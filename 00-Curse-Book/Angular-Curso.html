<!DOCTYPE html>
<html>
<head>
<title>Angular-Curso.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<head>
  <link rel="stylesheet" href="md.css">
</head>
<h1 id="curso-de-angular">Curso de Angular</h1>
<h2 id="c-o-n-t-e-n-i-d-o">C O N T E N I D O</h2>
<p>El siguiente documento presenta una descripción detallada de los conocimientos adquiridos y prácticas realizadas durante el curso de Angular de la plataforma Udemy. <a href="https://www.udemy.com/course/angular-fernando-herrera">Mas información Aquí: https://www.udemy.com/course/angular-fernando-herrera</a></p>
<h2 id="instalaci%C3%B3n">Instalación</h2>
<p>Se requiere:</p>
<p>Google Chrome
Visual Studio Code
Postman o extensión REST CLIENT de Code.
Mongo Compass
Git
Tener una cuenta en github o bitbucket, etc.</p>
<p>Para Mongo Compass ir al sitio https://www.mongodb.com/try/download/compass descargar y luego instalar el rpm ( o el ejecutable dependiendo de su sistema operativo)</p>
<p>Extensiones recomendadas para VSCode</p>
<pre><code>Angular Snippets
Angular Language Service
Angular Inline
Auto Close Tag
TypeScript importer
Rest Client
</code></pre>
<p>Installing Angular CLI</p>
<p>NOTA: Ver comentarios al final de esta sección para instalar la versión LTS compatible con Angular Cli.</p>
<p>Como usuario normal, Instalar o actualiza a la última versión de Node</p>
<pre class="hljs"><code><div>$ nvm install node
</div></code></pre>
<p>Si la versión instalada es &gt; 18.0.0 debe instalar la 16.10.x</p>
<pre class="hljs"><code><div>$ nvm install 16.10.0
$ nvm use 16.10.0
$ nvm alias default 16.10.0  (Esto hará que los editores como code usen la versión or default)
</div></code></pre>
<p>Instalar angular-CLI</p>
<pre class="hljs"><code><div>$ npm install -g @angular/cli
</div></code></pre>
<p>Probar Versión:</p>
<pre class="hljs"><code><div>$ ng --version

Angular CLI: 13.3.4
Node: 16.10.0
Package Manager: npm 7.24.0
OS: linux x64
</div></code></pre>
<p>NOTA: Luego de retomar el curso debí instalar la última versión estable soportada por Angular con este comando:</p>
<pre class="hljs"><code><div> nvm install --lts
 vm alias default 20.9.0
 npm uninstall -g @angular/cli
 npm install -g @angular/cli
</div></code></pre>
<h2 id="introducci%C3%B3n-a-angular">Introducción a Angular</h2>
<p>Angular es un framework, mantenido por google, viene con todo lo que se necesite para trabajar las aplicaciones. Las aplicaciones Angular son Modulares, es decir, todo el código se escribe en módulos independientes. (Antes de la V17 cuando se incuyen los standalone)</p>
<p>Existe 5 bloques fundamentales</p>
<ul>
<li>Componentes</li>
<li>Rutas</li>
<li>Directivas</li>
<li>Servicios</li>
<li>Módulos</li>
</ul>
<p><strong>Los componentes:</strong></p>
<ul>
<li>Es un bloque de código con segmento de HTML más una clase de Typescript. El objetivo es que cada componente sean bloques simples de código.</li>
</ul>
<p><strong>Servicio</strong></p>
<ul>
<li>Son Singleton que permiten trabajar la aplicación con información centralizada. Los componentes hacen uso de los serivcios, Los servicios exponen funcionalidades a otros servicios o componentes.</li>
</ul>
<p><strong>Directivas:</strong></p>
<ul>
<li>Existen 3 tipos de Directivas de Componentes, de estructuras y de atributos.</li>
</ul>
<p><strong>Directivas de Atributo</strong></p>
<p>Alteran la apariencia o comportamiento de un elemento del DOM y son usados como atributos de los elementos. (ngModel, ngClass, ngStyle)</p>
<p><strong>Directivas Estructurales</strong></p>
<p>Alteran la estructura del DOM, agregando, eliminando y manipulando los elementos a los que están unidos. (*ngIf, *ngFor, ngSwitch, ngPlural )</p>
<p><strong>Directivas de Componente</strong></p>
<p>Las Directivas de Componente son directivas con un Template. Los componentes tienen decoradores “@Component”, el componente es un decorador @Directive que es extendido con características propias de los templates.</p>
<p><strong>Rutas:</strong></p>
<p>Inidican que componentes renderizar dependiendo el URL ingresado por el usuario. Una Ruta típica de Angular tiene dos propiedades: path : una cadena que coincide con la URL en la barra de direcciones del navegador. component : el componente que el enrutador debe crear al navegar a esta ruta.</p>
<p><strong>Módulos:</strong>
Permiten agrupar componentes, incluso otros módulos. Se pueden descargar módulos existentes para usarlo dentro de la APP. Por ejemplo un módulo de Calendario.</p>
<h2 id="instalar-el-cli">Instalar el CLI</h2>
<p>Usaremos el Angular CLI (Command Line) de la siguiene manera</p>
<pre class="hljs"><code><div>$ npm install -g @angular/cli
</div></code></pre>
<h2 id="crear-nuevo-proyecto">Crear Nuevo proyecto</h2>
<p>para crear un nuevo proyecto con el CLI usamos el siguiente comando:</p>
<pre class="hljs"><code><div>$ ng new 01-bases --standalone false
</div></code></pre>
<p><code>--standalone false</code> Las últimas versiones de Angular (2023) ya no usan por dafault NGModule, pero durante el curso se usa la versión con NGModule, por lo tanto, esta parametro en false permite crear los proyectos tal como se hacia en las versiones anteriores, es decir de forma tradicional.</p>
<p>Esto genera el proyecto de pruebas y puede ejecutrase con el siguiente comando</p>
<pre class="hljs"><code><div>$ ng serve -o
</div></code></pre>
<p>NOTA: si el comando anterior genera algún error, realizar nuevamente el <code>npm install</code></p>
<h3 id="archivos-creados-por-el-ng-cli">Archivos creados por el ng cli.</h3>
<p>El proyecto cuenta con varios directorios y archivos</p>
<h2 id="archivos">Archivos</h2>
<p><code>.editconfig</code> archivo de configuración agregado por el plugin que permite agregar configuraciones para el editor.</p>
<p><code>.gitignore</code></p>
<p><code>angular.json</code> Es un archivo importante, muy pocas configuraciones se hacen aca, en este archivo le decimos a angular ciertas configuraciones para nuestras app.</p>
<p><code>karma.conf.js</code> Karma - a test runner</p>
<p><code>tsconfig</code> un grupo de archivos para configuraciones de typescript.</p>
<h3 id="directorios">Directorios</h3>
<p><code>.angular</code> archivo oculto que pocas veces se modifican, Ayuda a angular para detectar cambios, maneja el cache del proyecto, etc.</p>
<p><code>.vscode</code> Archivo del editor</p>
<p><code>dist</code>  Directorio de distribución</p>
<p><code>node_modules</code> Módulos de Node, dependencias.</p>
<p><code>src</code> Código fuente</p>
<p><code>src/app</code> Código fuente de nuestro proyecto</p>
<p><code>src/assets</code> Los Assets</p>
<p><code>src/environments</code> Archivos de configuración</p>
<p><code>src/main.ts</code> punto de entrada de nuestra App.</p>
<h2 id="primera-aproximaci%C3%B3n-de-un-componente">Primera aproximación de un componente</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-root'</span>,
  templateUrl: <span class="hljs-string">'./app.component.html'</span>,
  styleUrls: [<span class="hljs-string">'./app.component.css'</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent {
  title = <span class="hljs-string">'Contador App'</span>;
}
</div></code></pre>
<p><strong>selector</strong>: indica el elemento html que contendrá el componente una vez renderizado, en este caso es app-root ya que es la aplicación principal.</p>
<p><strong>templateUrl</strong> permite incluir un template existente escrito en HTML.</p>
<p>Podemos pasar variables al template al momento de crear la clase del componente, como en el siguiente caso:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent {
  title = <span class="hljs-string">'Contador App'</span>;
}
</div></code></pre>
<p><strong>Title</strong> puede luego usarse en el template de la siguiente forma:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hola Mundo<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Titulo desde componente: {{title}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<p>Esto generará:</p>
<pre class="hljs"><code><div>Hola Mundo
Titulo desde componente: Contador App
</div></code></pre>
<h2 id="m%C3%A9todos-en-los-componentes">Métodos en los componentes</h2>
<p>Podemos agregar métodos en nuestra clase y usarlos desde el template de la siguiente forma:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent {
  title: <span class="hljs-built_in">string</span> = <span class="hljs-string">'Contador App'</span>;
  numero: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>;

  acumular(valor: <span class="hljs-built_in">number</span>) {
    <span class="hljs-keyword">this</span>.numero += valor;
  }
}
</div></code></pre>
<p>Y consumirlo de la siguiente forma en el template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">" acumular(+1) "</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">" acumular(-1) "</span>&gt;</span>-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<h2 id="creando-nuevos-componentes">Creando nuevos componentes.</h2>
<p>Cuando la aplicación comienza a crecer, es necesario crear una estructura de directorios para organizar nuestro código. Cada componente con todos sus elementos se crea en sus propios directorios</p>
<p>Supongamos que vamos a crear un componente llamado <code>Heroe</code> pero este componente tiene una vista para renderizar información de un Heroe específico y tambien otro componente para mostrar información de los heroes en forma de lista, en este caso podriamos crear la siguiente estructura</p>
<pre class="hljs"><code><div>└── heroes
│       ├── heroe
│       │   ├── heroe.component.html
│       │   └── heroe.component.ts
│       └── listado
</div></code></pre>
<p>El directorio Heroe contiene el componente que muestra información de un heroe específico, mientras que el directorio listado, va a contener el componente para mostrar un listado de heroes.</p>
<p>De esta forma si necesitamos crear otro componente relacionado con heroes, creariamos un nuevo directorio dentro de heroes.</p>
<p>Veamos el componente Heroe.component.ts.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-heroe'</span>,
  templateUrl: <span class="hljs-string">'heroe.component.html'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HeroeComponent {
  nombre: <span class="hljs-built_in">string</span> = <span class="hljs-string">'IronMan'</span>;
  edad: <span class="hljs-built_in">number</span> = <span class="hljs-number">35</span>;

  <span class="hljs-keyword">get</span> nombreCapitalizado() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nombre.toUpperCase();
  }

  obtenerNombre(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.nombre}</span> - <span class="hljs-subst">${<span class="hljs-keyword">this</span>.edad}</span>`</span>;
  }

  cambiarNombre(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.nombre = <span class="hljs-string">'Spiderman'</span>;
  }

  cambiarEdad(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.edad = <span class="hljs-number">43</span>;
  }
}
</div></code></pre>
<p>Y su template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Heroe Component<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Nombre:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>{{nombre}}<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Edad:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>{{edad}}<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Función:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>{{obtenerNombre()}}<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>Caiptalizado:<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>{{nombreCapitalizado}}<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"cambiarNombre()"</span>&gt;</span>Cambiar Heroe<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"cambiarEdad()"</span>&gt;</span>Cambiar Edad<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>Notar como se usan las propiedades <strong>nombre</strong> y <strong>edad</strong> asi como una propiedad especial <strong>get</strong> llamada <strong>nombreCapitalizado</strong> y un método <strong>obtenerNombre</strong> Observe como se consumen esos elementos en el template.</p>
<p>Los métodos <strong>cambiarNombre()</strong> y <strong>cambiarEdad()</strong> cambian las propiedades nombre y edad del componente respectivamente. Al cambiar una propiedad, el componente volverá a renderizar todas aquellas partes (elementos del DOM) que dependen de la propiedad modificada.</p>
<h2 id="crear-componente-de-forma-autom%C3%A1tica">Crear Componente de forma automática.</h2>
<p>Para crear un componente con el ngCLI, usaremos el generador de componentes:</p>
<pre class="hljs"><code><div>$ ng generate component heroes/listado
</div></code></pre>
<p>Podemos usar la forma simplificada, por ejemplo</p>
<pre class="hljs"><code><div>$ ng g c heroes/listado
</div></code></pre>
<p>g: Generate
c: Component</p>
<p>El último valor se refiere al path y nombre del componente. Si soloamente se especifica un valor, el componente será creado en el directorio app/src.</p>
<p>Las salida del comando anterior debe ser:</p>
<pre class="hljs"><code><div>[fcruz@dev05 01-bases]$ ng generate component heroes/listdado
CREATE src/app/heroes/listdado/listdado.component.css (0 bytes)
CREATE src/app/heroes/listdado/listdado.component.html (23 bytes)
CREATE src/app/heroes/listdado/listdado.component.spec.ts (640 bytes)
CREATE src/app/heroes/listdado/listdado.component.ts (283 bytes)
UPDATE src/app/app.module.ts (586 bytes)
</div></code></pre>
<p>El componente creado se verá de la siguiente forma:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, OnInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-listdado'</span>,
  templateUrl: <span class="hljs-string">'./listdado.component.html'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ListdadoComponent <span class="hljs-keyword">implements</span> OnInit {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {}

  ngOnInit(): <span class="hljs-built_in">void</span> {}
}
</div></code></pre>
<p><strong>ngOnInit</strong> es parte del ciclo de vida de los componentes de angular, es un método que se dispara cuando el componente se ha inicializado, veremos estos ciclos de vida más adelante.</p>
<p>Por el momento podemos borra la referencia al OnInit, el archivo CSS y el archivo de pruebas.</p>
<h2 id="directiva-ngfor">Directiva *ngFor</h2>
<p>Podemos recorrer arreglos o elementos iterables y a la vez imprimir su contenido en el html, veamos este ejemplo:</p>
<p>Actualicemos nuestro componente:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-listado'</span>,
  templateUrl: <span class="hljs-string">'./listado.component.html'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ListadoComponent {
  heroeBorrado: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;

  heroes: <span class="hljs-built_in">string</span>[] = [<span class="hljs-string">'Spiderman'</span>, <span class="hljs-string">'Superman'</span>, <span class="hljs-string">'Hulk'</span>, <span class="hljs-string">'Ironman'</span>];

  borrarElemento() {
    <span class="hljs-keyword">this</span>.heroeBorrado = <span class="hljs-keyword">this</span>.heroes.shift() || <span class="hljs-string">''</span>;
  }
}
</div></code></pre>
<p>Y nuestro Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Listado de Heroes<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"borrarElemento()"</span>&gt;</span>Borrar Ùltimo<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Héroe Borrado: {{heroeBorrado}}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let heroe of heroes; let i = index"</span>&gt;</span>{{ i + 1}} - {{heroe}}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<p>Recorremos el arreglo Heroes y luego imprimimos el contenido en un <em><ul></em></p>
<h2 id="directivas-ngif-y-else">Directivas *ngIf y else</h2>
<p>Actualicemos nuestra plantilla con el siguiente código:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Listado de Heroes<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"this.heroes.length"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"borrarElemento()"</span>&gt;</span>
  Borrar Ùltimo
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"this.heroes.length == 0"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"reiniciarLista()"</span>&gt;</span>
  Reiniciar
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">h2</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"heroeBorrado.length; else noBorrado"</span>&gt;</span>
  Héroe Borrado: {{heroeBorrado}}
<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">noBorrado</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>No Borrado<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let heroe of heroes; let i = index"</span>&gt;</span>{{ i + 1}} - {{heroe}}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<p>La derctiva <strong>ng-if=&quot;expresion&quot;</strong> permite mostrar un elemento dependiendo del valor retornado al evaluar la expresión.</p>
<p>En el caso de los botones, se mostrará uno u otro en dependencia de la expresión &quot;this.heroes.length y &quot;this.heroes.length == 0 respectivamente.</p>
<p>También podemos incorporar un <strong>Else</strong> con una referencia local (hacia una plantilla local) tal como se hace con el mensage de borrado:</p>
<pre class="hljs"><code><div>&lt;h2 *ngIf=<span class="hljs-string">"heroeBorrado.length; else noBorrado"</span> &gt;Héroe Borrado: {{heroeBorrado}}&lt;<span class="hljs-regexp">/h2&gt;

&lt;ng-template #noBorrado&gt;
  &lt;h2&gt;No Borrado&lt;/</span>h2&gt;
&lt;<span class="hljs-regexp">/ng-template&gt;
</span></div></code></pre>
<p>Si <strong>heroeBorrado.length</strong> es true ejecutará el bloque inicial H2, caso contrario renderizará la plantilla con nombre <strong>noBorrado</strong> la cual imprimer un H2 con texto No Borrado.</p>
<h2 id="modulos">Modulos</h2>
<p>Implementaremos esta pantalla que consta de varios componentes, un listado y un formulario para agregar nuevos elementos al listado.
<br/>
<img src="./imagenes/basicapp.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" /></p>
<p>El objetivo de los módulos es ayudarnos a agrupar piezas de código que tienen relación entre sí. Permite tener un código mejor organizado, por ejemplo, actualmente tenemos los componentes:</p>
<ul>
<li>contador</li>
<li>Heroes
<ul>
<li>Heroe</li>
<li>Listado</li>
</ul>
</li>
</ul>
<p>Todos estos componentes son manajedos en el módulo principal de la APP:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@NgModule</span>({
  declarations: [
    AppComponent,
    ContadorComponent,
    HeroeComponent,
    ListadoComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
</div></code></pre>
<p>Notar como los componentes <strong>ContadorComponent</strong>, <strong>HeroeComponent</strong>, <strong>ListadoComponent</strong> son agregados al arreglo de las <strong>declarations</strong>, que pasa si nuestra app tiene 100 componentes? no podemos manejar 100 Componentes desde el APP Module, de modo que aca es donde entra la importancia de organizar el código en módulos.</p>
<p>Vamos a crear un nuevo Módulo para los componentes de Heroes:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { CommonModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common'</span>;
<span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { HeroeComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./heroe/heroe.component'</span>;
<span class="hljs-keyword">import</span> { ListadoComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./listado/listdado.component'</span>;

<span class="hljs-meta">@NgModule</span>({
  declarations: [HeroeComponent, ListadoComponent],
  exports: [HeroeComponent, ListadoComponent],
  imports: [CommonModule],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HeroesModule {}
</div></code></pre>
<p>Este archivo se crea en la raíz del directorio Heroes, con el nombre: <strong>heroes.module.ts</strong></p>
<pre class="hljs"><code><div>└── heroes
    ├── heroes.module.ts
    ├── heroe
    │   ├── heroe.component.html
    │   └── heroe.component.ts
    └── listado
        ├── listado.component.html
        └── listdado.component.ts
</div></code></pre>
<p>La sección <strong>declarations</strong> indica que componentes y declarativas pertenencen al módulo.</p>
<p>La sección de <strong>exports</strong> indica que componentes serán públicos y podrán ser usado por otros módulos que importen el módulo actual.</p>
<p>Mientras tanto la sección <strong>import</strong> indica que otros módulos serán usados por el módulo actual.</p>
<p>NOTA: el <strong>CommonModule</strong> se importa en aquellos componentes que utilizan directivas como *ngFor, *ngIf (entre otras) o pipes como currency pipe, Date pipe etc.</p>
<h2 id="crear-m%C3%B3dulos-con-el-generador-del-cli">Crear Módulos con el Generador del CLI</h2>
<p>Ejecute el comando:</p>
<pre class="hljs"><code><div>[fcruz@dev05 01-bases]$ ng generate module dbz
CREATE src/app/dbz/dbz.module.ts (189 bytes)
</div></code></pre>
<p>El modo autogenerado es:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { CommonModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common'</span>;

<span class="hljs-meta">@NgModule</span>({
  declarations: [],
  imports: [CommonModule],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> DbzModule {}
</div></code></pre>
<p>A continuación  agregamos un compomente al módulo recién creado:</p>
<pre class="hljs"><code><div>[fcruz@dev05 01-bases]$ ng generate component dbz/mainPage
CREATE src/app/dbz/main-page/main-page.component.css (0 bytes)
CREATE src/app/dbz/main-page/main-page.component.html (24 bytes)
CREATE src/app/dbz/main-page/main-page.component.spec.ts (641 bytes)
CREATE src/app/dbz/main-page/main-page.component.ts (286 bytes)
UPDATE src/app/dbz/dbz.module.ts (283 bytes)
</div></code></pre>
<p>Ahora en la sección de <strong>declarations</strong> de nuestro módulo tenemos el nuevo componente.</p>
<pre class="hljs"><code><div>declarations: [MainPageComponent];
</div></code></pre>
<p>Angula CLI no ingresa el nuevo componente en la lista de Exports del Módulo, ya que puede ser un componente privado.</p>
<h2 id="form-module">Form Module</h2>
<p>El siguiente bloque HTML genera un formulario el cual al hacer click en el botón Agregar refresca toda la página. en SPA esto no es un comportammiento aceptado.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Poder"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Agregar<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<p>Para evitar el evento de recargar la página durante el submit del Form podemos &quot;prevenir&quot; ese default event:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> (<span class="hljs-attr">submit</span>)=<span class="hljs-string">"agregar($event)"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Poder"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Agregar<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<p>Primero a nivel del form agregamos un eventListener <strong>submit</strong> y lo asignamos a la función agregar que recibe como parametro el evento que invoca el submit, en este caso el mismo submit del formulario.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> (<span class="hljs-attr">submit</span>)=<span class="hljs-string">"agregar($event)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<p>Luego agregamos la función en el componente:</p>
<pre class="hljs"><code><div>agregar(event: Event) {
    event.preventDefault();
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Agregar"</span>);
  }
</div></code></pre>
<p>La instrucción <strong>event.preventDefault();</strong> previene que el evento por default del Submit se ejecute, en este caso recargar la página por completo. Con estos cambios, logramos que al hacer click en el botón agregar (submit) no se recargue la página.</p>
<p>Angular al ser un Framework dispone de una serie de herramientas que facilitan el desarrollo. En este caso especifico, podemos evitarnos el trabajo de enviar el evento y llamar el preventDefault. Para ellos usaremos el módulo <strong>FormsModule</strong></p>
<p>Dado que el componente donde vamos a usarlo está contenido en el módulo dbz, vamos a proceder a importar el <em>FormsModule</em> en dicho módulo, de la siguiente forma:</p>
<pre class="hljs"><code><div>imports: [
    CommonModule,
    FormsModule
  ],
</div></code></pre>
<p>Ahora podemos usar el evento <strong>ngSubmit</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"agregar()"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Poder"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Agregar<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<p>Notar como se ha quitado el paramentro <strong>event</strong> y en la función agregar ya no es necesario agregar el <em>preventDefault</em>. Con estos cambios logramos el mismo efecto, no recargar la página, pero en este caso lo está manejando Angular.</p>
<h2 id="ngmodel">Ngmodel</h2>
<p>Creemos ahora un objeto en nuestro componente:</p>
<pre class="hljs"><code><div>nuevo: Personaje = {
  nombre: <span class="hljs-string">'Trunks'</span>,
  poder: <span class="hljs-number">14000</span>,
};
</div></code></pre>
<p>Modifiquemos nuestro input en el template para enlazar un campo del formulario con una propiedad del componente</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre"</span> [<span class="hljs-attr">value</span>]=<span class="hljs-string">"nuevo.nombre"</span> /&gt;</span>
</div></code></pre>
<p>Notar el uso de [] en value, esto hace que la expresión del otro lado del signo igual sea evaluada como una propiedad o función que retorna un dato desde el componente y será enlazado al control input.</p>
<p>Esto se denomina Enlace de datos unidireccional (<strong>One Way Data Binding</strong>) ya que el componente envía los datos al input, pero si cambiamos el input, el objeto en el componente NO cambia.</p>
<p>Para lograr que cualquier cambio en el input afecte el valor del objeto a nivel de componente podriamos agregar un <em>evenListener</em> y llamar un metodo para actualizar el valor:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span>
  <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre"</span>
  [<span class="hljs-attr">value</span>]=<span class="hljs-string">"nuevo.nombre"</span>
  (<span class="hljs-attr">input</span>)=<span class="hljs-string">"cambiarNombre()"</span>
/&gt;</span>
</div></code></pre>
<p>Y del lado del componente podríamos leer el <strong>event.target.value</strong> y actualizar el objeto.</p>
<pre class="hljs"><code><div>cambiarNombre(event: <span class="hljs-built_in">any</span>) {
  <span class="hljs-keyword">var</span> nombre = event.target.value;
  <span class="hljs-comment">//cambiar el valor nombre en el objeto...</span>
}
</div></code></pre>
<p>Nuevamente angular viene al rescate y nos hace la vida mas simple, podemos usar el <strong>ngModel</strong>, este crea una instancia de <strong>FormControl</strong> a partir de un modelo de dominio y la vincula a un elemento de control de formulario.</p>
<p>Cambiemos nuestro input a esto:</p>
<pre class="hljs"><code><div>&lt;input
  <span class="hljs-keyword">type</span>=<span class="hljs-string">"text"</span>
  placeholder=<span class="hljs-string">"Nombre"</span>
  name=<span class="hljs-string">"nombre"</span>
  [(ngModel)]=<span class="hljs-string">"nuevo.nombre"</span>
/&gt;
</div></code></pre>
<p>** [(ngModel)]=&quot;nuevo.nombre&quot;**</p>
<p>Primero, el uso de [] indica que haremos el binding y el uso de () indica que emitiremos un evento, al igual que antes, pero, ngModel se encargará de hacer todo el trabajo, no necesitamos crear un mètodo adicional que acepte el valor y lo guarde en el componente, lo cual aún podría ser necesario si hay que realizar algùn tratamiento especial del dato, pero en este caso el código es suficiente para hacer el binding en los dos sentidos.</p>
<p>Agreguemos un arreglo en nuestro componente:</p>
<pre class="hljs"><code><div>personajes: Personaje[] =
  [
    {
      nombre: <span class="hljs-string">'Goku'</span>,
      poder: <span class="hljs-number">15000</span>
    },
    {
      nombre: <span class="hljs-string">'Vegeta'</span>,
      poder: <span class="hljs-number">7500</span>
    },
  ];
</div></code></pre>
<p>Y el siguiente mètodo:</p>
<pre class="hljs"><code><div>agregar() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nuevo.nombre.trim().length == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span>
    }

    <span class="hljs-keyword">this</span>.personajes.push(<span class="hljs-keyword">this</span>.nuevo);
    <span class="hljs-keyword">this</span>.nuevo = {
      nombre: <span class="hljs-string">''</span>,
      poder: <span class="hljs-number">0</span>
    }
  }
</div></code></pre>
<p>Cambiemos nuestra template para renderizar la lista de personajes desde un arreglo con ngFor</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Personajes<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let personaje of personajes; let pos = index"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-primary"</span>&gt;</span>{{pos + 1}}.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    {{personaje.nombre}} - {{personaje.poder | number}}
   <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<p>Notar que luego de personajes poder estamos usando un pipe, number, el cual hace que el valor <strong>poder</strong> se imprima como un nùmero (separador de miles, decimales, etc.)</p>
<p>Otro elemento a notar es el <code>let pos = index</code> dentro del ngFor, hay otras variables que se pueden usar como el <em>isFirst</em>, <em>isLast</em>, etc.</p>
<p>Listo, con esto podemos agregar elementos a la lista al momento de presionar &quot;agregar&quot;.</p>
<h2 id="ngclass">nGClass</h2>
<p>Podemos aplicar una clase basada en una condición, por ejemplo si queremos agregar al <em><li></em> un color de fondo, podríamos usar las variables del for y el ngClass.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Personajes<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let personaje of personajes; let pos = index; let isEven = even;"</span> 
  <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span> 
  [<span class="hljs-attr">ngClass</span>] = <span class="hljs-string">"{'list-group-item-success': isEven}"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-primary"</span>&gt;</span>{{pos + 1}}.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    {{personaje.nombre}} - {{personaje.poder | number}}
   <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<p><code>[ngClass] = &quot;{'list-group-item-success': isEven}&quot;&gt;</code> agrega la clase <em>list-group-item-success</em> únicamente a los elementos Pares de la lista.</p>
<p>NOTA: dado que el índice del ciclo inicia en 0, se toma como par realmente los impares.
<br/>
<img src="./imagenes/ngClassExample.png" alt="ngClass ejemplo" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" /></p>
<h2 id="crear-componentes-hijos">Crear Componentes Hijos</h2>
<p>Cuando un componente crece en complejidad, una señal puede ser muchos métodos en el componente o mucho código html en el template se aconseja crear componentes hijos para reducir dicha complejidad, por ejemplo dado el siguiente template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Drangon Ball Z<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Personajes<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let personaje of personajes; let pos = index; let isEven = even;"</span> 
      <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span> 
      [<span class="hljs-attr">ngClass</span>] = <span class="hljs-string">"{'list-group-item-success': isEven}"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-primary"</span>&gt;</span>{{pos + 1}}.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        {{personaje.nombre}} - {{personaje.poder | number}}
      <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Agregar<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"agregar()"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
        <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre"</span>
        <span class="hljs-attr">name</span>=<span class="hljs-string">"nombre"</span>
        [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"nuevo.nombre"</span>
      /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
        <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span>
        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Poder"</span>
        <span class="hljs-attr">name</span>=<span class="hljs-string">"poder"</span>
        [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"nuevo.poder"</span>
      /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Agregar<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Es probable que lo ideal sería separar el listado y el formulario en componentes separados. Vamos a proceder a reliazar dicha separación de componentes. En la línea de comandos generamos el nuevo componente</p>
<pre class="hljs"><code><div>$ ng generate component dbz/personajes --skipTests
</div></code></pre>
<p>Luego en el template del nuevo componente moveremos el HTML de la lista</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Personajes<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let personaje of personajes; let pos = index; let isEven = even;"</span> 
  <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span> 
  [<span class="hljs-attr">ngClass</span>] = <span class="hljs-string">"{'list-group-item-success': isEven}"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-primary"</span>&gt;</span>{{pos + 1}}.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    {{personaje.nombre}} - {{personaje.poder | number}}
   <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<p>Luego necesitamos pasar la lista de personajes que es manejado por el componente main-page para el nuevo componente pueda renderizarlo.</p>
<p>En el nuevo componente usaremos @Input para indicar que el objeto personajes será entregado por el componente padre.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, Input } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-personajes'</span>,
  templateUrl: <span class="hljs-string">'./personajes.component.html'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> PersonajesComponent {
  <span class="hljs-meta">@Input</span>() personajes: <span class="hljs-built_in">any</span>[] = [];
}
</div></code></pre>
<p>Y finalmente el componente padre debe pasar el valor de personajes de la siguiente forma&gt;</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">app-personajes</span> [<span class="hljs-attr">personajes</span>]=<span class="hljs-string">"personajes"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">app-personajes</span>&gt;</span>
</div></code></pre>
<p>Recordemos que el uso de [propiedad] = &quot;valor&quot; indica que en el componente desitno existe una propiedad de nombre <strong>propiedad</strong> la cual va a recibir el valor externo de <strong>valor</strong></p>
<p>Podríamos crear un alias en el input para renombrar la propiedad:</p>
<pre class="hljs"><code><div>  <span class="hljs-meta">@Input</span>(<span class="hljs-string">'data'</span>) personajes: <span class="hljs-built_in">any</span>[] = [];
</div></code></pre>
<p>Luego tendríamos que cambiar el template del componente hijo para que use la variable Data:</p>
<pre class="hljs"><code><div>&lt;li *ngFor=<span class="hljs-string">"let personaje of data"</span>&gt;
    {{personaje.nombre}} - {{personaje.poder | <span class="hljs-built_in">number</span>}}
  &lt;<span class="hljs-regexp">/li&gt;
</span></div></code></pre>
<h2 id="usando-la-interfaz-personaje">Usando la Interfaz Personaje</h2>
<p>En La declaración siguiente sería idela usar la interfaz personaje que habiamos definido en el componente main-page:</p>
<pre class="hljs"><code><div>  <span class="hljs-meta">@Input</span>(<span class="hljs-string">'data'</span>) personajes: <span class="hljs-built_in">any</span>[] = [];
</div></code></pre>
<p>Asi que en lugar de any[] deberíamos de tener el tipo <strong>Personaje[]</strong> para ello vamos a crear nuestra interfaz en un nivel superior, de modo que ambos componentes pueda usarla.</p>
<p>Crear directorio <strong>interfaces</strong> en el directorio <strong>dbz</strong> y luego crear el archivo <strong>personaje.interface.ts</strong> con el siguiente contenido:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Personaje {
  nombre: <span class="hljs-built_in">string</span>;
  poder: <span class="hljs-built_in">number</span>;
}
</div></code></pre>
<p>Finalmente eliminamos el any y colocamos el tipo correcto.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Input</span>() personajes: Personaje[] = []
</div></code></pre>
<p>Se tiene que corregir el main-page ya que alli estabamos usando la misma interfaz pero fue removida,</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Personaje } <span class="hljs-keyword">from</span> <span class="hljs-string">'../interfaces/dbz.interface'</span>;

personajes: Personaje[] =
  [
    {
      nombre: <span class="hljs-string">'Goku'</span>,
      poder: <span class="hljs-number">15000</span>
    },
    {
      nombre: <span class="hljs-string">'Vegeta'</span>,
      poder: <span class="hljs-number">7500</span>
    },
  ];
</div></code></pre>
<p>Listo todo debeía de funcionar exactamente igual.</p>
<h2 id="crear-otro-componente-hijo">Crear Otro Componente Hijo</h2>
<p>Vamos a extraer el formulario y la acción agregar en un componente hijo,</p>
<pre class="hljs"><code><div>$ ng generate component dbz/agregar
</div></code></pre>
<p>Vamos a mover parte del código html del componente main-page al template del agregar, quedaría de la siguiente forma:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Agregar<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"agregar()"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
    <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
    <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre"</span>
    <span class="hljs-attr">name</span>=<span class="hljs-string">"nombre"</span>
    [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"nuevo.nombre"</span>
  /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
    <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span>
    <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Poder"</span>
    <span class="hljs-attr">name</span>=<span class="hljs-string">"poder"</span>
    [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"nuevo.poder"</span>
  /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Agregar<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<p>De igual manera, vamos a mover código del component main-page (archivo typescript) al nuevo componente:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, Input, OnInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { Personaje } <span class="hljs-keyword">from</span> <span class="hljs-string">'../interfaces/dbz.interface'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-agregar'</span>,
  templateUrl: <span class="hljs-string">'./agregar.component.html'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AgregarComponent {
  <span class="hljs-meta">@Input</span>() personajes: Personaje[] = [];

  <span class="hljs-meta">@Input</span>() nuevo: Personaje = {
    nombre: <span class="hljs-string">''</span>,
    poder: <span class="hljs-number">0</span>,
  };

  agregar() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nuevo.nombre.trim().length == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">this</span>.personajes.push(<span class="hljs-keyword">this</span>.nuevo);
    <span class="hljs-keyword">this</span>.nuevo = {
      nombre: <span class="hljs-string">''</span>,
      poder: <span class="hljs-number">0</span>,
    };
  }
}
</div></code></pre>
<p><strong>personajes</strong> y <strong>nuevo</strong> son propiedades que se pasarán desde el componente padre.</p>
<p>Y nuestras plantilla html de nuestro main-page component quedará asi:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Drangon Ball Z<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app-personajes</span> [<span class="hljs-attr">personajes</span>]=<span class="hljs-string">"personajes"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">app-personajes</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app-agregar</span> [<span class="hljs-attr">personajes</span>]=<span class="hljs-string">"personajes"</span> [<span class="hljs-attr">nuevo</span>]=<span class="hljs-string">"nuevo"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-agregar</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Todo debe de funcionar igual, pero tenemos un problema o un error de diseño, resulta que el metodo agregar del componente hijo recibe como referencia el arreglo de personajes y el componente hijo es el que se encarga de hacer el push al arreglo que se le pasa por medio del @Input, esto no es correcto, y lo que debería de suceder es que el componente hijo emita un eveto a su Padre y sea el quien modifique el arreglo, el cual esta definido en su scope.</p>
<p>En otras palabras, si un objeto es manejado por un componente, y un segundo componente intenta modificarlos, la forma correcta es que el segundo componente emita algún tipo de evento que sea escuchado por el primer componente (el dueño del objeto) y sea éste el que al final actualice sus propiedades.</p>
<h2 id="outputs-y-eventemiter">Outputs y EventEmiter</h2>
<p>Haremos cambios en el componente <em>agregar</em>, primero no vamos a pasar el arreglo <em>personajes</em>, únicamente vamos a pasar el objeto nuevo, para inicializar los campos del fomulario. Recordemos que estamos usando <em>ngModel</em> para habilitar el <strong>two way binding</strong> entre el formulario y el objeto <em>nuevo</em></p>
<p>En el template del main-page dejemos el app-agregar de la siguiente forma:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">app-agregar</span> [<span class="hljs-attr">nuevo</span>]=<span class="hljs-string">"nuevo"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-agregar</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Y en el componente <em>agregar</em>, vamos a crear una nueva propiedad, usaremos <strong>@Output()</strong> y será de tipo <em>EventEmitter</em>.</p>
<pre class="hljs"><code><div>  <span class="hljs-meta">@Output</span>() onNewPersonaje: EventEmitter&lt;Personaje&gt; = <span class="hljs-keyword">new</span> EventEmitter();
</div></code></pre>
<p>Cuando hacemos click en <em>agregar</em>, el <em>ngModule</em> mapea los valores del formulario al objeto <strong>nuevo</strong> definido en el componente <em>agregar</em> y por lo tanto necesitamos emitir un evento con este nuevo personaje para que el evento padre pueda obtener ese valor y proceder con la actualización del objeto <em>Personajes</em>.</p>
<p>Así quedaría parte de nuestro <em>agregarComponent</em>:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Output</span>() onNewPersonaje: EventEmitter&lt;Personaje&gt; = <span class="hljs-keyword">new</span> EventEmitter();

  agregar() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nuevo.nombre.trim().length == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span>
    }

    <span class="hljs-keyword">this</span>.onNewPersonaje.emit(<span class="hljs-keyword">this</span>.nuevo)

    <span class="hljs-keyword">this</span>.nuevo = {
      nombre: <span class="hljs-string">''</span>,
      poder: <span class="hljs-number">0</span>
    }
  }
</div></code></pre>
<p>Ahora necesitamos capturar ese evento en nuestro <em>main-page-component</em>, es decir el coponente padre y crear la lógica necesaria para agregar el elemento nuevo al arreglo de personajes:</p>
<p><em>onNewPersonaje</em> es el nombre del <em>customEvent</em> que hemos creado en el componente hijo, entonces con <em>()</em> vamos a especificar el nombre de ese evento y al recibirlo, vamos a mandar a llamar un nuevo método, que será el responsable de agregar el elemento al arreglo.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">app-agregar</span> [<span class="hljs-attr">nuevo</span>]=<span class="hljs-string">"nuevo"</span> (<span class="hljs-attr">onNewPersonaje</span>)=<span class="hljs-string">"agregarNuevoPersonaje($event)"</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">app-agregar</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Finalmente creamos el método en el componente Padre:</p>
<pre class="hljs"><code><div>agregarNuevoPersonaje( arg: Personaje ) {
  <span class="hljs-keyword">this</span>.personajes.push(arg);
}
</div></code></pre>
<p>Y listo, ahora el componente Padre, dueño del arreglo personaje, es quien actualiza dicho arreglo y no otro componente.</p>
<h2 id="debugger-con-vs-code">Debugger con VS Code</h2>
<p>Presione F5, en el archivo que se muestra cambiar el puerto al puerto donde corre la app de Angular-</p>
<pre class="hljs"><code><div>{
  <span class="hljs-comment">// Use IntelliSense to learn about possible attributes.</span>
  <span class="hljs-comment">// Hover to view descriptions of existing attributes.</span>
  <span class="hljs-comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span>
  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"0.2.0"</span>,
  <span class="hljs-attr">"configurations"</span>: [
    {
      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"pwa-chrome"</span>,
      <span class="hljs-attr">"request"</span>: <span class="hljs-string">"launch"</span>,
      <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Launch Chrome against localhost"</span>,
      <span class="hljs-attr">"url"</span>: <span class="hljs-string">"http://localhost:4200"</span>,
      <span class="hljs-attr">"webRoot"</span>: <span class="hljs-string">"${workspaceFolder}"</span>
    }
  ]
}
</div></code></pre>
<p>Cerrar Archivo y presionar nuevamente F5, para esto necesita que se esté ejecutando:</p>
<pre class="hljs"><code><div>$ ng server -o
</div></code></pre>
<h2 id="servicios">Servicios</h2>
<p>Los servicios es uno de los conceptos más fuertes de Angular, permite implementar patrones de diseño sin la necesidad de Redux por ejemplo.</p>
<p>Los servicios es otra forma de organizar el código, a medida que nuestra APP crece en número de componentes, es posible que muchos de estos componentes dupliquen cierto código, cierta funcionalidad. Podemos extraer dicha funcionalidad a un servicio.</p>
<p>Dado que los servicios son compartidos por varios componentes, suelen crearse dentro de módulos compartidos, que pueden llamarse common, shared, etc.</p>
<p>Otra de las utilidades de los servicios parte del hecho de que los componentes no deberían buscar o guardar datos directamente, el acceso a los datos es una tarea que debe delegarse a un servicio.</p>
<p>Tambièn los servicios son una forma para compartir funcionalidades entre clases que no se conocen entre si.</p>
<h2 id="creando-un-servicio-de-manera-manual">Creando un servicio de Manera Manual</h2>
<p>En el modulo de <em>dbz</em>, creemos una carpeta llamada services, en este caso, los servicios que se guarden en esta carpeta serán utilizado por todos los componentes del módulo <em>dbz</em>. Si necesitaramos uno a nivel global se puede crear la carpeta services en el directorio <em>app/</em></p>
<p>Dentro del nuevo directorio crear el archivo <strong>dbz.service.ts</strong></p>
<p>Crearmos un servicio con un constructor sencillo</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> DbzService {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Servicio Inicializado'</span>);
  }
}
</div></code></pre>
<p>Luego en el dbz.module.ts agregaremos una nueva sección:</p>
<pre class="hljs"><code><div>providers: [DbzService];
</div></code></pre>
<p>Los <em>providers</em> es un arreglo de Servicios.</p>
<p>Hasta el momento el servicio no ha sido utilizado por ningún modulo, clase, servicio, etc, por lo tanto el constructor no se ha ejecutado aún.</p>
<p>Vamos a refactorizar un poco el código del main-page component, recordemos este componente como ha sido desarrollado:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { Personaje } <span class="hljs-keyword">from</span> <span class="hljs-string">'../interfaces/dbz.interface'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-main-page'</span>,
  templateUrl: <span class="hljs-string">'./main-page.component.html'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MainPageComponent {
  nuevo: Personaje = {
    nombre: <span class="hljs-string">'Maestro Roshi'</span>,
    poder: <span class="hljs-number">1000</span>,
  };

  personajes: Personaje[] = [
    {
      nombre: <span class="hljs-string">'Goku'</span>,
      poder: <span class="hljs-number">15000</span>,
    },
    {
      nombre: <span class="hljs-string">'Vegeta'</span>,
      poder: <span class="hljs-number">7500</span>,
    },
  ];

  agregarNuevoPersonaje(arg: Personaje) {
    <span class="hljs-keyword">this</span>.personajes.push(arg);
  }
}
</div></code></pre>
<p>Tal como se indicó anteriormente, el componente no debe ser responsable de buscar o guardar la data, eso se tiene que delegar a un servicio.</p>
<p>Vamos a usar la Injección de dependencias. El servicio <em>dbzService</em> ha sido definido como <em>@Injectable</em> con lo cual podemos inyectarlo en el constructor de cualquier componente. Obviamente porque también hemos dicho que este servicio es un provider.</p>
<p>Si agregamos el constructor al main-page componente</p>
<pre class="hljs"><code><div><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> dbzService: DbzService </span>) {

}
</div></code></pre>
<p>Esto inyecta el servicio y ejecutará el constructor del servicio. Si adicionamos el mismo contructor a otro componente, Angular solo creará una única vez el servicio y podrá ser usado por el sergundo componente. Es decir, nuestro constructor solo se ejecuta una sola vez.</p>
<p>Podríamos hacer estos cambios:</p>
<ul>
<li>
<p>El primer cambio es mover el arreglo de personajes del main-page componente al servicio.</p>
</li>
<li>
<p>El siguiente cambio es crear una propiedad <em>personajes</em> en el componente y luego inicializarlo desde el Servicio. Por el momento lo haremos desde el contructor, pero lo idea es usar los ciclos de vida del componente para inicializar datos.</p>
</li>
</ul>
<p>Eso funcionaría, Pero podríamos aplicar otro enfoque, el siguiente:</p>
<ul>
<li>Establecer un método <em>get personajes()</em> que retorne la lista de personajes que viene del servicio, este seria como la operación de búsqueda de la Data que queremos tener en el componente. Recordemos que este componente usa un componente hijo <em>personaje</em> el cual crea la lista de personajes</li>
</ul>
<p>Pero ciertamente el <em>main-page</em> no necesita manejar la lista de personajes, esto podría hacerlo el componente <em>personaje</em> quien es al final el que imprime la lista, entonce podemos inyectar el servicio directamente el el componente hijo.</p>
<h2 id="m%C3%A9todos-en-el-servicio">Métodos en el Servicio</h2>
<p>Tal como lo hemos indicado, el servicio es el reponsable de actualizar los datos, en este caso necesitamos un método <em>AgregarPersonaje</em> a nivel del servicio y èste debe ser llamado por el componente <em>AgregarPersonaje</em>.</p>
<p>Este componente anteriormente emitía un evento, y el <em>main-page</em> caputaraba ese evento y actualizaba los datos, pues ahora no es necesario emitir evento puesto que el servicio es el que se encarga de agregar los datos.</p>
<p>Esto debe de eliminarse</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Output</span>() onNewPersonaje: EventEmitter&lt;Personaje&gt; = <span class="hljs-keyword">new</span> EventEmitter();
</div></code></pre>
<p>Al final el código quedaría de la siguiente forma:</p>
<p>Servicio:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { Personaje } <span class="hljs-keyword">from</span> <span class="hljs-string">'../interfaces/dbz.interface'</span>;

<span class="hljs-meta">@Injectable</span>()
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> DbzService {
  <span class="hljs-keyword">private</span> _personajes: Personaje[] = [
    {
      nombre: <span class="hljs-string">'Goku'</span>,
      poder: <span class="hljs-number">15000</span>,
    },
    {
      nombre: <span class="hljs-string">'Vegeta'</span>,
      poder: <span class="hljs-number">7500</span>,
    },
  ];

  <span class="hljs-keyword">get</span> personajes(): Personaje[] {
    <span class="hljs-keyword">return</span> [...this._personajes];
  }

  agregarPersonaje(personaje: Personaje) {
    <span class="hljs-keyword">this</span>._personajes.push(personaje);
  }
}
</div></code></pre>
<p>Main-Page Component:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { Personaje } <span class="hljs-keyword">from</span> <span class="hljs-string">'../interfaces/dbz.interface'</span>;
<span class="hljs-keyword">import</span> { DbzService } <span class="hljs-keyword">from</span> <span class="hljs-string">'../services/dbz.service'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-main-page'</span>,
  templateUrl: <span class="hljs-string">'./main-page.component.html'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MainPageComponent {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {}

  nuevo: Personaje = {
    nombre: <span class="hljs-string">'Maestro Roshi'</span>,
    poder: <span class="hljs-number">1000</span>,
  };
}
</div></code></pre>
<p>Main-Page template</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Drangon Ball Z<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app-personajes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-personajes</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">app-agregar</span> [<span class="hljs-attr">nuevo</span>]=<span class="hljs-string">"nuevo"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">app-agregar</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Personaje Component:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, Input } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { Personaje } <span class="hljs-keyword">from</span> <span class="hljs-string">'../interfaces/dbz.interface'</span>;
<span class="hljs-keyword">import</span> { DbzService } <span class="hljs-keyword">from</span> <span class="hljs-string">'../services/dbz.service'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-personajes'</span>,
  templateUrl: <span class="hljs-string">'./personajes.component.html'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> PersonajesComponent {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> dbzService: DbzService</span>) {}

  <span class="hljs-keyword">get</span> personajes() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.dbzService.personajes;
  }
}
</div></code></pre>
<p>Personaje Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Personajes<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let personaje of personajes"</span>&gt;</span>
    {{personaje.nombre}} - {{personaje.poder | number}}
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<p>Agregar Component:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, Input } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { Personaje } <span class="hljs-keyword">from</span> <span class="hljs-string">'../interfaces/dbz.interface'</span>;
<span class="hljs-keyword">import</span> { DbzService } <span class="hljs-keyword">from</span> <span class="hljs-string">'../services/dbz.service'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-agregar'</span>,
  templateUrl: <span class="hljs-string">'./agregar.component.html'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AgregarComponent {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> dbzService: DbzService</span>) {}

  <span class="hljs-meta">@Input</span>() nuevo: Personaje = {
    nombre: <span class="hljs-string">''</span>,
    poder: <span class="hljs-number">0</span>,
  };

  agregar() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nuevo.nombre.trim().length == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">this</span>.dbzService.agregarPersonaje(<span class="hljs-keyword">this</span>.nuevo);

    <span class="hljs-keyword">this</span>.nuevo = {
      nombre: <span class="hljs-string">''</span>,
      poder: <span class="hljs-number">0</span>,
    };
  }
}
</div></code></pre>
<p>Agregar Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Agregar<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">form</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"agregar()"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
    <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
    <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre"</span>
    <span class="hljs-attr">name</span>=<span class="hljs-string">"nombre"</span>
    [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"nuevo.nombre"</span>
  /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
    <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span>
    <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Poder"</span>
    <span class="hljs-attr">name</span>=<span class="hljs-string">"poder"</span>
    [(<span class="hljs-attr">ngModel</span>)]=<span class="hljs-string">"nuevo.poder"</span>
  /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>Agregar<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<h2 id="un-par-de-cambios-m%C3%A1s">Un par de cambios más</h2>
<p>Agregamos un método eliminar personaje para permitir remover de la lista un personaje:</p>
<p>En el servicio agregamos el nuevo método:</p>
<pre class="hljs"><code><div>eliminarPersonaje( index: <span class="hljs-built_in">number</span> ) {
    <span class="hljs-keyword">this</span>._personajes.splice(index, <span class="hljs-number">1</span>);
  }
</div></code></pre>
<p>En el template de la lista de personajes, agregamos un botón al final y adicionalmente reordenamos para mejorar la interfaz, incluimos algunas clases de bootstrap también</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Personajes<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let personaje of personajes; let pos = index; let isEven = even;"</span> 
  <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item d-flex justify-content-between align-items-center"</span> 
  [<span class="hljs-attr">ngClass</span>] = <span class="hljs-string">"{'list-group-item-success': isEven}"</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-primary"</span>&gt;</span>{{pos + 1}}.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{personaje.nombre}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> - <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>Power: <span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>{{personaje.poder | number}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"onEliminarPersonaje(pos)"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-danger"</span> &gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    
   <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<p>Finalmente enlazamos la vista con el servicio, esto lo logramos agregando el siguiente método al componente de personajes</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> onEliminarPersonaje(index: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.dbzService.eliminarPersonaje(index);
  }
</div></code></pre>
<h2 id="implementar-identificador-%C3%BAnico-para-cada-personaje">Implementar identificador único para cada personaje</h2>
<p>En lugar de eliminar por index, vamos a eliminar por ID, y agregaremos una libreria que nos permita generar códigos UUID.</p>
<p>Instalamos:</p>
<pre class="hljs"><code><div>$ npm install uuid
</div></code></pre>
<p>NOTA: algunas librerías están escritas en Javascript, para poder usarlas en nuestro ambiente de desarrollo con typescript, debemos importar su archivo de definición de tipos.</p>
<pre class="hljs"><code><div>$ npm install --save-dev @types/uuid
</div></code></pre>
<p>Luego modificamos la interfaz para incluir el nuevo campo id</p>
<pre class="hljs"><code><div> export interface Personaje {
<span class="hljs-addition">+  id: string;</span>
   nombre: string;
   poder: number;
 }

</div></code></pre>
<p>En es servicio haremos estos cambios</p>
<pre class="hljs"><code><div> import { Injectable } from "@angular/core";
<span class="hljs-addition">+import { v4 as uuid } from "uuid";</span>
 import { Personaje } from "../interfaces/dbz.interface";
 
 @Injectable()
@@ -7,18 +8,22 @@ export class DbzService {
   private _personajes: Personaje[] =
   [
     {
<span class="hljs-addition">+      id: uuid(),</span>
       nombre: 'Goku',
       poder: 15000
     },
</div></code></pre>
<p>Y en nuestro agregar Component, justo antes de guardar en la lista el nuevo personaje, generamos el UUID()</p>
<pre class="hljs"><code><div>agregar() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.nuevo.nombre.trim().length == <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span>
    }

    <span class="hljs-comment">//Generar un id unico</span>
    <span class="hljs-keyword">this</span>.nuevo.id = uuid();
    
    <span class="hljs-keyword">this</span>.dbzService.agregarPersonaje(<span class="hljs-keyword">this</span>.nuevo);

    <span class="hljs-keyword">this</span>.nuevo = {
      id: <span class="hljs-string">''</span>,
      nombre: <span class="hljs-string">''</span>,
      poder: <span class="hljs-number">0</span>
    }
  }
</div></code></pre>
<h2 id="generar-build-de-la-applicaci%C3%B3n">Generar Build de la Applicación</h2>
<pre class="hljs"><code><div>$ ng build --prod
</div></code></pre>
<p>En versiones recientes, no es necesario el parametro --prod</p>
<pre class="hljs"><code><div>[fcruz@dev05 01-bases]$ ng build --prod
Option &quot;--prod&quot; is deprecated: No need to use this option as this builder defaults to configuration &quot;production&quot;.
✔ Browser application bundle generation complete.
✔ Copying assets complete.
✔ Index html generation complete.

Initial Chunk Files           | Names         |  Raw Size | Estimated Transfer Size
main.6b9c85c0379b42ab.js      | main          | 147.28 kB |                41.18 kB
polyfills.f21860001d995b00.js | polyfills     |  33.01 kB |                10.64 kB
runtime.d15e317f76fa3172.js   | runtime       |   1.04 kB |               600 bytes
styles.dc3e7ac02ccd86e8.css   | styles        | 464 bytes |               218 bytes

                              | Initial Total | 181.78 kB |                52.62 kB

Build at: 2022-05-13T00:17:29.695Z - Hash: 9ca419420a6538bb - Time: 10607ms
</div></code></pre>
<p>Se generan los siguientes archivos:</p>
<ul>
<li>main.js: Contiene nuestro código</li>
<li>polyills: contiene funciones para asegurar que nuestra app se pueda ejecutar en diferentes browsers.</li>
<li>runtime: código utilizado por Webpack para cargar código en tiempo de ejecución</li>
<li>style.js: Nuestros estilos css.</li>
</ul>
<p>El hash en el nombre del archivo garantiza que se utilice la última versión del archivo en lugar del archivo en cache.</p>
<p>Esta información es almacenada en el directorio /dist</p>
<pre class="hljs"><code><div>[fcruz@dev05 01-bases]$ tree dist/
dist/
└── bases
    ├── 3rdpartylicenses.txt
    ├── favicon.ico
    ├── index.html
    ├── main.6b9c85c0379b42ab.js
    ├── polyfills.f21860001d995b00.js
    ├── runtime.d15e317f76fa3172.js
    └── styles.dc3e7ac02ccd86e8.css

1 directory, 7 files
</div></code></pre>
<h2 id="desplegando-nuestra-applicaci%C3%B3n">Desplegando nuestra applicación</h2>
<p>una vez construido el proyecto, podemos copiar el directorio bases y servirlo en un servidor web.</p>
<p>Eso genera los archivos en el directorio dist.</p>
<p>Podemos agregar esta configuración en apache:</p>
<pre class="hljs"><code><div>&lt;VirtualHost *:80&gt;
    ServerName localhost
    ServerAlias udemy-angular.com 127.0.0.1

    DocumentRoot /home/fcruz/Cursos/udemy/angular/code/udemy-angular/01-bases/dist/bases

    &lt;Directory /home/fcruz/Cursos/udemy/angular/code/udemy-angular/01-bases/dist/bases&gt;
        Options Indexes FollowSymLinks
        AllowOverride All
        Require all granted
    &lt;/Directory&gt;

    ErrorLog /var/log/httpd/angular-app_error.log
    CustomLog /var/log/httpd/angular-app_access.log combined
&lt;/VirtualHost&gt;

</div></code></pre>
<p>Luego debemos cambiar permisos para que el httpd pueda ejecutar nuestros archivos</p>
<pre class="hljs"><code><div>sudo chcon -R -t httpd_sys_content_t /home/fcruz/Cursos

sudo chmod +x /home /home/fcruz /home/fcruz/Cursos /home/fcruz/Cursos/udemy /home/fcruz/Cursos/udemy/angular /home/fcruz/Cursos/udemy/angular/code /home/fcruz/Cursos/udemy/angular/code/udemy-angular /home/fcruz/Cursos/udemy/angular/code/udemy-angular/01-bases

sudo chmod -R +r /home/fcruz/Cursos/udemy/angular/code/udemy-angular/01-bases

sudo systemctl restart httpd
</div></code></pre>
<p>Agregamos en el /etc/hosts</p>
<pre class="hljs"><code><div>127.0.0.1 udemy-angular.com
</div></code></pre>
<p>probar link:</p>
<p><a href="http://udemy-angular.com">http://udemy-angular.com</a></p>
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-nueva-aplicaci%C3%B3n">Nueva Sección: Nueva Aplicación:</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>La sección contendrá nuestra primera aplicación real de Angular, este es un breve listado de los temas fundamentales:</p>
<pre><code>Modularización de la aplicación

Estructura de la aplicación de media a gran escala

Componentes

ViewChild

Consumir servicios

Historial de búsquedas

Uso de Api Keys

Guardar información en local storage.

Peticiones HTTP

Animaciones mediante css
</code></pre>
<p>Vamos a construir una nueva applicación que consiste en un buscador de GIF, contiene un historial y un grid de resultados.</p>
<br/>
<img src="./imagenes/gifapp.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<p>Creamos el nuevo proyecto</p>
<pre class="hljs"><code><div>$ ng new 02-gifsApp
</div></code></pre>
<p>Vamos a trabajar con bootstrap, para ellos iremos al sitio oficial y copiaremos el CND link para el CSS únicamente</p>
<pre class="hljs"><code><div>&lt;!-- CSS only --&gt;
&lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; integrity=&quot;sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor&quot; crossorigin=&quot;anonymous&quot;&gt;
</div></code></pre>
<p>Pegamos este link en la sección <em>head</em> del archivo index.html</p>
<pre class="hljs"><code><div>./02-gifsApp/src/index.html
</div></code></pre>
<p>Luego borraremos toda la informacion en el archivo <em>code/udemy-angular/02-gifsApp/src/app/app.component.html</em> y crearemos nuestro diseño base HTML:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d-flex"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- Este es el sidebar --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bg-dark border-right p-2"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sidebar"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-light"</span>&gt;</span>Gifs-App<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-white"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group list-reset"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item list-group-item-action"</span>&gt;</span> DashBoard <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- Fin del sidebar --&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row p-3"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>Buscar:<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Buscar Gifs"</span> /&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>Estos es un texto temporal<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Agregamos el siguiente estilo al archivo principal <em>style.css</em></p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">html</span>,
<span class="hljs-selector-tag">body</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
}

<span class="hljs-selector-id">#sidebar</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">min-height</span>: <span class="hljs-number">100vh</span>;
  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">180px</span>;
}
</div></code></pre>
<p>Y listo, tenemos un diseño básico de lo que será nuestras APP. En contenedor (en el que aparece el texto temporal) mostrará el resultado de las búsqueda de GIF, y la barra lateral (sideBar) contrentrá la lista de las últimas 10 búsquedas.
<br/>
<img src="./imagenes/gifapp01.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" /></p>
<h1 id="crear-m%C3%B3dulo-y-componente-sidebar">Crear Módulo y Componente Sidebar</h1>
<p>Creamos el Modulo y el Componente:</p>
<pre class="hljs"><code><div>fcruz@dev05 02-gifsApp]$ ng g m shared
CREATE src/app/shared/shared.module.ts (192 bytes)

[fcruz@dev05 02-gifsApp]$ ng g c shared/sidebar
CREATE src/app/shared/sidebar/sidebar.component.css (0 bytes)
CREATE src/app/shared/sidebar/sidebar.component.html (22 bytes)
CREATE src/app/shared/sidebar/sidebar.component.spec.ts (633 bytes)
CREATE src/app/shared/sidebar/sidebar.component.ts (279 bytes)
UPDATE src/app/shared/shared.module.ts (280 bytes)
</div></code></pre>
<p>Movemos el HTML del main template hacia <em>/shared/sidebar/sidebar.component.html</em></p>
<p>Hacemos la exportación en el modulo shared del componente creado</p>
<p>Importamos el Módulo Share en el app.module.ts</p>
<p>Inluimos el <app-sidebar> en el template principal y listo.</p>
<h1 id="crar-nuevo-m%C3%B3dulo-gifs">Crar nuevo Módulo gifs</h1>
<p>Vamos a incluir todas las utilidades referente a los gifs en este módulo.</p>
<p>Generamos el módulo</p>
<pre class="hljs"><code><div>[fcruz@dev05 02-gifsApp]$ ng g m gifs
CREATE src/app/gifs/gifs.module.ts (190 bytes)
</div></code></pre>
<p>Y seguidamente lo importamos en el app.module.ts</p>
<h1 id="nuevo-complenmente-gifs-page">Nuevo Complenmente gifs-page</h1>
<p>Creamo el componente:</p>
<pre class="hljs"><code><div>[fcruz@dev05 02-gifsApp]$ ng g c gifs/gifsPage --skip-tests -is
CREATE src/app/gifs/gifs-page/gifs-page.component.html (24 bytes)
CREATE src/app/gifs/gifs-page/gifs-page.component.ts (259 bytes)
UPDATE src/app/gifs/gifs.module.ts (284 bytes)
</div></code></pre>
<p>NOTA: -is (internal style) omite la creación del archivo css:</p>
<p>Exportamos el componente en el gifs.module.ts</p>
<p>Importamos el modulo gifs en el app.module.ts</p>
<p>Creamos nuestra etiqueta app-gifs-page en nuestro main template</p>
<h1 id="crear-search-component">Crear search Component</h1>
<p>La barra de búsquedas será un componente aparte, dentro del módulo de gifs, procedemos:</p>
<pre class="hljs"><code><div>[fcruz@dev05 02-gifsApp]$ ng g c gifs/search --skip-tests -is
CREATE src/app/gifs/search/search.component.html (21 bytes)
CREATE src/app/gifs/search/search.component.ts (275 bytes)
UPDATE src/app/gifs/gifs.module.ts (406 bytes)
</div></code></pre>
<p>Este es un componente interno del módulo gifs por lo tanto no lo exportaremos, es de consumo interno.</p>
<h1 id="creamos-el-componente-results">Creamos el componente results</h1>
<p>Este contendrá los resultados de las búsquedas</p>
<p>Al final hemos separado el diseño original en componentes separados.</p>
<br/>
<img src="./imagenes/gifapp02.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<p>Hasta este punto los templates quedan de la siguiente forma:</p>
<p>El Main template debería de verse mas limpio de HTML:</p>
<p><strong>app.template.html:</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d-flex"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- Este es el sidebar --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">app-sidebar</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-sidebar</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- Fin del sidebar --&gt;</span>

  <span class="hljs-comment">&lt;!-- Este es el gifs-page component --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">app-gifs-page</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-gifs-page</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- Fin del gifs-page --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p><strong>sidebar.template.html:</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bg-dark border-right p-2"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sidebar"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-light"</span>&gt;</span>Gifs-App<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-white"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group list-reset"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item list-group-item-action"</span>&gt;</span> DashBoard <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p><strong>gifs-page.template.html</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row p-3"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">app-search</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-search</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">app-results</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-results</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p><strong>search.template.html</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>Buscar:<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Buscar Gifs"</span> /&gt;</span>
</div></code></pre>
<p><strong>results.template.html</strong></p>
<pre class="hljs"><code><div>Esto es un texto temporal
</div></code></pre>
<p>Por el momento solo nos hemos enfocado en trasbajar con el HTMl, el código a nivel de componentes.ts es el código por default del CLI.</p>
<h2 id="capturar-el-texto-de-b%C3%BAsqueda">Capturar el texto de búsqueda</h2>
<p>Para efectos prácticos y dado que solo tenemos un input, no consideramos necesario en este punto usar el FormModule para implementar el two-data-binding, vamos a usar otra técnica: el <strong>@ViewChild</strong></p>
<p>Tanto ViewChild como ViewChildren son dos decoradores que, utilizados sobre una propiedad de la clase que representa a un componente, permiten obtener las instancias de elementos nativos, directivas y componentes que estén en el template del mismo.</p>
<p>El primer cambio que haremmos es en el componente:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, ViewChild } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-search'</span>,
  templateUrl: <span class="hljs-string">'./search.component.html'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SearchComponent {
  <span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'txtBuscar'</span>) txtBuscar: <span class="hljs-built_in">any</span>;

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) {}

  buscar() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.txtBuscar);
  }
}
</div></code></pre>
<p>Como podemos observar, hemos usado el decorador <em>@ViewChild</em> para enlazar un elemento del DOM con una propiedad del Componente</p>
<pre class="hljs"><code><div>@ViewChild('txtBuscar') txtBuscar:any;
</div></code></pre>
<p>Con eso indicamos que en el template, vamos a tener un elemento que es identificado por medio de <em>txtBuscar</em> y que vamos a enlazar con una propiedad del componente llamada txtBuscar.</p>
<p>Ademas agregamos un método que imprime en consola un texto.</p>
<p>En la plantilla agregamos dos cosas:</p>
<p>1- Un identificador interno al control input: #txtBuscar</p>
<p>2- Un evento (keyup.enter) que llama al método buscar con el texto del elemento referenciado <em>txtBuscar.value</em></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span>
  <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
  <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>
  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Buscar Gifs..."</span>
  (<span class="hljs-attr">keyup.enter</span>)=<span class="hljs-string">"buscar(txtBuscar.value)"</span>
  #<span class="hljs-attr">txtBuscar</span>
/&gt;</span>
</div></code></pre>
<p>Pero que imprime ese console.log? Imprime un objeto de tipo <em>ElementRef</em> y no el valor en si, porque lo que estamos enlazando es el Elemento Completo. Entonces podemos cambiar el <em>any</em> por este tipo de datos:</p>
<pre class="hljs"><code><div>@ViewChild('txtBuscar') txtBuscar:ElementRef;
</div></code></pre>
<p>Pero ahora tenemos un error, Typescript nos exige que inicialicemos la propiedad, pero como en este caso sabemos que vamos a enlazar dicha propiedad a un elemento del DOM existente haremos uso del operador <em>!</em></p>
<pre class="hljs"><code><div>@ViewChild('txtBuscar') txtBuscar!:ElementRef;
</div></code></pre>
<p>Este operador se denomina **Operador de aserción no vacío ** Si el verificador de tipo no puede determinar si una variable es nula o no está definida durante el tiempo de ejecución, también arrojará un error. Podemos saber por nosotros mismos que no estará vacío, pero el verificador de tipos no. Por lo tanto, tenemos que decirle al verificador de tipos que no será nulo y utilizaremos el operador de aserción no nulo.</p>
<p>Listo, itentemos imprimir ahora el valor, si nos vamos al código y escribimos <code>console.log(this.txtBuscar.nativeElement.</code> vemos que luego de <em>nativeElement</em> no nos dá permite lsitar más propiedades, para resolver esto tenemos que agregar el tipo de elemento al <em>ElementRef</em> ya que es de tipo genèrico, en este caso como estamos trabajando con un elemento HTML, más especificamente el Input, entonces, finalmente la propiedad debe de quedar definida de la siguiente forma:</p>
<pre class="hljs"><code><div>@ViewChild('txtBuscar') txtBuscar!:ElementRef&lt;HTMLInputElement&gt;;
</div></code></pre>
<p>Ahora si podemos decifrar esta línea como: <strong>Estamos definiendo una propiedad denominada txtBuscar que es del tipo ElementRef<HTMLInputElement> y que estamos seguros que no es NULL (porque está definida en el DOM) y que el decorador @ViewChild creará un binding con un elemento en el DOM con un identificador intenot #txtBuscar</strong></p>
<p>Y ahora si podemos buscar la propiedad <em>value</em> de esta forma he imprimir su valor-</p>
<pre class="hljs"><code><div>    this.txtBuscar.nativeElement.value;
</div></code></pre>
<p>En este punto tenemos acceso al control Input, y podríamos manipular dicho control según lo necesitemos, por ejemplo si luego de usar el valor queremos limpiarlo, entonces hariamos esto:</p>
<pre class="hljs"><code><div>buscar() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.txtBuscar.nativeElement.value);
    <span class="hljs-keyword">this</span>.txtBuscar.nativeElement.value = <span class="hljs-string">''</span>;
  }
</div></code></pre>
<h2 id="cambios-en-la-app">Cambios en la APP.</h2>
<p>Haremos algunos cambios importantes en la configuraciones de los componentes y sus plantillas, se hará una reorganización mas limpia, al final el proyecto queda de esta forma:</p>
<p>Los directorios quedan de esta forma:</p>
<pre class="hljs"><code><div>── app.component.css
├── app.component.html
├── app.component.spec.ts
├── app.component.ts
├── app.module.ts
├── app-routing.module.ts
├── gifs
│   ├── components
│   │   ├── results
│   │   │   ├── results.component.html
│   │   │   └── results.component.ts
│   │   └── search-box
│   │       ├── search-box.component.html
│   │       └── search-box.component.ts
│   ├── gifs.module.ts
│   ├── helpers
│   ├── pages
│   │   └── home
│   │       ├── home-page.component.html
│   │       └── home-page.component.ts
│   └── services
└── shared
    ├── components
    │   └── sidebar
    │       ├── sidebar.component.html
    │       └── sidebar.component.ts
    ├── helpers
    ├── pages
    ├── services
    └── shared.module.ts
</div></code></pre>
<p>La aplicación se ha dividido en dos secciones</p>
<ul>
<li>gifs</li>
<li>shared</li>
</ul>
<p>Gifs contiene los elementos relacionados con renderizar las busqueda de gifs, componentes propiamente requeridos por la applicación para buscar y mostrar los gifs, en cambio shared, son elementos que puedne ser compartidos por otros elementos o secciones dentro de la app, por ejemplo una barra lateral de menú, está podría mostrarse no solo para una página que renderiza los gifs, pero también para cualquier otra página que renderice otro tipo de información dentro de la App. Por ejemplo, supongamos que agregaremos un panel para permitir configurar las busquedas de los gifs, podemos usar otro directorio gifSetUp y dentro de eso crear todos los elementos como componentes, helpers, servicios que muestren las herramientas para configuraciones. Entonces Shared contiene los elementos que se pueden compartir entre todos los componentes (vistas o secciones) de nuestra app</p>
<p>Dentro de cada sección crearemos una estructura de subdirectorios</p>
<p><em>components</em>  Aca se incluyen todos los componentes de la sección, para Gifs tendremos dos componentes, el SearchBox y el Result</p>
<p><em>helpers</em> Usaremos este directorio para colocar cualquier rutina, función o método que proporcione cierta funcionalidad de ayuda para los demas elementos de esta sección</p>
<p><em>pages</em> Las páginas son plantillas que agrupan a los componentes dentro de la sección</p>
<p><em>services</em> Servicios que otorgan utilidad a la sección</p>
<h2 id="componentes-principales">Componentes principales</h2>
<p>El template principal <em>app.component.html</em></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d-flex"</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- Este es el sidebar --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">shared-sidebar</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">shared-sidebar</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- Fin del sidebar --&gt;</span>

  <span class="hljs-comment">&lt;!-- Este es el gifs-page component --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">gifs-home-page</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">gifs-home-page</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- Fin del gifs-page --&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>El Componente, app.component.ts</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-root'</span>,
  templateUrl: <span class="hljs-string">'./app.component.html'</span>,
  styleUrls: [<span class="hljs-string">'./app.component.css'</span>]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppComponent {
  title = <span class="hljs-string">'02-gifsApp'</span>;
}
</div></code></pre>
<p>El enrrutador: app-routing.module.ts</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { RouterModule, Routes } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;

<span class="hljs-keyword">const</span> routes: Routes = [];

<span class="hljs-meta">@NgModule</span>({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppRoutingModule { }

</div></code></pre>
<p>y finalmente el módulo</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { BrowserModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser'</span>;

<span class="hljs-keyword">import</span> { AppRoutingModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app-routing.module'</span>;
<span class="hljs-keyword">import</span> { AppComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.component'</span>;
<span class="hljs-keyword">import</span> { SharedModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./shared/shared.module'</span>;
<span class="hljs-keyword">import</span> { GifsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'./gifs/gifs.module'</span>;

<span class="hljs-meta">@NgModule</span>({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    SharedModule,
    GifsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppModule { }
</div></code></pre>
<h2 id="componente-shared">Componente Shared</h2>
<p>El template</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"bg-dark border-right p-2"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sidebar"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-light"</span>&gt;</span>Gifs-App<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-white"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group list-reset"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item list-group-item-action"</span>&gt;</span>
      DashBoard
    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>El componente</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, OnInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'shared-sidebar'</span>,
  templateUrl: <span class="hljs-string">'./sidebar.component.html'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SahredSidebarComponent <span class="hljs-keyword">implements</span> OnInit {

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) { }

  ngOnInit(): <span class="hljs-built_in">void</span> {
  }

}
</div></code></pre>
<p>No tenemos por el momento helpers ni services ni páginas para esta sección, solamente el Modulo</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { CommonModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common'</span>;
<span class="hljs-keyword">import</span> { SahredSidebarComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/sidebar/sidebar.component'</span>;



<span class="hljs-meta">@NgModule</span>({
  declarations: [
    SahredSidebarComponent
  ],
  imports: [
    CommonModule
  ],
  exports: [
    SahredSidebarComponent
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SharedModule { }
</div></code></pre>
<h2 id="secci%C3%B3n-gifs">Sección Gifs</h2>
<p>Cuenta con dos componentes y una página que los agrupa,</p>
<h2 id="componente-search-box">Componente search-box</h2>
<p>el Template</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>Buscar:<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span>
  <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
  <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>
  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Buscar Gifs..."</span>
  (<span class="hljs-attr">keyup.enter</span>)=<span class="hljs-string">"buscar()"</span>
  #<span class="hljs-attr">txtBuscar</span>&gt;</span>
</div></code></pre>
<p>El componente</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, ElementRef, ViewChild } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'gifs-search-box'</span>,
  templateUrl: <span class="hljs-string">'./search-box.component.html'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SearchBoxComponent {

<span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'txtBuscar'</span>) txtBuscar!:ElementRef&lt;HTMLInputElement&gt;;

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) { }

  buscar() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.txtBuscar.nativeElement.value);
    <span class="hljs-keyword">this</span>.txtBuscar.nativeElement.value = <span class="hljs-string">''</span>;
  }

}

</div></code></pre>
<p>Ver más sobre el @ViewChild adelante en el documento.</p>
<h2 id="componente-result">Componente Result</h2>
<p>El template</p>
<p>Por el momento solo tenemos un texto</p>
<pre class="hljs"><code><div>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Cupiditate fugit molestias sapiente, laudantium quia officiis facere sed aut vero possimus, ullam ducimus praesentium minima nam qui debitis amet sequi laboriosam?
</div></code></pre>
<p>El componente</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, OnInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-results'</span>,
  templateUrl: <span class="hljs-string">'./results.component.html'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ResultsComponent <span class="hljs-keyword">implements</span> OnInit {

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) { }

  ngOnInit(): <span class="hljs-built_in">void</span> {
  }

}
</div></code></pre>
<h2 id="pages-componente-home-page">Pages: Componente home-page</h2>
<p>Este es un ejemplo de un componente que va en la carpeta <em>pages</em> es un componente que agrupa otros componentes y los presenta como una sola página.</p>
<p>el Template</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row p-3"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-12"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">gifs-search-box</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">gifs-search-box</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-12 pt-2"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">app-results</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-results</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Vemos como se muestran los dos componentes principales de la sección</p>
<p>El Componente</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, OnInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'gifs-home-page'</span>,
  templateUrl: <span class="hljs-string">'./home-page.component.html'</span>,
  styles: [
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomePageComponent <span class="hljs-keyword">implements</span> OnInit {

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) { }

  ngOnInit(): <span class="hljs-built_in">void</span> {
  }

}
</div></code></pre>
<h2 id="el-modulo-de-gifs">El Modulo de Gifs</h2>
<p>Este es el módulo de la sección Gifs</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { CommonModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common'</span>;
<span class="hljs-keyword">import</span> { HomePageComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./pages/home/home-page.component'</span>;
<span class="hljs-keyword">import</span> { SearchBoxComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/search-box/search-box.component'</span>;
<span class="hljs-keyword">import</span> { ResultsComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./components/results/results.component'</span>;



<span class="hljs-meta">@NgModule</span>({
  declarations: [
    HomePageComponent,
    SearchBoxComponent,
    ResultsComponent
  ],
  imports: [
    CommonModule
  ],
  exports: [
    HomePageComponent,
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> GifsModule { }
</div></code></pre>
<p>Y con eso se completa el rediseño de los componentes.</p>
<h2 id="viewchild">@ViewChild</h2>
<p>Documentación de internet:</p>
<p>En Angular, @ViewChild es un decorador que se utiliza para obtener una referencia a un elemento hijo dentro de un componente. Permite a un componente padre acceder a propiedades o métodos de un componente hijo directamente en el código TypeScript, en lugar de hacerlo a través del DOM.</p>
<p>La sintaxis básica de @ViewChild es la siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@ViewChild</span>(TipoDeElemento) nombreDeVariable: TipoDeElemento;
</div></code></pre>
<p>Donde:</p>
<pre><code>TipoDeElemento es el tipo de elemento que se está buscando. Puede ser un componente, una directiva, o un elemento nativo del DOM.
nombreDeVariable es el nombre de la variable que se utilizará para referenciar el elemento.
</code></pre>
<p>Aquí hay un ejemplo simple para ilustrar cómo se usa @ViewChild:</p>
<p>Supongamos que tienes un componente hijo llamado ChildComponent:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-child'</span>,
  template: <span class="hljs-string">'&lt;p&gt;Hola, soy un componente hijo.&lt;/p&gt;'</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ChildComponent {
  <span class="hljs-comment">// ... lógica del componente hijo, si es necesario</span>
}
</div></code></pre>
<p>Y ahora, en el componente padre, puedes usar @ViewChild para obtener una referencia a ese componente hijo:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, ViewChild, AfterViewInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { ChildComponent } <span class="hljs-keyword">from</span> <span class="hljs-string">'./child.component'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-parent'</span>,
  template: <span class="hljs-string">`
    &lt;p&gt;Componente Padre&lt;/p&gt;
    &lt;app-child&gt;&lt;/app-child&gt;
  `</span>,
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ParentComponent <span class="hljs-keyword">implements</span> AfterViewInit {
  <span class="hljs-meta">@ViewChild</span>(ChildComponent) childComponentRef!: ChildComponent;

  ngAfterViewInit() {
    <span class="hljs-comment">// Ahora puedes acceder a las propiedades y métodos del componente hijo</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.childComponentRef);
  }
}
</div></code></pre>
<p>En este ejemplo, @ViewChild se utiliza para obtener una referencia al componente hijo ChildComponent en el componente padre ParentComponent. Después del ciclo de vida ngAfterViewInit, la variable childComponentRef contendrá una referencia al componente hijo, y puedes interactuar con él directamente en el código del componente padre.</p>
<p>Fin de la documentación de internet.</p>
<p>Nuestro componente Search-Box usa este decorador, recordemos el template</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>Buscar:<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span>
  <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
  <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>
  <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Buscar Gifs..."</span>
  (<span class="hljs-attr">keyup.enter</span>)=<span class="hljs-string">"buscar()"</span>
  #<span class="hljs-attr">txtBuscar</span>&gt;</span>
</div></code></pre>
<p>El input tiene una referencia #txtBuscar la cual se usará como identificado único para enlazar el text con nuestro código en TypeScript.</p>
<p>En nuestro componente, definimos el enlace de esta forma</p>
<pre class="hljs"><code><div><span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'txtBuscar'</span>) txtBuscar!:ElementRef&lt;HTMLInputElement&gt;;
</div></code></pre>
<p>@ViewChild acepta como parámetro el identificador único del componente, a la vez necesita un nombre para la propiedad txtBuscar! (puede ser nullable) y se define el tipo del elemento, en este caso es un HTMLInputElement</p>
<p>Luego, podemos acceder a nuestro elemento de la siguiente forma:</p>
<pre class="hljs"><code><div>   <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.txtBuscar.nativeElement.value);
</div></code></pre>
<h2 id="servicio-gifs">Servicio Gifs</h2>
<p>Vamos a implementar un servicio, lo haremos desde la línea de comando</p>
<pre class="hljs"><code><div>ng g service gifs/services/gifs
</div></code></pre>
<p>Esto crea un par de archivo, el más importante <em>src/app/gifs/services/gifs.service.ts</em></p>
<p>Agregaremos una propiedad privada _<em>tagsHistory</em> para almacenar la lista de Tags con los que hemos realizado búsquedas.</p>
<pre class="hljs"><code><div>private _tagHistory: string[] = [];
</div></code></pre>
<p>A la vez, crearemos un metodo get para obtener la lista de tags (Arreglo)</p>
<pre class="hljs"><code><div>  get tagHistory(): string[] {
    return [...this._tagHistory];
  }
</div></code></pre>
<p>Dado que en Js los arreglos se pasan como referencia, y no queremos pasar esa referencia a cualquiera que lo solicite, usamos el operador sread <em>...</em> para pasar una copia del arreglo en lugar de la referencia.</p>
<p>Procedemos a crear un nuevo método <em>searchTag()</em> que recibe como parametro el tag de búsqueda y agregara el TAG a nuestro tags history, de paso mantendremos unicamente 10 elementos en nuestro arreglo.</p>
<p>El servicio por el momento es el siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Injectable</span>({
  providedIn: <span class="hljs-string">'root'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> GifsService {

  <span class="hljs-keyword">private</span> _tagHistory: <span class="hljs-built_in">string</span>[] = [];

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) { }

  <span class="hljs-keyword">get</span> tagHistory(): <span class="hljs-built_in">string</span>[] {
    <span class="hljs-keyword">return</span> [...this._tagHistory];
  }

  <span class="hljs-keyword">public</span> searchGifs(tag: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    tag = tag.trim().toLowerCase();
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._tagHistory.includes(tag)) {
      <span class="hljs-keyword">this</span>._tagHistory.unshift(tag);
      <span class="hljs-keyword">this</span>._tagHistory = <span class="hljs-keyword">this</span>._tagHistory.splice(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>);
    }
  }
}
</div></code></pre>
<p>Algunas cosas a notar:</p>
<p>Primero, el decorador <em>@Injectable</em> por medio del configurador <em>providedIn:  'root'</em> indicamos que cualquier módulo que importe este servicio, automáticamente tiene a su disposición usar dicho servicio.</p>
<p>De Internet:</p>
<p>Cuando se usa  <em>provideIn: 'root'</em> en tu servicio, le indicamos a Angular que proporcione el servicio en el inyector raíz. El inyector raíz es el inyector superior en su aplicación del cual heredan todos los demás inyectores. Esto significa que el servicio estará disponible en toda la aplicación. Es una forma de crear un servicio singleton, es decir, de garantizar que una clase de servicio tenga solo una instancia en toda la aplicación.</p>
<h2 id="inyectando-el-nuevo-servicio">Inyectando el nuevo servicio</h2>
<p>Regresemos a nuestro search-box Component, en el contructor debemos inyectar el nuevo servicio de la siguiente forma:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> gifsService: GifsService </span>) { }
</div></code></pre>
<p>Dado que el servicio fue agregado al Inyecto Raiz, no es necesario hacer Importaciones o exportaciones en los módulos, simplemente lo inyectamos.</p>
<p>Seguidamente podemos usar los métodos del servicio:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> newTag = <span class="hljs-keyword">this</span>.txtBuscar.nativeElement.value.trim().toLowerCase();
<span class="hljs-keyword">this</span>.gifsService.searchGifs(newTag); 
</div></code></pre>
<h2 id="consumiendo-el-servicios-desde-el-sidebar">Consumiendo el servicios desde el SideBar</h2>
<p>Vamos a imprimir la lista de elementos que tenemos en nuestro <em>_tagHistory</em> en el SideBar Component, para ello primero inyectamos el servicio en el componente y luego creamos un metodo publico GET para retornar la lista actual de elementos guardados.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SahredSidebarComponent {

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> gifsService: GifsService</span>) { }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> tags(): <span class="hljs-built_in">string</span>[] {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.gifsService.tagHistory;
  }
}
</div></code></pre>
<p>Seguidamente podemos usar el método Get en nuestro template, y con esto cada vez que agregamos un TAG se mostrará en la Barra lateral.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let tag of tags"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item list-group-item-action"</span>&gt;</span>
      {{ tag | titlecase}}
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>El resultado: Veremos como un botón los elementos guardados.</p>
<br/>
<img src="./imagenes/gitapp03.png" alt="Barra Lateral" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<p>NOTA: Angular está constantemente observando los cambios en los datos y actualizando la vista en consecuencia. Cuando el array _tagHistory en el servicio cambia (debido a la adición de un nuevo tag), Angular detecta este cambio.Angular actualiza automáticamente todas las referencias en las vistas que dependen de estos datos.</p>
<h2 id="giphy-api-key">Giphy API key</h2>
<p>Vamos a usar un API publico para reliazar busquedas de Gifs</p>
<p>Primero creamos una cuenta en <code>https://developers.giphy.com/</code> luego en el Dashboard (<code>https://developers.giphy.com/dashboard/</code>) creamos una nueva APP y seleccionamos el API. Esto genera un API key, el cual vamos a usar en nuestra app.</p>
<p>Por el momento usaremos una constante en el servicio para almacenar el API Key, mas adelante usaremos variables de Entorno.</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
 * The GIPHY API key.
 * <span class="hljs-doctag">TODO:</span> Move to environment variables.
 */</span>
<span class="hljs-keyword">const</span> GIPPHY_API_KEY = <span class="hljs-string">'******************************'</span>;

<span class="hljs-meta">@Injectable</span>({
  providedIn: <span class="hljs-string">'root'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> GifsService {}
</div></code></pre>
<p>Para probar el API podemos instalar la extensión Rest Client, creamos un archivo con extensión http en nuestra carpeta root del proyecto y agregamos request como este:</p>
<pre class="hljs"><code><div>GET https://api.giphy.com/v1/gifs/search?api_key=KTsjcCoEj7zWZC0vEgmQDtFd6Fegr8ta&amp;q=funny+cat
</div></code></pre>
<p>Luego Ctrl + Click en el URL.</p>
<h2 id="obtener-datos">Obtener Datos</h2>
<p>Podemos implementar un Fetch para realizar búsquedas usando el API,</p>
<pre class="hljs"><code><div>fetch(<span class="hljs-string">`<span class="hljs-subst">${GIPHY_API_URL}</span>/search?api_key=<span class="hljs-subst">${GIPPHY_API_KEY}</span>&amp;q=<span class="hljs-subst">${tag}</span>&amp;limit=10`</span>)
      .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())
      .then( <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(response.data);
      });
</div></code></pre>
<p>Pero existe otra forma en angular que permite implementar interceptors, y realizar otras operaciones con la llamada al API, usaremos HttpClientModule</p>
<h2 id="httpclientmodule">HttpClientModule</h2>
<p>HttpClientModule permite nativamente desde angular implementar, entre otras cosas, llamadas a API en las que podamos aplicar interceptor, programación reactiva, etc. Es un client muy poderoso y se recomienda usarlo en Angular.</p>
<p>Primero en el <code>app.module.ts</code> importamos el paquete:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { HttpClientModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>;

<span class="hljs-meta">@NgModule</span>({
  imports: [
    HttpClientModule
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppModule { }
</div></code></pre>
<p>Y luego en nuestro servicio lo inyectamos en el constructor:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> http: HttpClient</span>) { }
</div></code></pre>
<p>Y luego implementamos el GET de la siguiente forma:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">`<span class="hljs-subst">${GIPHY_API_URL}</span>/search?api_key=<span class="hljs-subst">${GIPPHY_API_KEY}</span>&amp;q=<span class="hljs-subst">${tag}</span>&amp;limit=10`</span>).subscribe( <span class="hljs-function">(<span class="hljs-params">response: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(response.data);
    });
</div></code></pre>
<p>El <code>this.http.get</code> regresa un <code>Observable</code> el cual es un objeto que a lo largo del tiempo puede estar emitiendo diferentes valores</p>
<p>Un objeto <code>Observable</code> permite subscribirse por medio del método <code>subscribe</code> eso significa que vamos a estar escuchando las emisiones de ese objeto. Cada vez que emita un valor, vamos a escucharlo y reaccionar a dicho evento. En nuestro caso, es un objeto que emite eventos una sola vez pero igual, debemos de suscribirnos. Esto quiere decir que hay otros Observables que emiten eventos constantemente en el tiempo.</p>
<h2 id="httpparams">HttpParams</h2>
<p>Continuamos optimizando nuestro código, esta vez lo haremos con los parámetros de la petición. Vamos a implementar un objeto HttpParams (propio de JS, no necesitamos importar nada) y agregaremos nuestros parámetros a dicho objeto, posteriormente lo agregaremos a la petición, el código queda de esta forma:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> params = <span class="hljs-keyword">new</span> HttpParams()
      .set(<span class="hljs-string">'api_key'</span>, GIPPHY_API_KEY)
      .set(<span class="hljs-string">'q'</span>, tag)
      .set(<span class="hljs-string">'limit'</span>, GIPHY_SEARCH_LIMIT.toString());

    <span class="hljs-keyword">this</span>.http.get(<span class="hljs-string">`<span class="hljs-subst">${GIPHY_API_URL}</span>/search`</span>, { params }).subscribe( <span class="hljs-function">(<span class="hljs-params">response: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-built_in">console</span>.log(response);
    });
</div></code></pre>
<p>NOTA: <code>GIPHY_SEARCH_LIMIT</code> es una constante agregada en el servicio.</p>
<h2 id="implementando-tipo-de-datos-para-el-api-response">Implementando Tipo de Datos para el API response</h2>
<p>El API retorna un objeto con muchos datos, mapear eso a las interfaces manualmente puede ser una tarea complicada, pero podemos usar herramientas que transforman un JSON en las interfaces necesarios, por ejemplo podemos usar <a href="https://app.quicktype.io/">https://app.quicktype.io/</a></p>
<p>Pegamos el JSON, seleccionamos el tipo de lenguaje (typescript) y marcamos Solo interfaces, cambiamos el nombre de la interfaz principal a <code>SearchResponse</code>, creamos un nuevo archivo: <code>src/app/gifs/interfaces/gifs.interface.ts</code> y agregamos todas las interfaces creadas por quicktype.</p>
<p>La interfaz principal <code>SearchResponse</code> cuenta con tres campos</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> SearchResponse {
    data:       Gifs[];
    pagination: Pagination;
    meta:       Meta;
}
</div></code></pre>
<p><em>Data</em> es un arreglo de gifs, y es el objeto que contiene los datos mas relevantes. Los almacenaremos en una variable pública <code>public gifsList: Gifs[] = [];</code></p>
<p>NOTA: en este caso usamos una propiedad pública y no una privada con su Get (usando desestructuración) porque esta lista es volátil, cada vez que hacemos una búsqueda, esta lista va a ser reemplazada. Por eso no tiene mucha importancia si un proceso externo al servicio la modifica. Aunque lo ideal es siempre usare el metodo GET con su propiedad privada tal como se hizo con el <code>private _tagHistory: string[] = [];</code></p>
<p>A continuación, vamos a tipar nuestro response, el código siguiente imprime únicamente el título de los gifs en la respuesta:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">this</span>.http.get&lt;SearchResponse&gt;(<span class="hljs-string">`<span class="hljs-subst">${GIPHY_API_URL}</span>/search`</span>, { params })
    .subscribe( <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
      <span class="hljs-keyword">this</span>.gifsList = response.data;
    });
</div></code></pre>
<h2 id="mostrar-gifs-en-pantalla">Mostrar Gifs en Pantalla</h2>
<p>Tenemos esta estructura de componentes:</p>
<pre class="hljs"><code><div>app_root
  |
  |-shared-sidebar
  |
  |-gifs-home-page
      |
      |-gifs-search-box
      |
      |-gifs-card-list
</div></code></pre>
<p>Tenemos dos opciones:</p>
<ol>
<li>Inyectar el servicio directamente en el <em>gifs-card-list</em></li>
<li>Inyectar el servicio en el <em>gifs-home-page</em> y que sea este el que pase los gifs al componente hijo <em>gifs-card-list</em></li>
</ol>
<p>Con la opción 1, inyectamos directamente el servicio al card list, de modo que únicamente este componente podrá usar la información de los gifs.</p>
<p>La ventaja del item 2 es que podemos posteriormente agregar otro componente al home page que use la información de los gifs, por ejemplo una sección de resumen.</p>
<p>Implementaremos la opción #2.</p>
<p>Inyectamos el servicio y creamos un método <em>get</em></p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HomePageComponent {

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> gifsService: GifsService</span>) { }

  <span class="hljs-keyword">get</span> gifs() : Gifs[] {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.gifsService.gifsList;
  } 

}
</div></code></pre>
<p>Ahora necesitamos pasar esa información al componente hijo <em>gifs-card-list</em> y lo haremos por medio de un <em>@Input</em>  En el componente Card list agregamos este input:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CardListComponent  {

  <span class="hljs-meta">@Input</span>() gifs: Gif[] = [];

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) { }

}
</div></code></pre>
<p>Nuestro componente hijo está listo para recibir la lista de Gifs desde el padre, para pasar esa información, modificaremos el template del componente <em>gifs-home-page</em> y al momento de definir el componente <em>gifs-card-list</em> pasamos el dato como un parámetro</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-12 pt-2"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">gifs-card-list</span> [<span class="hljs-attr">gifs</span>]=<span class="hljs-string">"gifs"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">gifs-card-list</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>En este momento el card list puede renderizar en su template la lista de gifs.</p>
<h2 id="actualizar-el-sidebar">Actualizar el SideBar</h2>
<p>En nuestro sideBar Component, ya tenemos el servicio inyectado en el constructor, lo usamos para crear la lista de tags (últimos 10 tags buscandos), vamos a agregar un método que llame nuevamente el servicio para buscar por un tag específico, en este caso, al hacer click en el botón</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SahredSidebarComponent {

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> gifsService: GifsService</span>) { }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> tags(): <span class="hljs-built_in">string</span>[] {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.gifsService.tagHistory;
  }

  <span class="hljs-keyword">public</span> searchTag(tag: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.gifsService.searchGifs(tag);
  }
}
</div></code></pre>
<p>Ahora, en nuestro template, usaremos el método <em>searchTag</em></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
    (<span class="hljs-attr">click</span>) = <span class="hljs-string">"searchTag(tag)"</span> 
    *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let tag of tags"</span>  
    <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item list-group-item-action"</span>&gt;</span>
      {{ tag | titlecase}}
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>Con este cambio, al hacer click en el botón, se dispara nuevamente una búsqueda con el Tag seleccionado.</p>
<p>Veremos como se actualizada el cardListComponent sin hacer mayor cambio, porque la llamada al método <em>this.gifsService.searchGifs(tag);</em> actualizará la pripiedad <em>this.gifsList = response.data;</em> esto hace que en cualquier sitio de nuestro código donde hemos usado esta propiedad, se refresquen los componentes asociados, por ejemplo, en el homePageComponente hicimos esto</p>
<pre class="hljs"><code><div><span class="hljs-keyword">get</span> gifs() : Gif[] {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.gifsService.gifsList;
  } 
</div></code></pre>
<p>El método gifs se usa en la renderización del cardList</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">gifs-card-list</span> [<span class="hljs-attr">gifs</span>]=<span class="hljs-string">"gifs"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">gifs-card-list</span>&gt;</span>
</div></code></pre>
<p>Y esto hace que el componente actualice su información en Pantalla.</p>
<h2 id="localstorage">LocalStorage</h2>
<p>La lisa de TAGS y sus resulados actualmente se pierde cuando recargamos el navegador, vamos a implementar un localstorage, para ello podemos guardar la información en el browser usando localstorage, sessionStorage o las Cookies.</p>
<p>El Localstorage permite un mayor cantidad de datos de almacenamiento y es persistente aunque apaguemos el computador.</p>
<p>El SessionStorage también permite guardar grandes cantdidades de datos pero se pierde cuando cerramos el navegador.</p>
<p>El cookies tambien persisten datos pero a diferencia de los métodos anteriores, el contenido es enviado al backend cuando interactuamos con el.</p>
<p>Implementemos un metodo sencillo en el GigsService</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
   * Save the tag history to the local storage.
   */</span>
  <span class="hljs-keyword">private</span> saveTagHistory(): <span class="hljs-built_in">void</span> {
    localStorage.setItem(<span class="hljs-string">'history'</span>, <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>._tagHistory));
  }
</div></code></pre>
<p>Este método debemos llamarlo tan pronto el servicio actualice la lista de Tags.</p>
<h2 id="cargar-datos-guardados">Cargar datos guardados</h2>
<p>Ahora es momento de cargar los datos guardados en el localstorage la carga nuestra App.</p>
<p>Creamos el método correspondiente para cargar el history desde el localStorage</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
   * Load the tag history from the local storage.
   */</span>
  <span class="hljs-keyword">private</span> loadTagHistory(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">const</span> history = localStorage.getItem(<span class="hljs-string">'history'</span>);
    <span class="hljs-keyword">if</span> (history) {
      <span class="hljs-keyword">this</span>._tagHistory = <span class="hljs-built_in">JSON</span>.parse(history);
      <span class="hljs-keyword">this</span>.searchGifs(<span class="hljs-keyword">this</span>._tagHistory[<span class="hljs-number">0</span>]);
    }
  }
</div></code></pre>
<p>Necesitamos llamar este método en algún lugar, y lo haremos cuando inyectemos el servicio por primera vez, es decir en el constructor del servicio.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> GifsService {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> http: HttpClient</span>) { 
    <span class="hljs-keyword">this</span>.loadTagHistory();
  }
}
</div></code></pre>
<p>NOTA: al recargar el browser, si tenemos tags almacenados, veremos que la app siempre carga los gifs del primer TAG, esto es posible porque hemos agregado la siguiente línea de código en nuestro loadTagHistory()</p>
<pre class="hljs"><code><div><span class="hljs-keyword">this</span>.searchGifs(<span class="hljs-keyword">this</span>._tagHistory[<span class="hljs-number">0</span>]);
</div></code></pre>
<p>Y con esto ya podemos persistir en el localStorage la lista de TAGS.</p>
<h2 id="tarea-adicional-1">Tarea Adicional 1</h2>
<p>Implementaremos una funcionalidad que elimine un Tag específico, para ellos agregaremos un icono de eliminar a la par del TAG en el sideBarComponent y al presionar, eliminaremos ese TAG de la lista.</p>
<h2 id="tarea-adicional-2">Tarea Adicional 2</h2>
<p>Permitir cargar GIFS desde el localStorage, cuando se cargue desde el localStorage, agregar un icono a la par del TAG que indique que ha sido cargado desde Memoria.</p>
<h1 id="soluci%C3%B3n-ambas-tareas">Solución ambas tareas</h1>
<p>Usando mi cuenta personal, se obtiene un kit the Fontawesome y se agrega en el index.html</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://kit.fontawesome.com/8de2637909.js"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<p>Se agrega el método eliminar TAG en el <em>GifsService</em>:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
   * Delete a tag from the tag history.
   * @param tag The tag.
   */</span>
  <span class="hljs-keyword">public</span> deleteTag(tag: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>._tagHistory = <span class="hljs-keyword">this</span>._tagHistory.filter( <span class="hljs-function"><span class="hljs-params">OldTag</span> =&gt;</span> OldTag !== tag);
    <span class="hljs-keyword">this</span>.saveTagHistory();
  }
</div></code></pre>
<p>Se agrega el método de eliminar en el  <em>sideBarComponent</em></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> deleteTag(tag: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.gifsService.deleteTag(tag);
  }
</div></code></pre>
<p>Se agregan los iconos al template del <em>sideBarComponent</em></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let tag of tags"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d-flex justify-content-between align-items-center"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>
          (<span class="hljs-attr">click</span>)=<span class="hljs-string">"searchTag(tag)"</span>   
          <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item list-group-item-action"</span>&gt;</span>
          {{ tag | titlecase }}
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"deleteTag(tag)"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sb-icon text-white"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa-solid fa-trash-can"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"searchTag(tag)"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sb-icon text-white"</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa-solid fa-rotate"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<div style="page-break-after: always;"></div>
## Nueva Seccion - Image Loader 
<p>¿Qué veremos en esta sección?</p>
<p>El objetivo principal de la sección es poder aprender a realizar un loading mientras la imagen se carga, pero indirectamente haremos:</p>
<pre><code>@Inputs

@Outputs

Custom Components

Validaciones

Importación de módulos personalizados
</code></pre>
<h2 id="crear-un-nuevo-componente">Crear un nuevo componente</h2>
<p>Antes de comenzar con esta sección, vamos a crear un componente para mostrar un Gif. Actualmente tenemos un <em>gif-card-list</em> y este, recorre la lista de gifs[] y renderiza los gifs en una especie de cartilla. Pues crearemos un componente que renderiza un gif especifico (recibirá como @Input el gif) y dicho componente los llamaremos en el <em>gif-card-list</em></p>
<p>Usando el ng Client:</p>
<pre class="hljs"><code><div>ng g c gif-card
</div></code></pre>
<p>En el template del nuevo componente moveremos el código html que teniamos en el ciclo del <em>gifCardListComponent</em></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card mb-2 text-center bg-dark"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-body text-white"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"gif.images.downsized_medium.url"</span> [<span class="hljs-attr">alt</span>]=<span class="hljs-string">"gif.title"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-img-top"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-text"</span>&gt;</span>
          {{ gif.title }}
      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>El código de typescript para este nuevo componente debera:
1- Aceptar un gif como parámetro de entrada
2- Validar que le gif ha sido proporcionado, osea, que no sea null.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'gifs-gif-card'</span>,
  templateUrl: <span class="hljs-string">'./gif-card.component.html'</span>,
  styleUrls: [<span class="hljs-string">'./gif-card.component.css'</span>]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> GifCardComponent <span class="hljs-keyword">implements</span> OnInit {

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) { }

  <span class="hljs-meta">@Input</span>() gif!: Gif;

  ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.gif) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'GifCardComponent: gif is required'</span>);
    }
  }
}
</div></code></pre>
<p>Ahora necesitamos cambiar el template del <em>gifCardListComponent</em> para llamar este componente y proprcionar el gif específico a renderizar</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">gifs-gif-card</span> 
        [<span class="hljs-attr">gif</span>]=<span class="hljs-string">"gif"</span>
        *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let gif of gifs "</span> 
        <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-2 col-sm-6"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">gifs-gif-card</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Y listo, tenemos nuevamente la aplicación funcionando como antes, solo que esta vez, tenemos un nuevo componente para renderizar un único gif. Esto nos ayudara a reutilizar este componente, supongamos que al hacer click abrimos una nueva sección, y parte de esa sección es mostrar el gif seleccionado en un card, con este componente podremos hacer eso facilmente.</p>
<h2 id="lazy-image">Lazy Image</h2>
<p>Implementaremos la carga perezosa de imagenes por medio de un componente, dado que podemos reutilizar esta funcionalidad con cualquier imagen, vamos a colocar el componente en nuestro Shared.</p>
<p>Shared puede ser luego copiado integramente a otros proyecto, de modo que todos estos componentes estarán disponibles para su uso inmediato en otra aplicación.</p>
<p>Primero agreamos el componente:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'shared-lazy-image'</span>,
  templateUrl: <span class="hljs-string">'./lazy-image.component.html'</span>,
  styleUrls: [<span class="hljs-string">'./lazy-image.component.css'</span>],
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> LazyImageComponent { 


}
</div></code></pre>
<p>Luego lo declaramos y exportamos en el <em>SharedModule</em></p>
<pre class="hljs"><code><div><span class="hljs-meta">@NgModule</span>({
  declarations: [
    SahredSidebarComponent,
    LazyImageComponent
  ],
  imports: [
    CommonModule
  ],
  exports: [
    SahredSidebarComponent,
    LazyImageComponent
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SharedModule { }
</div></code></pre>
<p>Hasta aca, el componente puede ser usado por todo aquel módulo que importe el <em>SharedModule</em></p>
<p>Ahora, importamos el módulo donde queremos usarlo, en el <em>GifsModule</em> Solamente lo incluimos en la sección <em>imports</em></p>
<pre class="hljs"><code><div><span class="hljs-meta">@NgModule</span>({
  imports: [
    SharedModule
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> GifsModule { }
</div></code></pre>
<p>Con este cambio ya podemos usar el <em>LazyImageComponent</em> dentro de nuestro <em>GifsModule</em></p>
<p>Ahora implementaremos la funcionalidad del <em>LazyImageComponent</em> agregaremos una propiedad  @Input <em>src</em> que será el URL del recurso a cargar (imagen o Gif), validaremos que el OnInit que el URL ha sido proporcionado. Y tambien una propiedad nullable para mostrar el ALT Text. Tambien implementaremos un flag, hasLoaded, para determinar cuando ha sido cargada la imagen. El objetivo es que mientras la imagen no ha sido cargada, mostremos el Spinner, una vez cargada ocultamos el spinner y se muestra la imagen.</p>
<p>El compomente será:</p>
<pre class="hljs"><code><div>  <span class="hljs-meta">@Component</span>({
    selector: <span class="hljs-string">'shared-lazy-image'</span>,
    templateUrl: <span class="hljs-string">'./lazy-image.component.html'</span>,
    styleUrls: [<span class="hljs-string">'./lazy-image.component.css'</span>],
  })
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> LazyImageComponent <span class="hljs-keyword">implements</span> OnInit {

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) { }

    <span class="hljs-meta">@Input</span>() src!: <span class="hljs-built_in">string</span>;
    <span class="hljs-meta">@Input</span>() alt: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">public</span> hasLoaded: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;

    ngOnInit(): <span class="hljs-built_in">void</span> {
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.src) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Attribute src is required'</span>);
      }
    } 

    onLoad() {
      <span class="hljs-keyword">this</span>.hasLoaded = <span class="hljs-literal">true</span>;
    }
  }
</div></code></pre>
<p>El template de nuestro LazyLoader será</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"d-flex justify-content-center"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> 
        [<span class="hljs-attr">src</span>]=<span class="hljs-string">"src"</span>  
        [<span class="hljs-attr">alt</span>]=<span class="hljs-string">"alt"</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"card-img-top"</span>
        (<span class="hljs-attr">load</span>)=<span class="hljs-string">"onLoad()"</span>
        [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">"{ display: hasLoaded ? '' : 'none'}"</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"!hasLoaded"</span> 
        <span class="hljs-attr">src</span>=<span class="hljs-string">"assets/rings.svg"</span> 
        <span class="hljs-attr">height</span>=<span class="hljs-string">"45"</span> 
        <span class="hljs-attr">width</span>=<span class="hljs-string">"45"</span> 
        <span class="hljs-attr">class</span>=<span class="hljs-string">"mt-3"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Inicialmente el componete tiene el flag <em>hasLoaded</em>  en <em>false</em> este es el estado inicial y mostrará el spinner.</p>
<p>En la primer imagen, tenemos un <em>(load)=&quot;onLoad()</em> esto significa que una vez cargada la imagen, se llama el método <em>onLoad()</em></p>
<p>El método <em>onLoad()</em> cambia el flag <em>hasLoaded</em> a <em>true</em></p>
<p>A continuación esto oculta el spinner <em>*ngIf=&quot;!hasLoaded&quot;</em> y muestra la imagen <em>[ngStyle]=&quot;{ display: hasLoaded ? '' : 'none'}&quot;&gt;</em></p>
<p>Ahora implementemos el <em>LazyImageComponent</em> en nuestro template del <em>gif-card-component</em>, el cual luce de esta forma antes de este cambio:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card mb-2 text-center bg-dark"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-body text-white"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"gif.images.downsized_medium.url"</span> [<span class="hljs-attr">alt</span>]=<span class="hljs-string">"gif.title"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-img-top"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-text"</span>&gt;</span>
            {{ gif.title  || 'No title'}}
        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>En ese template, vamos a implementar nuestro <em>shared-lazy-image</em> es decir reemplazamos el <em><img></em> por esta línea:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">shared-lazy-image</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"gif.images.downsized_medium.url"</span> [<span class="hljs-attr">alt</span>]=<span class="hljs-string">"gif.title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">shared-lazy-image</span>&gt;</span>
</div></code></pre>
<p>Y listo, al cargar la página vemos un spinner y cuando la imagen ha sido cargada es mostrada.</p>
<br/>
<img src="./imagenes/gitapp04.png" alt="Barra Lateral" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<h2 id="animaciones-con-css">Animaciones con CSS</h2>
<p>Sitio: <a href="https://animate.style/">https://animate.style/</a></p>
<p>Colocamos en nuestro index.html</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">link</span>
    <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>
    <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"</span>
  /&gt;</span>
</div></code></pre>
<p>Y luego podemos usar las classes para agregar efectos, por ejemplo, agregar un FadeIn de 400ms cuando se carga la imagen:</p>
<p><em>animate__animated animate__fadeIn animate__delay-400ms</em></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">img</span> 
        [<span class="hljs-attr">src</span>]=<span class="hljs-string">"src"</span>  
        [<span class="hljs-attr">alt</span>]=<span class="hljs-string">"alt"</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"card-img-top animate__animated animate__fadeIn animate__delay-400ms"</span>
        (<span class="hljs-attr">load</span>)=<span class="hljs-string">"onLoad()"</span>
        [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">"{ display: hasLoaded ? '' : 'none'}"</span>&gt;</span>
</div></code></pre>
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-spa">Nueva Sección: SPA</h1>
<p><em>Single Page Application</em></p>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>Este es un breve listado de los temas fundamentales:</p>
<p>Rutas</p>
<p>RouterLink y RouterLinkActive</p>
<p>Componentes especializados</p>
<p>DebounceTime</p>
<p>Inputs</p>
<p>SwitchMaps</p>
<p>Consumo de APIs</p>
<p>Tipado de datos</p>
<p>Menú de aplicación</p>
<p>Y más</p>
<p>En esta sección daremos los fundamentos de una aplicación SPA (Single Page Application), y luego, las seguiremos haciendo pero mediante carga perezosa (lazyload), esta es otra aplicación real que nos enseñara mucho de cómo funciona Angular y como la información fluye en ella.</p>
<div style="page-break-after: always;"></div>
<p>Muestra de la APP:</p>
<br/>
<img src="./imagenes/countryapp01.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<p>Mostrando información de un País en específico:</p>
<br/>
<img src="./imagenes/countryapp02.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<div style="page-break-after: always;"></div>
## Crear nuevo proyecto:
<p>Configuraciones iniciales:</p>
<pre class="hljs"><code><div>[fcruz@fedora udemy-angular]$ ng new 03-countryApp --standalone=false
? Which stylesheet format would you like to use? CSS
? Do you want to enable Server-Side Rendering (SSR) and Static Site Generation (SSG/Prerendering)? No
</div></code></pre>
<p>Agregar Bootstrap, Animate y fontawesome</p>
<pre class="hljs"><code><div><span class="hljs-comment">&lt;!-- CSS only --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">integrity</span>=<span class="hljs-string">"sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">link</span>
    <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>
    <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"</span>
  /&gt;</span>
  
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://kit.fontawesome.com/8de2637909.js"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<p>Agregar la Clase Container al body</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
</div></code></pre>
<p>Borramos el Template del APP y listo, podemos iniciar.</p>
<h2 id="modulos">Modulos</h2>
<p>Vamos a crear un SPA (Single Page Application) y nos vamos a basar en dos módulos con varias páginas cada uno. Por el momento creamos ambos módulos:</p>
<pre class="hljs"><code><div>[fcruz@fedora 03-countryApp]$ ng g m countries
CREATE src/app/countries/countries.module.ts (195 bytes)
[fcruz@fedora 03-countryApp]$ ng g m shared
CREATE src/app/shared/shared.module.ts (192 bytes)
[fcruz@fedora 03-countryApp]$ 
</div></code></pre>
<p>La carga del <em>countries.module</em> se hará de modo LazyLoading, es decir, no se va a cargar inicialmente, en cambio el módulo <em>shared.module</em> se será cargado desde un inicio, por lo tanto, agregaremos el <em>shared.module</em> en la sección de <em>imports</em> de nuestro <em>app.module</em></p>
<h2 id="router-module-y-p%C3%A1ginas-spa">Router Module y Páginas SPA</h2>
<p>En la carpeta <em>app/shared</em> crearemos dos directorios: <em>components</em> y <em>pages</em> y dentro de pages vamos a crear dos componentes: <em>shared-home-page</em> y <em>shared-about-page</em></p>
<pre class="hljs"><code><div>[fcruz@fedora app]$ tree
.
└── app
   ├── countries
   │   └── countries.module.ts
   └── shared
       ├── components
       ├── pages
       │   ├── aboutPage
       │   │   ├── aboutPage.component.css
       │   │   ├── aboutPage.component.html
       │   │   └── aboutPage.component.ts
       │   └── homePage
       │       ├── homePage.component.css
       │       ├── homePage.component.html
       │       └── homePage.component.ts
       └── shared.module.ts

</div></code></pre>
<p>LA idea es implementar un Router que permita carga uno de los dos componentes dependiendo del URL</p>
<p><em>/home</em> cargará el <em>homePageComponent</em> y <em>/about</em> el <em>aboutPageComponent</em></p>
<p>Archivo: <em>src/app/app-routing.module.ts</em></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">'home'</span>,
    component: HomePageComponent
  },
  {
    path: <span class="hljs-string">'about'</span>,
    component: AboutPageComponent
  },
  {
    path: <span class="hljs-string">'**'</span>,
    redirectTo: <span class="hljs-string">'home'</span>
  }
];

<span class="hljs-meta">@NgModule</span>({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppRoutingModule { }
</div></code></pre>
<p>Analicemos el Router, se crea un arreglo de tipo <em>Routes</em>, este objetos <em>{}</em> el cual, por el momento contiene un <em>path</em> el URL section, y un <em>component</em>, el que se debe cargar si el URL hace match.</p>
<p>Luego, como este es el Routing principal usaremos <em>forRoot</em>, en el import: <em>RouterModule.forRoot(routes)</em></p>
<p>Finalmente exportamos el módulo ya que luego debemos importarlo en el App.module.</p>
<p>Y luego, en el template principal <em>src/app/app.component.html</em> agregamos un <em>router-outlet</em> el cual actúa como un marcador de posición que Angular llena dinámicamente según el estado actual del enrutador.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Listo, si cargamos el URL <em>http://localhost:4200/home</em> mostrará el <em>homeComponent</em> y si por el contrario cargamos el URL <em>http://localhost:4200/about</em> entonces mostrará el <em>aboutComponent</em></p>
<h2 id="router-link">Router Link</h2>
<p>Construiremos una barra de navegación para que al hacer click podamos cambiar entre componentes (home o about) sin necesidad de recargar el URL.</p>
<p>Crearemos un <em>SidebarComponent</em> en la carpeta <em>Shared</em> que servirá de barra de navegación, el template es el siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Países<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>
    <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"home"</span>
    <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active"</span>
    <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>&gt;</span>
        Home
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> 
    <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"about"</span>
    <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active"</span>
    <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>&gt;</span>
        About
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<p>Notar que cada elemento del menú <em>li</em> tiene una propiedad [routerLink] con un valor del <em>path</em> que agregamos anteriormente a nuestro Router. Pero para que  Angular reconozca el [routerLink] como una propiedad de elemento <em>li</em> debemos importar el <em>AppRoutingModule</em> en nuestro <em>SharedModule</em> Si no importamos el Routing Module, nos dará un error.</p>
<p>Con respecto a <em>routerLinkActive</em> lo que perite es agregar la clase <em>acive</em> al elemento seleccionado, se mostrará en azul.</p>
<p>Con estos cambios, al hacer click en cada elementos, veremos como se carga el componente indicado.</p>
<p>NOTA: También podemos usar el RouterLink de la siguiente forma</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">li</span>
    <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"home"</span>
    <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>&gt;</span>
        Home
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
</div></code></pre>
<p>La versión con los <em>[]</em> permite asignar dinámicamente los path a cada elemento, la segunda forma es mas estática.</p>
<p>Aplicamos los mismos pasos para agregar un ContactPageComponent y la aplicación por el momento debe de verse asi</p>
<br/>
<img src="./imagenes/countryapp03.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<h2 id="crear-estrutura-de-counties">Crear estrutura de Counties</h2>
<p>Vamos a crear la estructura de directorios y a la vez agregaremos componentes y muy importante, Crearemos un CoutriesRoutingModule, es decir un sistema de rutas específico para nuestra seccion de Countries. Este será agregado como un ChildRoutingModule, porque la APP solo permite teneru un RootRouting que ya lo hemos creado.</p>
<p>Comenzamos creando algunas carpetas <em>components</em>, <em>services</em>, <em>pages</em>, <em>interfaces</em> y agregamos componentes:</p>
<pre class="hljs"><code><div>[fcruz@fedora 03-countryApp]$ ng g c countries/pages/byCapitalPage --inline-style   --skip-tests 
CREATE src/app/countries/pages/by-capital-page/by-capital-page.component.html (30 bytes)
CREATE src/app/countries/pages/by-capital-page/by-capital-page.component.ts (200 bytes)
UPDATE src/app/countries/countries.module.ts (317 bytes)
</div></code></pre>
<p>De la misma forma crearemos los siguientes componentes:</p>
<pre class="hljs"><code><div>$ ng g c countries/pages/byCountryPage --inline-style   --skip-tests 
$ ng g c countries/pages/byRegionPage --inline-style   --skip-tests 
$ ng g c countries/pages/countryPage --inline-style   --skip-tests 
</div></code></pre>
<p>NOTA: Todos los componentes se crean con el prefijo <em>app</em> en el Selector, cambiemos ese prefijo, en este caso por <em>countries</em></p>
<pre class="hljs"><code><div>selector: <span class="hljs-string">'app-country-page'</span>,
</div></code></pre>
<p>Cambiar por</p>
<pre class="hljs"><code><div>selector: <span class="hljs-string">'countries-country-page'</span>,
</div></code></pre>
<p>Repetimos el cambio para los componentes que acabamos de crear.</p>
<h2 id="crear-sistema-de-rutas-para-countries">Crear sistema de rutas para Countries</h2>
<p>Como se ha mencionado, vamos a crear un módulo de rutas específico para la sección <em>Countries</em> este contendrá las rutas apuntando a las páginas que acabamos de crear.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
    {
        path: <span class="hljs-string">'by-capital'</span>,
        component: ByCapitalPageComponent
    },
    {
        path: <span class="hljs-string">'by-country'</span>,
        component: ByCountryPageComponent
    },
    {
        path: <span class="hljs-string">'by-region'</span>,
        component: ByRegionPageComponent
    },
    {
        path: <span class="hljs-string">'by/:id'</span>,
        component: CountryPageComponent 
    },
];

<span class="hljs-meta">@NgModule</span>({
    imports: [
        RouterModule.forChild(routes)
    ],
    exports: []
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CountriesRoutingModule { }
</div></code></pre>
<p>Luego tenemos que agregar en la lista de <em>imports</em> del <em>CountriesModule</em></p>
<pre class="hljs"><code><div><span class="hljs-meta">@NgModule</span>({
  declarations: [
    ByCapitalPageComponent,
    ByCountryPageComponent,
    ByRegionPageComponent,
    CountryPageComponent
  ],
  imports: [
    CommonModule,
    CountriesRoutingModule,
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CountriesModule { }
</div></code></pre>
<p>La estructura final de Countries luce de esta forma:</p>
<pre class="hljs"><code><div>.
├── components
├── countires-routing.module.ts
├── countries.module.ts
├── interfaces
├── pages
│   ├── by-capital-page
│   │   ├── by-capital-page.component.html
│   │   └── by-capital-page.component.ts
│   ├── by-country-page
│   │   ├── by-country-page.component.html
│   │   └── by-country-page.component.ts
│   ├── by-region-page
│   │   ├── by-region-page.component.html
│   │   └── by-region-page.component.ts
│   └── country-page
│       ├── country-page.component.html
│       └── country-page.component.ts
└── services

</div></code></pre>
<p>Hasta el momento, las rutas no están siendo &quot;comprendidas&quot; por la APP porque no hemos usado el <em>countries.module.ts</em> quien tiene todas las declaraciones, imports y exports. Lo veremos en la próxima sección, ya que vamos a implementar una carga Lazy. Es decir, únicamente cuando el usuario lo demande.</p>
<h2 id="lazyload">LazyLoad</h2>
<p>No vamos a agregar el <em>CountriesRoutingModule</em> en el <em>AppModule</em> porque eso significa carga el módulo completo desde que iniciamos la APP, lo que buscamos es cargar por demanda el Módulo. Para ello primero necesitamos un punto de entrada, es decir una ruta que nos permita cargar el Counties. Agregamos una nueva ruta en nuestro Root.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">'home'</span>,
    component: HomePageComponent
  },
  {
    path: <span class="hljs-string">'about'</span>,
    component: AboutPageComponent
  },
  {
    path: <span class="hljs-string">'contact'</span>,
    component: ContactPageComponent
  },
  {
    path: <span class="hljs-string">'countries'</span>,
    loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./countries/countries.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.CountriesModule)
  },
  {
    path: <span class="hljs-string">'**'</span>,
    redirectTo: <span class="hljs-string">'home'</span>
  }
];
</div></code></pre>
<p>Notar como el path de <em>counties</em> no carga un componente directamente, carga un módulo usando <em>loadChildren</em> el cual es un  objeto que especifica rutas secundarias con carga diferida.</p>
<p>Por el momento, si cargamos el url <em>http://localhost:4200/countries</em> notaremos que no se carga ningun componente, unicamente el sideBar</p>
<br/>
<img src="./imagenes/countryapp04.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<p>Si cargamos los URL hijos:</p>
<p><em>http://localhost:4200/countries/by-country</em></p>
<br/>
<img src="./imagenes/countryapp05.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<p>Ahora, podemos usar esta configuración para agregar más opciones al menú, por ejemplo, en nuestro sideBar podemos agregar las búsquedas por capital, region, país</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">li</span> 
    <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"countries/by-capital"</span>
    <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active"</span>
    <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>&gt;</span>
        By Capital
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> 
    <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"countries/by-region"</span>
    <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active"</span>
    <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>&gt;</span>
        By Region
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> 
    <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"countries/by-country"</span>
    <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active"</span>
    <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>&gt;</span>
        By Country  
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
</div></code></pre>
<p>Ahora podemos ver las opciones en el SideBar.</p>
<p>NOTA: Las opciones del HOME | CONTACT | ABOUT pueden ser eliminadas, solamente fueron usadas para propósito de explicar el Routing. La Aplicación únicamente mostrará las opciones para filtar por CAPITAL | REGION | PAIS</p>
<br/>
<img src="./imagenes/countryapp06.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<h2 id="build-y-lazy-files">Build y Lazy Files</h2>
<p>Los cambios realizados permiten cargar de manera perezosa el módulo <em>CountriesModule</em> de modo que hasta  que hacemos click en uno de los links nuevos, el browser solicitará un archivo adicional (chunk) el cual contiene el código JS del módulo <em>CountriesModule</em></p>
<p>Esto lo podemos ver también en el <em>build</em>, podemos notar que existe una sección <em>Lazy Chunk Files</em>, este se carga tan pronto hacemos click por primera vez en uno de los links nuevo.</p>
<pre class="hljs"><code><div>fcruz@fedora 03-countryApp]$ ng build

Initial Chunk Files   | Names            |  Raw Size | Estimated Transfer Size
chunk-RZ5F67RC.js     | -                | 200.00 kB |                53.86 kB
polyfills-LZBJRJJE.js | polyfills        |  32.69 kB |                10.59 kB
main-AE5FO73B.js      | main             |   2.90 kB |               820 bytes
styles-5INURTSO.css   | styles           |   0 bytes |                 0 bytes

                      | Initial Total    | 235.59 kB |                65.25 kB

Lazy Chunk Files      | Names            |  Raw Size | Estimated Transfer Size
chunk-6OYRYQCF.js     | countries-module |   1.49 kB |               363 bytes

Application bundle generation complete. [3.172 seconds]
</div></code></pre>
<h2 id="cambios-en-redirectto">Cambios en RedirectTo</h2>
<p>Haremos un cambio adicional con las rutas, actualmente al carga la applicación desplieuga el URL <em>http://localhost:4200/home</em> y muestra el HomePageComponent. Queremos que por defecto cargue el <em>by Capital</em></p>
<p>Lo único que necesitamos cambiar es el redirectTo del comodin <em>**</em> en nuestro Root Router, en lugar de 'home' usar el 'countries/by-capital'</p>
<pre class="hljs"><code><div>{
    path: <span class="hljs-string">'**'</span>,
    redirectTo: <span class="hljs-string">'countries/by-capital'</span>
  }
</div></code></pre>
<p>Otra forma de hacerlo y quizás mejor es definir rutas por default en cada router, en este caso en el router ROOT podemos definir únicamente el redoretTo a 'countries'</p>
<pre class="hljs"><code><div>{
    path: <span class="hljs-string">'**'</span>,
    redirectTo: <span class="hljs-string">'countries'</span>
  }
</div></code></pre>
<p>Y, en el <em>CountriesRoutingModule</em> definimos también un default path</p>
<pre class="hljs"><code><div>{
        path: <span class="hljs-string">'**'</span>,
        redirectTo: <span class="hljs-string">'by-capital'</span>
    }
</div></code></pre>
<p>Y recordemos que el URL <em>by-caputal</em> navega al componente <em>ByCapitalPageComponent</em>, regla que ha sido definida en el mismo <em>CountriesRoutingModule</em></p>
<pre class="hljs"><code><div> {
        path: <span class="hljs-string">'by-capital'</span>,
        component: ByCapitalPageComponent
    }
</div></code></pre>
<h2 id="nuevo-componente-searchbox">Nuevo Componente SearchBox</h2>
<p>Para realizar las búsquedas vamos a crear un nuevo componente, la idea es crear un componente que pueda ser reutilizado por cualquier tipo de búsqueda, de modo que vamos a tener que enviar algunos parametros, y el componente tendrá que emitir el valor a buscar, para que sea el componente padre, el que llame el servicio correspondiente. El componente estará ubicado en el directorio <em>Shared</em></p>
<p>Agregamos el <em>ShareSearchBoxComponent</em></p>
<p>Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
<span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
[<span class="hljs-attr">placeholder</span>]=<span class="hljs-string">"placeholder"</span>
<span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>
(<span class="hljs-attr">keyup.enter</span>)=<span class="hljs-string">"searchBy()"</span>
#<span class="hljs-attr">txtSearchInput</span>&gt;</span>
</div></code></pre>
<p>Typescript:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SearchBoxComponent {

  <span class="hljs-meta">@Input</span>() <span class="hljs-keyword">public</span> placeholder: <span class="hljs-built_in">string</span> = <span class="hljs-string">'Search...'</span>;

  <span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'txtSearchInput'</span>) txtSearchInput!: ElementRef&lt;HTMLInputElement&gt;;

  <span class="hljs-meta">@Output</span>() onNewSearch: EventEmitter&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> EventEmitter();

  <span class="hljs-keyword">public</span> searchBy() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.txtSearchInput.nativeElement.value.length == <span class="hljs-number">0</span>) 
      <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">this</span>.onNewSearch.emit(<span class="hljs-keyword">this</span>.txtSearchInput.nativeElement.value);
  }
}
</div></code></pre>
<p>Aca podemos observar:</p>
<p><em>Input placeholder</em> Este control necesita que quien lo implemente le envíe el texto a mostrar en el placeholder.</p>
<p><em>@ViewChild('txtSearchInput')</em> El template tiene un elemento <em>#txtSearchInput</em> el cual lo hacemos visible en el typescript para poder acceder directamente a su valor.</p>
<p><em>@Output() onNewSearch: EventEmitter<string></em> Esto indica que el component EMITE un valor string, el valor ingresado por el usuario, y el componente padre debe capturarlo para realizar la búsqueda correspondiente.</p>
<h2 id="implementando-el-searchboxcomponent">Implementando el SearchBoxComponent</h2>
<p>Vamos a implementarlo en el <em>ByCapitalPageComponent</em></p>
<p>Primero debemos agregarlo en el template la referencia al control</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">shared-search-box</span>
        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Search by Capital"</span>
        (<span class="hljs-attr">onNewSearch</span>)=<span class="hljs-string">"searchByCapital($event)"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">shared-search-box</span>&gt;</span>
</div></code></pre>
<p>Tal como lo mencionamos, el que implemente este control debe de enviar un valor para el <em>PlaceHolder</em> y debe esperar un evento <em>(onNewSearch)</em></p>
<p>El evento <em>onNewSearch</em> es capturado y a la vez llama el método <em>searchByCapital</em></p>
<p>Finalmente el código del control, tiene el método para iniciar la búsqueda.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ByCapitalPageComponent {

  <span class="hljs-keyword">public</span> searchByCapital(term: <span class="hljs-built_in">string</span>) {
    <span class="hljs-comment">//TODO call the service</span>
  }
}
</div></code></pre>
<p>De la misma forma podemos implementar el mismo control <em>SearchBoxComponent</em> en los otros componente:</p>
<ul>
<li>ByCountryPageComponent</li>
<li>ByRegionPageComponent</li>
</ul>
<h2 id="countries-api">Countries API</h2>
<p>Usaremos el API de <a href="https://restcountries.com/">https://restcountries.com/</a></p>
<p>Usaremos este ENDPOINT y le enviaremos una capital para obtener una muestra de los datos.</p>
<p>https://restcountries.com/v3.1/capital/{capital}</p>
<p>Copiaremos el JSON de respuesta y lo vamos a transformar en una serie de interfaces que las guardaremos en el archivo <em>country.interface.ts</em></p>
<p>Podemos usar la extensión: <em>Paste JSON as Code</em>, abrimos el archivo <em>country.interface.ts</em>, luego en la linea de comandos de Code (ctrl + p) escribimos <em>Paste json as code</em> y le damos el nombre de la interfaz raiz <em>countries</em> y listo, solo necesitamos tener en el clipboard el JSON respuesta.</p>
<p>Tambien podemos usar el sitio web <a href="https://app.quicktype.io/">https://app.quicktype.io/</a> que es del mismo proveedor de la extensión.</p>
<p>Verificamos las interfaces creadas.</p>
<h2 id="nuevo-servicio">Nuevo Servicio</h2>
<p>Con el Angular CLI Creamos un nuevo servicio</p>
<pre class="hljs"><code><div>[fcruz@fedora app]$ ng g s countries/services/countries.service.ts
CREATE src/app/countries/services/countries.service.ts.service.spec.ts (419 bytes)
CREATE src/app/countries/services/countries.service.ts.service.ts (147 bytes)
</div></code></pre>
<p>Y agregamos el siguiente código</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Injectable</span>({
  providedIn: <span class="hljs-string">'root'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CountriesServiceTsService {

  <span class="hljs-keyword">private</span> apiUrl: <span class="hljs-built_in">string</span> = <span class="hljs-string">'https://restcountries.com/v3.1'</span>;

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> httpClient: HttpClient</span>) { }

  <span class="hljs-comment">/**
   * Search countries by Capital
   * @param term string
   * @returns Observable&lt;Country&gt;
   */</span>
  searchByCapital(term: <span class="hljs-built_in">string</span>): Observable&lt;Country[]&gt; {
    <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.apiUrl}</span>/capital/<span class="hljs-subst">${term}</span>`</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.get&lt;Country[]&gt;(url);
  } 
}
</div></code></pre>
<p>NOTA Importante: Aca estamos usando el <em>HttpClient</em></p>
<pre class="hljs"><code><div>import { HttpClient } from '@angular/common/http';
</div></code></pre>
<p>No solo basta con el <em>import</em> en este caso tenemos que Importar el <em>HttpClientModule</em>. Dónde lo haremos? tiene que ser en un Módulo de la APP, si las peticiones REST las haremos en todos los componentes, lo ideal es agregarlo al archivo <em>app.module.ts</em></p>
<pre class="hljs"><code><div><span class="hljs-meta">@NgModule</span>({
  declarations: [
    AppComponent
  ],
  imports: [
    HttpClientModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppModule { }
</div></code></pre>
<p>Si omitimos este paso, vamos a tener un error:</p>
<pre class="hljs"><code><div>ERROR NullInjectorError: R3InjectorError(_CountriesModule)[_CountriesService -&gt; _CountriesService -&gt; _HttpClient -&gt; _HttpClient]: 
  NullInjectorError: No provider for _HttpClient!
</div></code></pre>
<p><em>La razón por la cual necesitas importar HttpClientModule es porque HttpClient es un servicio proporcionado por Angular, y estos servicios deben ser registrados en un módulo para que Angular pueda inyectarlos correctamente en los componentes y servicios que los utilizan.</em></p>
<p>Regresando al Servicio, el código es bastante simple, el método principal recibe un término de búsqueda, puede ser una capital o simplemente cualquier palabra, el API puede retornar un arreglo de objetos o países, por ejemplo si envíamos el término <em>San</em>, podría retornar</p>
<ul>
<li>San Marino</li>
<li>Yemen</li>
<li>Chile</li>
<li>El Salvador</li>
<li>Puerto Rico</li>
<li>Dominican Republic</li>
<li>Costa Rica</li>
</ul>
<p>Por lo tanto debemos esperar un arreglo de paises <em>Country[]</em></p>
<p>El <em>httpClient.get</em> retorna un <em>Observable</em> del mismo tipo <em>Country[]</em></p>
<p>NOTA: <em>Country</em> es la interfaz que creamos en el paso anterior.</p>
<h2 id="implementando-el-servicio">Implementando el Servicio</h2>
<p>La búsqueda por Capital va a ser usada por el componente <em>ByCapitalPageComponent</em> Inyectaremos el Nuevo servicio. El código del componente queda de la siguiente forma:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'countries-by-capital-page'</span>,
  templateUrl: <span class="hljs-string">'./by-capital-page.component.html'</span>,
  styles: <span class="hljs-string">``</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ByCapitalPageComponent {

  <span class="hljs-keyword">private</span> countries: Country[] = [];

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> countryService: CountriesService</span>) { }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> getCountries(): Country[] {  
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.countries;
  }

  <span class="hljs-keyword">public</span> searchByCapital(term: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">this</span>.countryService.searchByCapital(term)
      .subscribe(
        <span class="hljs-function">(<span class="hljs-params">countries</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.countries = countries;
        });
  }
}
</div></code></pre>
<p>Posteriormente podemos mostrar rápidamente en una lista el nombre de los países, en el template colocamos esto:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let country of getCountries"</span>&gt;</span>
                 {{ country.name.common }} - {{ country.capital}}
            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>El resultado para el término <em>San</em> es:</p>
<br/>
<img src="./imagenes/countryapp07.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<h2 id="country-table">Country Table</h2>
<p>Implementaremos un nuevo control, para mostrar los países en una tabla.</p>
<pre class="hljs"><code><div>[fcruz@fedora app]$ ng g c countries/countryTable
</div></code></pre>
<p>En el template del nuevo componente creamos por el momento una tabla HTML</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"countries.length === 0; else table"</span>   <span class="hljs-attr">class</span>=<span class="hljs-string">"alert alert-warning text-center"</span>&gt;</span>
    No countries to list!
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>


<span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">table</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"table table-hover"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>#<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Icon<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Capital<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Population<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let country of countries; index as rnum"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{rnum + 1}}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
                    {{country.flag}}
                <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{country.name.common}}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{country.capital}}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{country.population | number}}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>
</div></code></pre>
<p>En código del componente:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'countries-country-table'</span>,
  templateUrl: <span class="hljs-string">'./country-table.component.html'</span>,
  styleUrl: <span class="hljs-string">'./country-table.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CountryTableComponent {

  <span class="hljs-meta">@Input</span>() <span class="hljs-keyword">public</span> countries: Country[] = [];
}
</div></code></pre>
<p>En la sección de <em>declarations</em> del <em>CountriesModule</em>  agregamos el nuevo componente CountryTableComponent. Aunque el componente esta definido dentro de la misma seccón, debemos de hacerlo vivible en el mismo módulo.</p>
<p>Luego en el template del componente ** borramos el <em>UL</em> temporal que habíamos creado y agregamos el nuevo componente:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">countries-country-table</span> [<span class="hljs-attr">countries</span>]=<span class="hljs-string">"getCountries"</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">countries-country-table</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Recordemos que el <em>getCountries</em> retorna la lista de Países que generó la última búsqueda.</p>
<h2 id="catcherror-manejo-de-errores-en-observables">CatchERror: Manejo de Errores en Observables</h2>
<p>ACtualmente no tenemos ninún manejador de errores, cuando hacemos la búsqueda de con un término que no genera resultados, obtenemos, del lado del servicio, un <em>404</em>. Si la tabla ya tiene resultados, da la impresión al usuario que el nuevo término generó los mismos resultados.</p>
<p>Lo que haremos es implementar un <em>catchError</em> del lado del servicio y si ocurre un error, entonces retornamos un arreglo vacío.</p>
<p>El código actualizado es el siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
   * Search countries by Capital
   * @param term string
   * @returns Observable&lt;Country&gt;
   */</span>
  searchByCapital(term: <span class="hljs-built_in">string</span>): Observable&lt;Country[]&gt; {
    <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.apiUrl}</span>/capital/<span class="hljs-subst">${term}</span>`</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.get&lt;Country[]&gt;<span class="hljs-function">(<span class="hljs-params">url</span>).<span class="hljs-params">pipe</span>(<span class="hljs-params"> catchError(<span class="hljs-params"> (<span class="hljs-params">err</span>) =&gt; of(<span class="hljs-params">[]</span>) </span>) </span>);
  }
</span></div></code></pre>
<p>Usamos un <em>pipe</em> y capturamos cualquier error, si hay un error, entonces usamos el operador <em>of</em> para generar un nuevo observable pero con un arreglo vacío.</p>
<p>Con esto resolvemos el problema mencionado.</p>
<h2 id="agregando-m%C3%A1s-criterios-de-b%C3%BAsquedas">Agregando más criterios de búsquedas</h2>
<p>Todos los pasos que se han realizado para mostrar los paises por Capital, se deben repetir para las búsquedas por Región y por Nombre de pais.</p>
<p>Agregaremos los nuevos métodos al Servicio y de paso refactorizamos</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Injectable</span>({
providedIn: <span class="hljs-string">'root'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CountriesService {

<span class="hljs-keyword">private</span> apiUrl: <span class="hljs-built_in">string</span> = <span class="hljs-string">'https://restcountries.com/v3.1'</span>;

<span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> httpClient: HttpClient</span>) { }

<span class="hljs-comment">/**
 * Search countries by Capital
 * @param term string
 * @returns Observable&lt;Country&gt;
 */</span>
searchByCapital(term: <span class="hljs-built_in">string</span>): Observable&lt;Country[]&gt; {
  <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.apiUrl}</span>/capital/<span class="hljs-subst">${term}</span>`</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.searchCountries(term, url);
}

<span class="hljs-comment">/**
 * Search countries by Name
 * @param term string
 * @returns Observable&lt;Country&gt;
 */</span>
searchByName(term: <span class="hljs-built_in">string</span>): Observable&lt;Country[]&gt; {
  <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.apiUrl}</span>/name/<span class="hljs-subst">${term}</span>`</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.searchCountries(term, url);
}

<span class="hljs-comment">/**
 * Search countries by Region
 * @param term string
 * @returns Observable&lt;Country&gt;
 */</span>
  searchByRegion(term: <span class="hljs-built_in">string</span>): Observable&lt;Country[]&gt; {
    <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.apiUrl}</span>/region/<span class="hljs-subst">${term}</span>`</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.searchCountries(term, url);
  }

  <span class="hljs-comment">/**
   * Search countries by Term and URL
   * @param term string
   * @param url string
   * @returns Observable&lt;Country&gt;
   */</span>
  <span class="hljs-keyword">private</span> searchCountries(term: <span class="hljs-built_in">string</span>, url: <span class="hljs-built_in">string</span>): Observable&lt;Country[]&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.get&lt;Country[]&gt;<span class="hljs-function">(<span class="hljs-params">url</span>).<span class="hljs-params">pipe</span>(<span class="hljs-params"> catchError(<span class="hljs-params"> (<span class="hljs-params">err</span>) =&gt; of(<span class="hljs-params">[]</span>) </span>) </span>);
  }
}
</span></div></code></pre>
<p>El resto de los cambios se aplican igual, en los templates y el código javascript de los componentes:</p>
<ul>
<li>ByCountryPageComponent</li>
<li>ByRegionPageComponent</li>
</ul>
<h2 id="argumentos-por-url">Argumentos por URL</h2>
<p>Cuando navegamos al siguiente URL <code>http://localhost:4200/countries/by/CRC</code> el router hace que se cargue el <em>CountryPageComponent</em> debido a esta regla de ruteo:</p>
<pre class="hljs"><code><div>{
        path: <span class="hljs-string">'by/:id'</span>,
        component: CountryPageComponent 
    }
</div></code></pre>
<p>Para acceder a la lista  de parámetros usaremos un servicio: <em>ActivatedRoute</em></p>
<p>Inyectamos el servicio y obtenemos el Params:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CountryPageComponent  <span class="hljs-keyword">implements</span> OnInit{

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> activatedRoute: ActivatedRoute </span>) { }
  
  ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.activatedRoute.params
    .subscribe( <span class="hljs-function">(<span class="hljs-params">params</span>) =&gt;</span> {
      <span class="hljs-built_in">console</span>.log({ params });
    });
  }
}
</div></code></pre>
<p>El console log imprime:</p>
<pre class="hljs"><code><div>{
    &quot;id&quot;: &quot;CRC&quot;
}
</div></code></pre>
<p>Para extraer el <em>id</em> podemos usar <em>params[&quot;id&quot;]</em>  o en el suscribe deestructura el pamas de esta forma:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">this</span>.activatedRoute.params
    .subscribe( <span class="hljs-function">(<span class="hljs-params">{ id }</span>) =&gt;</span> {
      <span class="hljs-built_in">console</span>.log({ params: id });
    });
</div></code></pre>
<p>Este último código imprime:</p>
<pre class="hljs"><code><div>  {params: 'CRC'}
</div></code></pre>
<p>Una vez que tenmos acceso al parámetro, que indica el código del país, necesitmos extender nuestro <em>CoutriesService</em> para buscar paises por códigos.</p>
<h2 id="b%C3%BAsqueda-por-c%C3%B3digo-de-pa%C3%ADs">Búsqueda por Código de País</h2>
<p>Usaremos el endpoint /alpha/:id y crearemos un nuevo método en nuestro servicio</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
   * Get country by Alpha code
   * @param id string
   * @returns Observable&lt;Country&gt;
   */</span>
  getCountryByAlpha(id: <span class="hljs-built_in">string</span>): Observable&lt;Country[]&gt; {
    <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.apiUrl}</span>/alpha/<span class="hljs-subst">${id}</span>`</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.searchCountries(id, url);
  }
</div></code></pre>
<p>Este método utiliza nuestro método único de búsquedas</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
     * Search countries by Term and URL
     * @param term string
     * @param url string
     * @returns Observable&lt;Country&gt;
     */</span>
  <span class="hljs-keyword">private</span> searchCountries(term: <span class="hljs-built_in">string</span>, url: <span class="hljs-built_in">string</span>): Observable&lt;Country[]&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.get&lt;Country[]&gt;<span class="hljs-function">(<span class="hljs-params">url</span>).<span class="hljs-params">pipe</span>(<span class="hljs-params"> catchError(<span class="hljs-params"> (<span class="hljs-params">err</span>) =&gt; of(<span class="hljs-params">[]</span>) </span>) </span>);
  }
</span></div></code></pre>
<p>Siguiente paso: inyectar el servicio en el <em>CountryPageComponent</em> y luego consumirlo:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CountryPageComponent  <span class="hljs-keyword">implements</span> OnInit{

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">private</span> activatedRoute: ActivatedRoute,
    <span class="hljs-keyword">private</span> countriesService: CountriesService </span>) { }
  
  ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.activatedRoute.params
    .subscribe( <span class="hljs-function">(<span class="hljs-params">{ id }</span>) =&gt;</span> {
      <span class="hljs-keyword">this</span>.countriesService.getCountryByAlpha(id).subscribe( <span class="hljs-function"><span class="hljs-params">country</span> =&gt;</span> { 
        <span class="hljs-built_in">console</span>.log( { country });
      } );
    });
  }
}
</div></code></pre>
<p>Esto imprime un arreglo, normalmente con un solo elemento, un País. Pero realmente lo que necesitamos es un único elemento, y hay otro problema mayor, tenemos un llamado a un API dentro de otro llamado a otro API (endpoint), es dedir nos suscribimos a un Observable pero dentro del bloque del primer Observable, tenemos otro, esto se llama CallbackHell y se debe evitar.</p>
<p>Para evitar este escenarios, debemos usar operadores de alto nivel de rxJX, en este caso usaremos el <em>switchMap</em></p>
<pre class="hljs"><code><div>ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.activatedRoute.params
    .pipe(switchMap( <span class="hljs-function">(<span class="hljs-params">{ id }</span>) =&gt;</span> <span class="hljs-keyword">this</span>.countriesService.getCountryByAlpha(id)))
    .subscribe( <span class="hljs-function"><span class="hljs-params">country</span> =&gt;</span> {<span class="hljs-built_in">console</span>.log(country);});
  }
</div></code></pre>
<p><strong>Explicación del Código</strong></p>
<p><em>this.activatedRoute.params</em> nos da un observable, el resultado es un objeto <strong>params : Param</strong>, pero en lugar de suscribirnos, lo que implementamos es un <strong>pipe</strong>, es como colocar un &quot;tubo&quot; en la salida de un Observable, cualquier cosa que genera el primer Observable pasará por esa tubería.</p>
<p>En Angular, los observables son fundamentales para trabajar con flujos asíncronos de datos, como eventos del usuario, peticiones HTTP y otros eventos que pueden ocurrir en el tiempo. El método switchMap es una de las numerosas funciones de alto nivel proporcionadas por la biblioteca RxJS que ayuda a gestionar estos flujos de datos de manera más efectiva.</p>
<p>Vamos a desglosar el código para entenderlo paso a paso:</p>
<p><strong>this.activatedRoute.params</strong> Este es un observable que emite eventos cada vez que los parámetros de la ruta cambian. En Angular, el objeto ActivatedRoute representa la ruta activa, y params es un observable que emite un evento cada vez que los parámetros de la ruta cambian.</p>
<p><strong>.pipe(switchMap(({ id }) =&gt; this.countriesService.getCountryByAlpha(id))):</strong> Aquí estamos utilizando el método pipe para encadenar operadores en el  observable. <strong>switchMap</strong> es uno de esos operadores. Este operador se utiliza para transformar cada valor emitido por el observable (<strong>activatedRoute.params</strong>) en otro observable (<strong>this.countriesService.getCountryByAlpha(id)</strong>). Además, el uso de switchMap implica que solo te interesa el observable más reciente generado por getCountryByAlpha(id) y descartas cualquier observación anterior si aún no se ha completado.</p>
<p><strong>({ id }) =&gt; this.countriesService.getCountryByAlpha(id):</strong> Esta es una función de proyección que toma el valor emitido por <strong>activatedRoute.params</strong> (en este caso, un objeto con una propiedad id) y devuelve un nuevo observable (<strong>this.countriesService.getCountryByAlpha(id)</strong>).</p>
<p><strong>switchMap:</strong> Este operador toma cada valor emitido por <strong>activatedRoute.params</strong>, aplica la función de proyección y &quot;cambia&quot; al nuevo observable retornado por la función de proyección. Si un nuevo evento llega antes de que el observable retornado anteriormente por <strong>getCountryByAlpha(id)</strong> se complete, <strong>el antiguo observable se cancela y se sustituye por el nuevo</strong>.</p>
<p><strong>.subscribe(country =&gt; {console.log(country);})</strong>: Finalmente, te suscribes al observable resultante después de aplicar switchMap. En este punto, estás recibiendo los datos finales emitidos por this.countriesService.getCountryByAlpha(id) después de que ha sido procesado por el operador switchMap. En este caso, el código dentro de subscribe simplemente imprime el país en la consola.</p>
<p>Para finalizar, a parte del <strong>SwitchMap</strong> existen otras funciones, el <strong>ConcatMap</strong> y el <strong>MergeMap</strong> la diferencia radica en como actúan con respecto al momento en el que el observable genera un nuevo evento (Observer)</p>
<p><strong>SwitchMap</strong> Cancela el antiguo observable y los sustituye por el nuevo</p>
<p><strong>ConcatMap</strong> Espera que termien el observable actual para procesar el siguiente. Los valores emitidos por los observables internos se concatenan en lugar de superponerse.</p>
<p><strong>MergeMap</strong> ombina los valores emitidos por todos los observables internos, incluso si no han completado. Puede superponerse en el tiempo.</p>
<h2 id="cambios-en-el-countriesservices">Cambios en el CountriesServices</h2>
<p>Ahora necesitamos una forma de retornar un solo país, en lugar de un arreglo, podemos usar el mismo concepto, aplicar un PIPE con una función reductora para retornar un único elemento.</p>
<p>El método actual es el siguiente:</p>
<pre class="hljs"><code><div>getCountryByAlpha(id: <span class="hljs-built_in">string</span>): Observable&lt;Country[]&gt; {
    <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.apiUrl}</span>/alpha/<span class="hljs-subst">${id}</span>`</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.searchCountries(id, url);
  }
</div></code></pre>
<p>Recordemos que <strong>searchCountries</strong> regresa siempre un <strong>Observable&lt;Country[]&gt;</strong> Lo que necesitamos es que al final <strong>getCountryByAlpha</strong> regrese un <strong>Observable&lt;Country | null&gt;</strong> el null es porque si la búsqueda no retorna nada, genera un error, y necesitamos regresar un null a la capa superior.</p>
<p>El nuevo método es como sigue:</p>
<pre class="hljs"><code><div> getCountryByAlpha(id: <span class="hljs-built_in">string</span>): Observable&lt;Country | <span class="hljs-literal">null</span>&gt; {
   <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.apiUrl}</span>/alpha/<span class="hljs-subst">${id}</span>`</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.searchCountries(id, url)
   .pipe(map( (countries: 
     Country[]) =&gt; countries.length &gt; <span class="hljs-number">0</span> ? countries[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span> ))
 }
</div></code></pre>
<p>Estamos usando nuevamente un PIPE, y esta vez usamos una función <strong>map</strong>, si el arreglo tiene al menos un elemento, regresaremos siempre el primero, dado que enviamos una petición por código de país, esperamos que siempre retorne null o un país.</p>
<p>Con este cambio, el método <strong>getCountryByAlpha</strong> ya retorna un Observable&lt;Country | null&gt;</p>
<h2 id="validacion-del-null">Validacion del Null</h2>
<p>Si la consulta por código de país retorna un <strong>null</strong> debemos sacar al usuario de esa página, no tiene sentido mantener ese URL porque tiene un código incorrecto,</p>
<p>Para ello, en el <strong>CountryPageComponent</strong> inyectaremos un nuevo servicio  <strong>private router: Router</strong> y luego validamos el null. Si la respuesta es null, entonce enviamos al usuario a otra pantalla con <strong>this.router.navigateByUrl('/countries');</strong> Caso contrario, tendremos la información del país en la variable <strong>public country?: Country;</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CountryPageComponent  <span class="hljs-keyword">implements</span> OnInit{

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">private</span> activatedRoute: ActivatedRoute,
    <span class="hljs-keyword">private</span> countriesService: CountriesService,
    <span class="hljs-keyword">private</span> router: Router </span>) { }
  
  <span class="hljs-keyword">public</span> country?: Country;

  ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.activatedRoute.params
    .pipe(switchMap( <span class="hljs-function">(<span class="hljs-params">{ id }</span>) =&gt;</span> <span class="hljs-keyword">this</span>.countriesService.getCountryByAlpha(id)))
    .subscribe( <span class="hljs-function"><span class="hljs-params">country</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!country) {
        <span class="hljs-keyword">this</span>.router.navigateByUrl(<span class="hljs-string">'/countries'</span>);
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">this</span>.country = country;
    });
  }
}
</div></code></pre>
<h2 id="mostrar-informac%C3%B3n-por-pa%C3%ADs">Mostrar informacón por País</h2>
<p><strong>CountryPageComponent</strong> ya tiene la información del país seleccionado, en la variable <strong>country</strong> ahora trabajaremos en el template para mostrar información:</p>
<p>Tenemos un <strong>ng-template</strong>, el cual se muestra brevemente mientras no se ha cargado la info del país, y luego, trabajaremos en el HTML para mostrar toda la data. Por el momento solo mostramos el nombre:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> #<span class="hljs-attr">loading</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"alert alert-info text-center"</span>&gt;</span>
       Loading country information! Wait a moment please...
   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"country; else loading"</span>&gt;</span>
   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-12"</span>&gt;</span>
           <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Country: {{country.name.common}}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>POdemos agregar más información, algunos de los datos necesitan un tratamiento especial, por ejemplo el <strong>translations</strong></p>
<p>En la interfaz tenemos:</p>
<pre class="hljs"><code><div>translations: { [key: <span class="hljs-built_in">string</span>]: Translation };
</div></code></pre>
<p>Podemos usar un <strong>ngFor</strong> y obtener el KEY del Mapa.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"badge bg-secondary m-1"</span>
    *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let currency of country.currencies| keyvalue"</span> &gt;</span>
     {{currency.key | uppercase}} {{ country.currencies[currency.key].name }}
 <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<p>El resultado de navegar a este url: <em>http://localhost:4200/countries/by/SMR</em> será:</p>
<br/>
<img src="./imagenes/countryapp08.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<h2 id="navegar-desde-el-countrytablecomponent">Navegar desde el CountryTableComponent</h2>
<p>Al final de la tabla agreguemos un link:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"['/countries/by', country.cca3]"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-outline-primary btn-sm"</span>&gt;</span>
        View
    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
</div></code></pre>
<p>Dado que estamos usando el <strong>routerLink</strong> necesitamos importar el <strong>RouterModule</strong> en el módulo al que pertenece el <strong>CountryTableComponent</strong> es decir en el <strong>CountriesModule</strong>:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">import</span> { RouterModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;

<span class="hljs-meta">@NgModule</span>({
  imports: [
    RouterModule
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CountriesModule { }
</div></code></pre>
<p>Listo, con esto tenemos un link al final de la tabla que abre el componente <strong>CountryPageComponent</strong> con el país seleccionado</p>
<br/>
<img src="./imagenes/countryapp09.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-mejoras-y-funcionalidades-extras">Nueva Sección: Mejoras y Funcionalidades Extras</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>Aquí continuaremos la aplicación de países, pero enfocados en la parte de las sugerencias, debounce y mantener el estado de las consultas, este es un breve listado de los temas fundamentales:</p>
<ul>
<li>ngClass y diferentes formas de manipular clases</li>
<li>CSS condicionales</li>
<li>Optimizaciones a peticiones HTTP</li>
<li>Debounce manual mediante RxJs</li>
<li>LocalStorage</li>
<li>Ideas de Store</li>
<li>Re-utilización de componentes</li>
<li>Varios operadores de RxJS aplicados</li>
</ul>
<h2 id="nuevo-componente-loading">Nuevo componente Loading</h2>
<p>Vamos agregar un componente que muestre un Spinner mientras cargamos un componente, en este caso la tabla de paises.</p>
<pre class="hljs"><code><div>fcruz@fedora 03-countryApp]$ ng g c shared/components/loadingSpinner
CREATE src/app/shared/components/loading-spinner/loading-spinner.component.css (0 bytes)
CREATE src/app/shared/components/loading-spinner/loading-spinner.component.html (30 bytes)
CREATE src/app/shared/components/loading-spinner/loading-spinner.component.spec.ts (658 bytes)
CREATE src/app/shared/components/loading-spinner/loading-spinner.component.ts (234 bytes)
UPDATE src/app/shared/shared.module.ts (1033 bytes)
</div></code></pre>
<p>Agregamos en el template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spinner-container bg-dark"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Searching...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"assets/loader.svg"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Los Estilos</p>
<pre class="hljs"><code><div><span class="hljs-selector-class">.spinner-container</span> {
  <span class="hljs-attribute">align-items</span>: center;
  <span class="hljs-attribute">background-color</span>: black;
  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">20px</span>;
  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">15px</span>;
  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">10px</span> <span class="hljs-number">0px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.75</span>);
  <span class="hljs-attribute">color</span>: white;
  <span class="hljs-attribute">display</span>: flex;
  <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">position</span>: fixed;
  <span class="hljs-attribute">right</span>: <span class="hljs-number">15px</span>;
}

<span class="hljs-selector-tag">span</span> {
  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">10px</span>;
  <span class="hljs-attribute">font-weight</span>: <span class="hljs-number">800</span>;
}
</div></code></pre>
<p>El componente: (no hemos agregado nada)</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'shared-loading-spinner'</span>,
  templateUrl: <span class="hljs-string">'./loading-spinner.component.html'</span>,
  styleUrl: <span class="hljs-string">'./loading-spinner.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> LoadingSpinnerComponent {

}
</div></code></pre>
<p>Lo declaramos y lo exportamos en el <strong>SharedModule</strong></p>
<p>Y luego lo implementamos, primero en el <strong>ByCapitalPageComponent</strong> en el template, en cualquier parte, agregamos el componente</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">shared-loading-spinner</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isLoading"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">shared-loading-spinner</span>&gt;</span>
</div></code></pre>
<p>Tal como se puede ver depende de una propiedad <strong>isLoading</strong> la cual debemos definir en nuestro compoenente <strong>ByCapitalPageComponent</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ByCapitalPageComponent {

  <span class="hljs-keyword">private</span> countries: Country[] = [];

  <span class="hljs-keyword">public</span> isLoading: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> countryService: CountriesService</span>) { }

  <span class="hljs-keyword">public</span> <span class="hljs-keyword">get</span> getCountries(): Country[] {  
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.countries;
  }

  <span class="hljs-keyword">public</span> searchByCapital(term: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.countryService.searchByCapital(term)
      .subscribe(
        <span class="hljs-function">(<span class="hljs-params">countries</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.countries = countries;
          <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">false</span>;
        });
  }
}
</div></code></pre>
<p><strong>isLoading</strong> es <em>Flase</em> y justo cuando iniciamos la petición <strong>searchByCapital</strong> se cambia a <em>True</em> esto hace que se muestre el Spinner, y cuando se completa la carga se regresa a <em>False</em></p>
<br/>
<img src="./imagenes/countryapp10.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<h2 id="debounce">Debounce</h2>
<p>Vamos a escribir esta funcionalidad que permite al usuario realizar la búsqueda sin la necesidad de presionar ENTER, luego de que el usuario deja de escribir por cierto tiempo, vamos a iniciar la búsqueda automáticamente.</p>
<p>Lo primero es agregar un nuevo evento en el textBox del Search, *<em>SearchBoxComponent</em></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
<span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
[<span class="hljs-attr">placeholder</span>]=<span class="hljs-string">"placeholder"</span>
<span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>
(<span class="hljs-attr">keyup.enter</span>)=<span class="hljs-string">"searchBy()"</span>
(<span class="hljs-attr">keyup</span>)=<span class="hljs-string">"onKeyPress($event)"</span>
#<span class="hljs-attr">txtSearchInput</span>&gt;</span>
</div></code></pre>
<p>Luego debemos implementar el evento <strong>onKeyPress($event)</strong> para ello antes debemos crear un debouncer, y usaremos el <strong>Subject</strong> de rxJS,</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
 * A Subject is a special type of Observable that allows values to be
 * multicasted to many Observers. Subjects are like EventEmitters.
 *
 * Every Subject is an Observable and an Observer. You can subscribe to a
 * Subject, and you can call next to feed values as well as error and complete.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Subject&lt;T&gt; <span class="hljs-keyword">extends</span> Observable&lt;T&gt; <span class="hljs-keyword">implements</span> SubscriptionLike {}
</div></code></pre>
<p>Implementamos un debouncer que emitira <strong>strings</strong> (texto de búsqueda del usuario)</p>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> debouncer: Subject&lt;<span class="hljs-built_in">string</span>&gt; = <span class="hljs-keyword">new</span> Subject();
</div></code></pre>
<p>Luego debemos suscribirnos a ese OBservable, lo hacemos en el <strong>ngOnInit</strong></p>
<pre class="hljs"><code><div>ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.debouncer
    .pipe(
      debounceTime(<span class="hljs-number">300</span>)
    )
    .subscribe( <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
      <span class="hljs-keyword">this</span>.searchBy();
    });
  }
</div></code></pre>
<p>Aca vemos que se implementa un <strong>PIPE</strong> para agregar un delay de 300 ms cuando se emite un evento. Luego de ese delay, se dispara el <strong>subscribe</strong> que al final es el que llama a la búsqueda.</p>
<p>Y finalmente, debemos escribir el código que hace la emisión, eso lo hacemos en el método que se llama desde el componente. Es decir desde nuestro <strong>onKeyPress</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> onKeyPress(event: <span class="hljs-built_in">any</span>) {
    <span class="hljs-keyword">this</span>.debouncer.next(<span class="hljs-keyword">this</span>.txtSearchInput.nativeElement.value);
  }
</div></code></pre>
<p>Entonces, resumiendo:</p>
<ul>
<li>El usuario escribe en la caja de texto</li>
<li>Esto llama al <strong>onKeyPress</strong> quien emite un evento con el <strong>this.debouncer.next</strong></li>
<li>El <strong>.pipe(debounceTime(300))</strong> detiene por 300 MS el evento</li>
<li>Si el usuario continúa escribiendo, se genera un nuevo evento y se cancela el anterior</li>
<li>Si el usuario deja de escribir durante 300 MS, se ejecuta la suscripción <strong>.subscribe( value =&gt; {this.searchBy();});</strong></li>
<li>Eso dispara la búsqueda <strong>this.searchBy();</strong></li>
<li>El usuario ve datos en pantalla</li>
</ul>
<br/>
<img src="./imagenes/countryapp11.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<h2 id="limpieza-de-suscripciones">Limpieza de suscripciones</h2>
<p>Generalmente, a nivel de componentes, cuando estos se destruyen, las suscripciones siguen activas, y aunque no se disparen más, (hasta que el componente se cree nuevamente) es mejor limpiarlas. Para ello se implementa el <strong>ngOnDestroy</strong></p>
<pre class="hljs"><code><div>ngOnDestroy(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.debouncer.unsubscribe();
  }
</div></code></pre>
<h2 id="optimizar-b%C3%BAsqueda-por-regiones">Optimizar búsqueda por regiones</h2>
<p>La búsqueda por región solo acepta ciertas regiones, lo mejor es usar un dropdown o algo similar para que el usuario seleccione una región específica en lugar de usar el SearchBox.</p>
<p>Primero en el componente <strong>ByRegionPageComponent</strong> agregamos un tipo y un arreglo de ese tipo</p>
<pre class="hljs"><code><div><span class="hljs-keyword">type</span> regions = <span class="hljs-string">'africa'</span> | <span class="hljs-string">'americas'</span> | <span class="hljs-string">'asia'</span> | <span class="hljs-string">'europe'</span> | <span class="hljs-string">'oceania'</span>;

<span class="hljs-keyword">public</span> regions: regions[] = [<span class="hljs-string">'africa'</span>, <span class="hljs-string">'americas'</span>, <span class="hljs-string">'asia'</span>, <span class="hljs-string">'europe'</span>, <span class="hljs-string">'oceania'</span>];
</div></code></pre>
<p>Luego, en el template del mismo componente, vamos a eliminar la referencia al componente <strong>shared-search-box</strong> y lo reemplazaremos por una lista de botones, uno por cada región.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
        *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let region of regions"</span>
        [<span class="hljs-attr">ngClass</span>]=<span class="hljs-string">"{ 'btn-outline-primary': region === activeRegion }"</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"btn  btn-block m-2 text-center"</span>
        (<span class="hljs-attr">click</span>)=<span class="hljs-string">"searchByRegion(region)"</span>
        &gt;</span>
            {{ region | titlecase }}
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>Se agrega un [ngClass] para permitir agregar una clase que muestre que botón ha sido seleccionado, el resultado es:</p>
<br/>
<img src="./imagenes/countryapp12.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<h2 id="mantener-data-en-pantalla">Mantener Data en Pantalla</h2>
<p>La versión actual de la app, no permite persistir datos cuando nos movemos entre pantallas, si realizamos una búsqueda y nevegamos al detalle de un país, al regresar hemos perdido el resultado de la búsqueda realizada anteriormente.</p>
<p>Esto sucede porque cuando cambiamos de ruta, el componente presentado se destruye para mostrar uno nuevo. Y varias propiedades, como la lista de países, se inicializan con un arreglo vacío, al inicializar el componente, por lo tanto la tabla de países siempre aparece vacía.</p>
<p>Se puede implementar LocalStorage, para que cada componente guarde la lista de paises, o podemos usar algún tipo de estructura en memoria para guardar los datos.</p>
<p>usaremos un OBjeto en memoria, y el mejor lugar para colocarlo es el servicio, ya que este se inyecta una sola vez y permanece en memoria durante la ejecución de la app.</p>
<p>En primer lugar, el tipo <em>Regions</em> que habíamos agregado a nivel del servicio, lo vamos a crear en un archivo independiente dentro de un directorio <em>Types</em></p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> Regions = <span class="hljs-string">'africa'</span> | <span class="hljs-string">'americas'</span> | <span class="hljs-string">'asia'</span> | <span class="hljs-string">'europe'</span> | <span class="hljs-string">'oceania'</span>;
</div></code></pre>
<p>Luego vamos a crear una interfaz, dentro del directorio <em>interfaces</em></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Regions } <span class="hljs-keyword">from</span> <span class="hljs-string">"../types/regions.types"</span>;
<span class="hljs-keyword">import</span> { Country } <span class="hljs-keyword">from</span> <span class="hljs-string">"./country.interface"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> cacheStorage {
    byCapital: cacheData;
    byCountry: cacheData;
    byRegion : cacheRegionData;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> cacheData {
    term     : <span class="hljs-built_in">string</span>;
    countries: Country[];
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> cacheRegionData {  
    region?    : Regions;
    countries  : Country[];
}
</div></code></pre>
<p>Y luego, en nuestro servicio, creamos la estructura de datos:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> cacheCountries: cacheStorage = {
    byCapital: { term: <span class="hljs-string">''</span>, countries: [] },
    byCountry: { term: <span class="hljs-string">''</span>, countries: [] },
    byRegion : { region: <span class="hljs-literal">undefined</span>, countries: [] },
  }
</div></code></pre>
<p>Notar que para Region hemos definido como nullable, porque no podemos inicializarla con una cadena vacía, porque no es aceptado por nuestro tipo de datos <strong>Regions</strong></p>
<p>Por lo tanto la inicializamos en <em>undefined</em></p>
<h2 id="guardando-datos-en-el-cachestorage">Guardando datos en el cacheStorage</h2>
<p>El punto ideal para guardar es en el servicio, tan pronto realizamos la búsqueda debemos de guardar en el cacheStorage.</p>
<p>Por ejemplo, en la búsqueda por Capital</p>
<pre class="hljs"><code><div>searchByCapital(term: <span class="hljs-built_in">string</span>): Observable&lt;Country[]&gt; {
   <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.apiUrl}</span>/capital/<span class="hljs-subst">${term}</span>`</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.searchCountries(term, url);
 }
</div></code></pre>
<p>Pero recordemos que el <strong>this.searchCountries(term, url);</strong> retorna un <em>Observable</em>, y como necesitamos seguir regresando el mismo tipo de datos no podemos <em>Suscribirnos</em> para acceder a los <em>Countries</em>, pero, podemos usar un <strong>PIPE</strong> con una función RXJS para acceder a los Countries, llenar el Cache y retornar siempre un Observable, lo haremos con el <strong>TAP</strong></p>
<pre class="hljs"><code><div>searchByCapital(term: <span class="hljs-built_in">string</span>): Observable&lt;Country[]&gt; {
   <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.apiUrl}</span>/capital/<span class="hljs-subst">${term}</span>`</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.searchCountries(term, url)
   .pipe(
     tap( <span class="hljs-function">(<span class="hljs-params">countries</span>) =&gt;</span> {
       <span class="hljs-keyword">this</span>.cacheCountries.byCapital = { term, countries };
     })
   );
 }
</div></code></pre>
<p>El <strong>TAP</strong> unicamente extrae el dato de la tubería, y no es necesario especificar un <strong>return</strong>, el flujo continua siendo un Observable.</p>
<p>A diferencia del <strong>MAP</strong> u otras funciones, estas interceptan el valor, lo procesan y debemos retornar algo a la tubería explicitamente.</p>
<p>Aplicamos el mismo cambio en las otras búsquedas dentro del mismo servicio y listo, ahora falta usar esa información en memoria.</p>
<h2 id="usando-el-cachestorage">Usando el cacheStorage</h2>
<p>En este caso, debemos implementar esto a nivel de componente, todo aquel componente que use la lista de países, podemos ir al <strong>cacheStorage</strong> y tomar los datos iniciales de allí, en lugar de inicializarlo con un arreglo vacío.</p>
<p>También necesitamos restaurar el último término de búsqueda.</p>
<p>Haremos en cambio en el <strong>ByCapitalPageComponent</strong>, ya tenemos una propiedad para la lista de paises, agreguemos una para el termino de búsqueda:</p>
<pre class="hljs"><code><div>  <span class="hljs-keyword">private</span> countries: Country[] = [];
  <span class="hljs-keyword">public</span> sotoredSearchValue: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;
</div></code></pre>
<p>En el ngOnInit necesitamos cargar estos valores desde el Caché:</p>
<pre class="hljs"><code><div>ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.sotoredSearchValue = <span class="hljs-keyword">this</span>.countryService.cacheCountries.byCapital.term;
    <span class="hljs-keyword">this</span>.countries = <span class="hljs-keyword">this</span>.countryService.cacheCountries.byCapital.countries;
  }
</div></code></pre>
<p>Con este cambio, ya estamos listos con el asunto de los países, veremos que la tabla de Países mantiene el último resultado cuando nos movemos entre componentes, pero no así con el término de búsqueda. PAra el caso de la búsqueda por Capital y Pais usamos el <strong>SearchBoxComponent</strong>, debemos pasarle el valor guardado en memoria, y para ello necesitamos agregar un @Input en dicho componente:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Input</span>() <span class="hljs-keyword">public</span> sotoredSearchValue: <span class="hljs-built_in">string</span> = <span class="hljs-string">''</span>;
</div></code></pre>
<p>y luego lo usamos en su template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
<span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
[<span class="hljs-attr">value</span>]=<span class="hljs-string">"sotoredSearchValue"</span>
[<span class="hljs-attr">placeholder</span>]=<span class="hljs-string">"placeholder"</span>
<span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>
(<span class="hljs-attr">keyup.enter</span>)=<span class="hljs-string">"searchBy()"</span>
(<span class="hljs-attr">keyup</span>)=<span class="hljs-string">"onKeyPress($event)"</span>
#<span class="hljs-attr">txtSearchInput</span>&gt;</span>
</div></code></pre>
<p>Y finalmente necesitamos pasarle ese valor desde el componente que lo implementa, en este caso desde <strong>ByCapitalPageComponent</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">shared-search-box</span>
        [<span class="hljs-attr">sotoredSearchValue</span>]=<span class="hljs-string">"sotoredSearchValue"</span>
        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Search by Capital"</span>
        (<span class="hljs-attr">onNewSearch</span>)=<span class="hljs-string">"searchByCapital($event)"</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">shared-search-box</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Con ese cambio, podemos mantener tanto el último término de búsqueda como la lista de países cuando nos movemos entre componentes.</p>
<p>La implementación es exactamente igual para el componente <strong>ByCountryPageComponent</strong> pero en el caso de la región debemos usar otra forma para indicar que región había sido seleccionada, porque en ese caso usamos botones en lugar del SearchBOX.</p>
<pre class="hljs"><code><div>ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.countries = <span class="hljs-keyword">this</span>.countryService.cacheCountries.byRegion.countries;
    <span class="hljs-keyword">this</span>.activeRegion = <span class="hljs-keyword">this</span>.countryService.cacheCountries.byRegion.region;
  }
</div></code></pre>
<h2 id="agregando-mapas-no-inlcuido-en-el-curso">Agregando Mapas (No inlcuido en el curso)</h2>
<p>Usaremos la libreria <strong>leaflet</strong></p>
<pre class="hljs"><code><div>npm install leaflet @asymmetrik/ngx-leaflet leaflet-minimap
</div></code></pre>
<p>Agregamos un componente básico:</p>
<pre class="hljs"><code><div>[fcruz@fedora 03-countryApp]$ ng g c shared/components/map
CREATE src/app/shared/components/map/map.component.css (0 bytes)
CREATE src/app/shared/components/map/map.component.html (18 bytes)
CREATE src/app/shared/components/map/map.component.spec.ts (580 bytes)
CREATE src/app/shared/components/map/map.component.ts (187 bytes)
UPDATE src/app/shared/shared.module.ts (1146 bytes)

</div></code></pre>
<p>Buscamos la sección de Styles en el archivo <strong>angular.json</strong> y agregamos:</p>
<pre class="hljs"><code><div><span class="hljs-string">"styles"</span>: [
    <span class="hljs-string">"node_modules/leaflet/dist/leaflet.css"</span>,
    <span class="hljs-string">"node_modules/leaflet-minimap/dist/Control.MiniMap.css"</span>
    <span class="hljs-string">"src/styles.css"</span>
</div></code></pre>
<p>Tambien agregamos los JS</p>
<pre class="hljs"><code><div><span class="hljs-string">"scripts"</span>: [
  <span class="hljs-string">"node_modules/leaflet/dist/leaflet.js"</span>,
  <span class="hljs-string">"node_modules/leaflet-minimap/dist/Control.MiniMap.js"</span>
]
</div></code></pre>
<p>El componente se define de la siguiente forma, el template es muy simple:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"map-container"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"map-frame"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"map"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Y el componente en sí contiene el siguiente código:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { AfterViewInit, Component, Input } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> leaflet <span class="hljs-keyword">from</span> <span class="hljs-string">'leaflet'</span>;
<span class="hljs-keyword">import</span> { CountryMap } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../countries/interfaces/country.interface'</span>;
<span class="hljs-keyword">import</span> { HttpClient } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/http'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'shared-map'</span>,
  templateUrl: <span class="hljs-string">'./map.component.html'</span>,
  styleUrl: <span class="hljs-string">'./map.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MapComponent  <span class="hljs-keyword">implements</span> AfterViewInit{
  
  <span class="hljs-meta">@Input</span>() <span class="hljs-keyword">public</span> countries!: CountryMap[];

  <span class="hljs-keyword">private</span> map!: leaflet.Map;

  <span class="hljs-keyword">private</span> initMap(): <span class="hljs-built_in">void</span> {

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.countries) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> lat = <span class="hljs-keyword">this</span>.countries[<span class="hljs-number">0</span>].latlng[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">var</span> lng = <span class="hljs-keyword">this</span>.countries[<span class="hljs-number">0</span>].latlng[<span class="hljs-number">1</span>];

    <span class="hljs-keyword">this</span>.map = leaflet.map(<span class="hljs-string">'map'</span>, {
      center: [ lat, lng ],
      zoom: <span class="hljs-number">5</span>
    });

    <span class="hljs-keyword">const</span> tiles = leaflet.tileLayer(<span class="hljs-string">'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'</span>, {
      maxZoom: <span class="hljs-number">18</span>,
      minZoom: <span class="hljs-number">3</span>,
      attribution: <span class="hljs-string">'&amp;copy; &lt;a href="http://www.openstreetmap.org/copyright"&gt;OpenStreetMap&lt;/a&gt;'</span>
    });

    tiles.addTo(<span class="hljs-keyword">this</span>.map);

    <span class="hljs-keyword">this</span>.loadGeoJson(<span class="hljs-keyword">this</span>.countries[<span class="hljs-number">0</span>].cca3);
  }

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> httpClient: HttpClient</span>) { }

  ngAfterViewInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.initMap();
  }

  <span class="hljs-keyword">private</span> loadGeoJson(countryCode: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">const</span> geoJsonUrl = <span class="hljs-string">`../../assets/geojsonfiles/<span class="hljs-subst">${countryCode}</span>.geojson`</span>;

    <span class="hljs-keyword">this</span>.httpClient.get(geoJsonUrl).subscribe(<span class="hljs-function">(<span class="hljs-params">geoJson: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> geoJsonLayer = leaflet.geoJSON(geoJson);
      geoJsonLayer.addTo(<span class="hljs-keyword">this</span>.map);
    });
  }
}

</div></code></pre>
<p>El componente acepta un arreglo de paises, pero por el momento solo estamos mostrando el primer país</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> lat = <span class="hljs-keyword">this</span>.countries[<span class="hljs-number">0</span>].latlng[<span class="hljs-number">0</span>];
<span class="hljs-keyword">var</span> lng = <span class="hljs-keyword">this</span>.countries[<span class="hljs-number">0</span>].latlng[<span class="hljs-number">1</span>];
</div></code></pre>
<p>La idea es que cuando abrimos la información de un país en específico debemos colorear el área de dicho país en el mapa, para ellos necesitmos unos arhivos especiales, los geoJson, el cual contiene toda la inforamción para crear la capa necesaria en el mapa.</p>
<p>Estos archivos fueron descargados del sitio <a href="https://www.geoboundaries.org">https://www.geoboundaries.org</a> se descargó el archivo global, y mediande un script en PHP se crearon archivos individuales usando el código de país</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;?php</span>

ini_set(<span class="hljs-string">'memory_limit'</span>, <span class="hljs-string">'8912M'</span>);

<span class="hljs-comment">// Read the geoBoundariesCGAZ_ADM0.geojson file</span>
$geoBoundariesCGAZ_ADM0 = file_get_contents(<span class="hljs-string">'geoBoundariesCGAZ_ADM0.geojson'</span>);
$geoBoundariesCGAZ_ADM0 = json_decode($geoBoundariesCGAZ_ADM0, <span class="hljs-keyword">true</span>);

<span class="hljs-comment">// Loop through the features</span>
<span class="hljs-keyword">foreach</span> ($geoBoundariesCGAZ_ADM0[<span class="hljs-string">'features'</span>] <span class="hljs-keyword">as</span> $feature) {
    <span class="hljs-comment">// Get the country code</span>
    $countryCode = $feature[<span class="hljs-string">'properties'</span>][<span class="hljs-string">'shapeGroup'</span>];

    <span class="hljs-comment">// Create the file name</span>
    $fileName = <span class="hljs-string">'byCountry/'</span> . $countryCode . <span class="hljs-string">'.geojson'</span>;

    <span class="hljs-comment">// Create the FeatureCollection structure</span>
    $featureCollection = [
        <span class="hljs-string">'type'</span> =&gt; <span class="hljs-string">'FeatureCollection'</span>,
        <span class="hljs-string">'crs'</span> =&gt; [
            <span class="hljs-string">'type'</span> =&gt; <span class="hljs-string">'name'</span>,
            <span class="hljs-string">'properties'</span> =&gt; [
                <span class="hljs-string">'name'</span> =&gt; <span class="hljs-string">'urn:ogc:def:crs:OGC:1.3:CRS84'</span>
            ]
        ],
        <span class="hljs-string">'features'</span> =&gt; [$feature] <span class="hljs-comment">// Contiene solo la característica actual</span>
    ];

    <span class="hljs-comment">// Convertir la estructura a JSON</span>
    $featureCollectionJson = json_encode($featureCollection, JSON_PRETTY_PRINT);

    <span class="hljs-comment">// Crear el archivo con la estructura FeatureCollection</span>
    file_put_contents($fileName, $featureCollectionJson);
}


</div></code></pre>
<p>Esto genero un archivo por país el cual es leído desde el médoto <strong>loadGeoJson</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> loadGeoJson(countryCode: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">const</span> geoJsonUrl = <span class="hljs-string">`../../assets/geojsonfiles/<span class="hljs-subst">${countryCode}</span>.geojson`</span>;

    <span class="hljs-keyword">this</span>.httpClient.get(geoJsonUrl).subscribe(<span class="hljs-function">(<span class="hljs-params">geoJson: <span class="hljs-built_in">any</span></span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> geoJsonLayer = leaflet.geoJSON(geoJson);
      geoJsonLayer.addTo(<span class="hljs-keyword">this</span>.map);
    });
  }
</div></code></pre>
<p>Se agregó una interfaz para enviar datos reducidos al mapa y no todo el objeto de Country:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> CountryMap {
    name:         <span class="hljs-built_in">string</span>;
    cca2:         <span class="hljs-built_in">string</span>;
    ccn3:         <span class="hljs-built_in">string</span>;
    cca3:         <span class="hljs-built_in">string</span>;
    cioc:         <span class="hljs-built_in">string</span>;
    latlng:       <span class="hljs-built_in">number</span>[];
    maps:         Maps;
}
</div></code></pre>
<p>Ese es el tipo de dato que recibe el componente Mapa</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Input</span>() <span class="hljs-keyword">public</span> countries!: CountryMap[];
</div></code></pre>
<p>Luego usamos el nuevo componente, lo agregaremos al <strong>CountryPageComponent</strong> primero definimos una propiedad:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> countryMap: CountryMap[] = [];
</div></code></pre>
<p>Esta propiedad se llena en el ngOnInit</p>
<pre class="hljs"><code><div><span class="hljs-keyword">this</span>.countryMap = [<span class="hljs-keyword">this</span>.CountryMapMapper(country)];
</div></code></pre>
<p>Recordemos que <strong>country</strong> cotiene toda la información que proviene del servicio <code>this.countriesService.getCountryByAlpha(id)</code> adicionalmente, mapeamos toda la información del país a un objeto más simple.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> CountryMapMapper(country: Country): CountryMap {
    <span class="hljs-keyword">return</span> {
      name: country.name.common,
      cca2: country.cca2,
      ccn3: country.ccn3,
      cca3: country.cca3,
      cioc: country.cioc,
      latlng: country.latlng,
      maps: country.maps,
    }
  }
</div></code></pre>
<p>Finalmente agregamos a nuestro template la referencia al mapa y le pasamos un arreglo de países, en este caso un único país, el seleccionado para mostrar</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"map-component-container"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">shared-map</span> [<span class="hljs-attr">countries</span>]=<span class="hljs-string">"countryMap"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">shared-map</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Los resultados:</p>
<br/>
<img src="./imagenes/countryapp13.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-pipes-en-angular">Nueva Sección: PIPES en Angular</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>Esta sección es de mis favoritas del curso, veremos temas sobre Pipes y transformación visual de la data, pero también decidí mezclarlo con otro tema muy solicitado que es PrimeNG (Más adelante hay también una sección con muchos componentes de Angular Material), pero esta sección pretende enseñarles muchas cosas interesantes, aparte de los Pipes de Angular</p>
<p>Este es un breve listado de los temas fundamentales:</p>
<p>Todos los Pipes de Angular a la fecha</p>
<p><strong>Uppercase, Lowercase, TitleCase, Date, Decimal, Currency, Percent,i18nSelect, i18Plural,KeyValue, Json, Async,PrimeNG.</strong></p>
<p>Módulo especializado para módulos de PrimeNG</p>
<p>PrimeNG es un paquete de componentes estilizados que contienen funcionalidades basadas en Angular para crear aplicaciones elegantes, hermosas y funcionales rápidamente.</p>
<h2 id="nueva-app">Nueva APP</h2>
<p>Crearemos una nueva APP para implementar los PIPES</p>
<pre class="hljs"><code><div>ng new 04-pipesApp --standalone false
</div></code></pre>
<p>Borrar el template del HTML y dejar el</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
</div></code></pre>
<h2 id="que-son-los-pipes">Que son los Pipes?</h2>
<p>Los <strong>pipes</strong> (tuberías o filtros) son herramientas que te permiten transformar y dar formato a los datos que se muestran en la interfaz de usuario. Los pipes se utilizan principalmente en las plantillas de Angular para realizar operaciones de manipulación y presentación de datos de manera declarativa.</p>
<p>Angular proporciona varios pipes incorporados que cubren tareas comunes, como formatear fechas, números, cadenas de texto, entre otras. Algunos ejemplos de pipes integrados en Angular incluyen DatePipe, DecimalPipe, y UpperCasePipe.</p>
<p>Aquí hay un ejemplo básico de cómo se utiliza un pipe en una plantilla de Angular:</p>
<pre class="hljs"><code><div><span class="hljs-comment">&lt;!-- Supongamos que 'nombre' es una variable en el componente --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ nombre | uppercase }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</div></code></pre>
<p>En este ejemplo, <strong>uppercase</strong> es un pipe que convierte el valor de la variable nombre a mayúsculas antes de mostrarlo en la plantilla.</p>
<p>Además de los pipes integrados, también puedes crear tus propios <strong>pipes personalizados</strong> para realizar transformaciones específicas de datos según tus necesidades. Los pipes personalizados te permiten encapsular lógica de formato y reutilizarla en diferentes partes de tu aplicación.</p>
<p>Aquí hay un ejemplo simple de cómo crear un pipe personalizado en Angular:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Pipe, PipeTransform } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Pipe</span>({
  name: <span class="hljs-string">'miPipePersonalizado'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MiPipePersonalizado <span class="hljs-keyword">implements</span> PipeTransform {
  transform(valor: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span> {
    <span class="hljs-comment">// Realizar la lógica de transformación aquí</span>
    <span class="hljs-comment">// Devolver el valor transformado</span>
    <span class="hljs-keyword">return</span> valor;
  }
}
</div></code></pre>
<p>Luego, en tu plantilla, puedes usar el pipe personalizado de la siguiente manera:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ miDato | miPipePersonalizado }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</div></code></pre>
<h2 id="primeng">PrimeNG</h2>
<p>PrimeNG es una biblioteca de componentes de interfaz de usuario (UI) para Angular. Proporciona una amplia variedad de componentes UI que pueden ser utilizados en el desarrollo de aplicaciones web con Angular.</p>
<p>Instalación:</p>
<pre class="hljs"><code><div>npm install primeng primeicons --save
</div></code></pre>
<p>También vamos a requerir instalar el Angular Animations, algunos controles, como el Menu requieren estas animaciones.</p>
<pre class="hljs"><code><div>npm install @angular/animations --save
</div></code></pre>
<p>Agregamos al <strong>Angular.json</strong> los siguientes estilos</p>
<pre class="hljs"><code><div><span class="hljs-string">"styles"</span>: [
    <span class="hljs-string">"src/styles.css"</span>,
    <span class="hljs-string">"node_modules/primeng/resources/themes/lara-light-indigo/theme.css"</span>,
    <span class="hljs-string">"node_modules/primeng/resources/primeng.min.css"</span>,
    <span class="hljs-string">"node_modules/primeicons/primeicons.css"</span>
],
</div></code></pre>
<p><strong>NOTA</strong>: Podemos cambiar el theme, en lugar de lara-light-indigo podemos ubicar otro theme en el directorio y aplicarlo.</p>
<p><strong>NOTA</strong> También podemos incluir los archivos en Assets para cambiarlos de forma dinámica. En el caso de agregarlos al <strong>angular.json</strong> debemos construir la APP.</p>
<p>Probaremos un botón, en el <strong>app.module.ts</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { ButtonModule }  <span class="hljs-keyword">from</span> <span class="hljs-string">'primeng/button'</span>;
</div></code></pre>
<p>y lo colocamos en la seccón <strong>imports:</strong> del mismo archivo, luego en el template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-button</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"Submit"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p-button</span>&gt;</span>
</div></code></pre>
<p>También podemos usar algunos iconos</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-button</span> <span class="hljs-attr">icon</span>=<span class="hljs-string">"pi pi-check"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p-button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p-button</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"Submit"</span> <span class="hljs-attr">icon</span>=<span class="hljs-string">"pi pi-check"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p-button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p-button</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"Submit"</span> <span class="hljs-attr">icon</span>=<span class="hljs-string">"pi pi-check"</span> <span class="hljs-attr">iconPos</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p-button</span>&gt;</span>
</div></code></pre>
<p>Conultar el sitio <a href="https://primeng.org/button">https://primeng.org/button</a> para obtener más información sobre como implementar los botones.</p>
<h2 id="m%C3%B3dulo-personalizado-primeng">Módulo personalizado primeNg</h2>
<p>Dado que estaremos importando muchos módulos de PrimeNg, una idea es crear un módulo personalizado y agregar los imports de primeNg en un solo lugar, esto es una idea, pueden existir otras implementaciones:</p>
<pre class="hljs"><code><div>[fcruz@fedora 04-pipesApp]$ ng g m primeNg
CREATE src/app/prime-ng/prime-ng.module.ts (193 bytes)
</div></code></pre>
<p>El inconveniente es que centralizamos la carga de todos los módulos en un solo archivo, y los más seguro es que muchos componentes usaran unos cuantos módulos nada mas.</p>
<h2 id="agregando-menu">Agregando Menu</h2>
<p>Antes crearemos la estructura básica de nuestra APP, por el momento agregamos el módulo Shared,</p>
<pre class="hljs"><code><div>ng g m shared/shared
CREATE src/app/shared/shared.module.ts (192 bytes)
</div></code></pre>
<p>Verificamo que el sharedModule este importado en el App.module.ts</p>
<p>Luego, dentro de la carpeta shared creamos la carpeta <strong>components</strong> y agregamos el componente Menu</p>
<pre class="hljs"><code><div>[fcruz@fedora 04-pipesApp]$ ng g c shared/components/menu
CREATE src/app/shared/components/menu/menu.component.css (0 bytes)
CREATE src/app/shared/components/menu/menu.component.html (19 bytes)
CREATE src/app/shared/components/menu/menu.component.spec.ts (587 bytes)
CREATE src/app/shared/components/menu/menu.component.ts (191 bytes)

</div></code></pre>
<p>Dado que usaremos el menú, importamos el <strong>SharedModule</strong> en el <strong>app.module.ts</strong></p>
<p>Vamos ahora al template del menu:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-menu</span> [<span class="hljs-attr">model</span>]=<span class="hljs-string">"items"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p-menu</span>&gt;</span>
</div></code></pre>
<p>En el código del Menu Component agregamos:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, OnInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { MenuItem } <span class="hljs-keyword">from</span> <span class="hljs-string">'primeng/api'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'shared-menu'</span>,
  templateUrl: <span class="hljs-string">'./menu.component.html'</span>,
  styleUrl: <span class="hljs-string">'./menu.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MenuComponent <span class="hljs-keyword">implements</span> OnInit{
  
  <span class="hljs-keyword">public</span> items: MenuItem[] = [];

  ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.items = [
      {label: <span class="hljs-string">'Home'</span>, icon: <span class="hljs-string">'pi pi-fw pi-home'</span>},
      {label: <span class="hljs-string">'Products'</span>, icon: <span class="hljs-string">'pi pi-fw pi-shopping-cart'</span>},
      {label: <span class="hljs-string">'About'</span>, icon: <span class="hljs-string">'pi pi-fw pi-info-circle'</span>},
    ]
  }
}
</div></code></pre>
<p>Esto mostrará la página en blanco con un error:</p>
<pre class="hljs"><code><div>RROR Error: NG05105: Unexpected synthetic listener @overlayAnimation.start found. Please make sure that:
  - Either `BrowserAnimationsModule` or `NoopAnimationsModule` are imported in your application.
</div></code></pre>
<p>Básicamente el componente de Menu de PrimeNg requiere un módulo de animación, ya sea el BrowserAnimationsModule o el NoopAnimationsModule. Al inicio de la sección hemos instalado el <strong>BrowserAnimationsModule</strong> de <strong>@Angular</strong> así que vamos a usarlo, primero debemos importarlo en el <strong>app.module.ts</strong> y luego lo agregamos a la sección <strong>imports</strong> del mismo arhivo:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { BrowserAnimationsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/platform-browser/animations'</span>;

<span class="hljs-meta">@NgModule</span>({
  imports: [
    BrowserAnimationsModule,
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppModule { }
</div></code></pre>
<p>Con este cambio, el error desaparece y el menú se muestra en la pantalla:</p>
<br/>
<img src="./imagenes/pipesApp01.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<p>Dado que ocupamos un menu horizontal, en el header de la aPP, vamos a cambiar el <strong>menu</strong> por el <strong>menubar</strong></p>
<ol>
<li>En el <strong>PrimeNgModule</strong> importamos el menubar, y lo agregamos al <strong>Exports[]</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { MenubarModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'primeng/menubar'</span>;

<span class="hljs-meta">@NgModule</span>({
  declarations: [],
  imports: [],
  exports: [
    MenubarModule,
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> PrimeNgModule { }
</div></code></pre>
<ol start="2">
<li>En nuestro <strong>MenuComponent</strong> creamos un menú con más opciones:</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">this</span>.items = [
      {
        label: <span class="hljs-string">'Pipes de Angular'</span>, 
        icon: <span class="hljs-string">'pi pi-desktop'</span>,
        items: [
          {
            label: <span class="hljs-string">'Textos y Fechas'</span>,
            icon: <span class="hljs-string">'pi pi-align-left'</span>,
            routerLink: <span class="hljs-string">'/'</span>
          },
          {
            label: <span class="hljs-string">'Numeros'</span>,
            icon: <span class="hljs-string">'pi pi-dollar'</span>,
            routerLink: <span class="hljs-string">'numeros'</span>
          },
          {
            label: <span class="hljs-string">'No comunes'</span>,
            icon: <span class="hljs-string">'pi pi-globe'</span>,
            routerLink: <span class="hljs-string">'no-comunes'</span>
          }
        ]
      },{
        label: <span class="hljs-string">'Pipes personalizados'</span>, 
        icon: <span class="hljs-string">'pi pi-cog'</span>,
        routerLink: <span class="hljs-string">'ordenar'</span>
      }
     
    ]
  }
</div></code></pre>
<ol start="3">
<li>Cambiamos el template</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-menubar</span> [<span class="hljs-attr">model</span>]=<span class="hljs-string">"items"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./favicon.ico"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p-menubar</span>&gt;</span>
</div></code></pre>
<p>Verificamos el resultado:</p>
<br/>
<img src="./imagenes/pipesApp02.png" alt="Country APP" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<h2 id="m%C3%B3dulos-y-rutas-de-la-applicaci%C3%B3n">Módulos y Rutas de la Applicación</h2>
<p>Crearemos un módulo para relizar la carga perezosa,</p>
<pre class="hljs"><code><div>[fcruz@fedora 04-pipesApp]$ ng g m products --routing
CREATE src/app/products/products-routing.module.ts (251 bytes)
CREATE src/app/products/products.module.ts (288 bytes)
</div></code></pre>
<p><strong>--routing</strong> En Angular, un &quot;routing module&quot; es un módulo especializado que se utiliza para gestionar la navegación y la configuración de las rutas en una aplicación. Este módulo se encarga de definir las rutas y las asociaciones entre las URL y los componentes que se deben cargar cuando el usuario navega a una determinada URL.</p>
<p>Dentro del directorio <strong>products</strong> crearemos el directorio <strong>pages</strong> y dentro del mismo agregaremos nuestros componentes</p>
<pre class="hljs"><code><div>ng g c products/pages/basicsPage --skip-tests
ng g c products/pages/numbersPage --skip-tests
ng g c products/pages/uncommonPage --skip-tests
</div></code></pre>
<p>Resultado</p>
<pre class="hljs"><code><div>[fcruz@fedora 04-pipesApp]$ tree src/app/products/pages/
src/app/products/pages/
├── basics-page
│   ├── basics-page.component.css
│   ├── basics-page.component.html
│   └── basics-page.component.ts
├── numbers-page
│   ├── numbers-page.component.css
│   ├── numbers-page.component.html
│   └── numbers-page.component.ts
└── uncommon-page
    ├── uncommon-page.component.css
    ├── uncommon-page.component.html
    └── uncommon-page.component.ts
</div></code></pre>
<p>Ya hemos creado el routingModule de nuestra página de productos, hemos agregado los componentes tipo Page, y ahora necesitamos agregar las rutas para navegar a dichas páginas.</p>
<p>En el <strong>ProductsRoutingModule</strong> (nuestro routing module para productos) agregamos las rutas:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">''</span>,
    component: BasicsPageComponent
  },
  {
    path: <span class="hljs-string">'numbers'</span>,
    component: NumbersPageComponent
  },
  {
    path: <span class="hljs-string">'uncommon'</span>,
    component: UncommonPageComponent
  },
  {
    path: <span class="hljs-string">'**'</span>,
    redirectTo: <span class="hljs-string">''</span>
  }
];
</div></code></pre>
<p>Recordemos que estas son rutas hijas, debemos agregarlas en el mismo <strong>ProductsRoutingModule</strong> como <strong>Childs</strong></p>
<pre class="hljs"><code><div><span class="hljs-meta">@NgModule</span>({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ProductsRoutingModule { }
</div></code></pre>
<p>Ahora vamos a nuestro Router principal, <strong>AppRoutingModule</strong> y hacemos la carga perezosa de nuestro products Module</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">''</span>,
    loadChildren: <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./products/products.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.ProductsModule)
  }
];

<span class="hljs-meta">@NgModule</span>({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppRoutingModule { }
</div></code></pre>
<p>Reordemos esta sintáxis:</p>
<pre class="hljs"><code><div>loadChildren: <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./products/products.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.ProductsModule)
</div></code></pre>
<p><strong>loadChildren</strong>: Es una propiedad de configuración de ruta en Angular. Se utiliza para cargar dinámicamente un módulo cuando se navega a una ruta específica.</p>
<p><strong>() =&gt; import('./products/products.module'):</strong> Aquí se utiliza una función de flecha para definir un punto de entrada dinámico al módulo que se va a cargar. La función import() es una característica de JavaScript llamada &quot;import dinámico&quot;. Este enfoque permite cargar módulos de manera asíncrona, lo que es fundamental para la carga perezosa.</p>
<p><strong>import('./products/products.module')</strong>: Esta parte del código indica que el módulo products.module se cargará de manera dinámica. El camino relativo ('./products/products.module') indica la ubicación del archivo del módulo.</p>
<p><strong>.then(m =&gt; m.ProductsModule):</strong> Después de que el módulo es importado dinámicamente, la función then() se utiliza para especificar lo que debe suceder después de que la importación sea exitosa. En este caso, m representa el módulo importado, y m.ProductsModule es la referencia al módulo de productos que será cargado de forma perezosa.</p>
<h2 id="conectando-el-menubar-con-las-rutas">Conectando el MenuBar con las Rutas.</h2>
<p>Para Links internos, usamos el <strong>routerLink</strong> del <strong>MenuItem</strong> para enlazar a una ruta interna. Si fuese externa podemos usar el <strong>URL</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">this</span>.items = [
      {
        label: <span class="hljs-string">'Pipes de Angular'</span>, 
        icon: <span class="hljs-string">'pi pi-desktop'</span>,
        items: [
          {
            label: <span class="hljs-string">'Textos y Fechas'</span>,
            icon: <span class="hljs-string">'pi pi-align-left'</span>,
            routerLink: <span class="hljs-string">'/'</span>
          },
          {
            label: <span class="hljs-string">'Numeros'</span>,
            icon: <span class="hljs-string">'pi pi-dollar'</span>,
            routerLink: <span class="hljs-string">'numbers'</span>
          },
          {
            label: <span class="hljs-string">'No comunes'</span>,
            icon: <span class="hljs-string">'pi pi-globe'</span>,
            routerLink: <span class="hljs-string">'uncommon'</span>
          }
        ]
      },{
        label: <span class="hljs-string">'Pipes personalizados'</span>, 
        icon: <span class="hljs-string">'pi pi-cog'</span>,
        routerLink: <span class="hljs-string">'ordenar'</span>
      }
     
    ]
</div></code></pre>
<h2 id="construir-basics-page">Construir Basics Page</h2>
<p>Vamos a agregar primeramente una serie de Imports en el <strong>PrimeNgModule</strong> los cuales los usaremos en varios de los componentes que estamos por desarrollar.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { ButtonModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'primeng/button'</span>;
<span class="hljs-keyword">import</span> { CardModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'primeng/card'</span>;
<span class="hljs-keyword">import</span> { FieldsetModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'primeng/fieldset'</span>;
<span class="hljs-keyword">import</span> { MenubarModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'primeng/menubar'</span>;
<span class="hljs-keyword">import</span> { PanelModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'primeng/panel'</span>;


<span class="hljs-meta">@NgModule</span>({
  declarations: [],
  imports: [],
  exports: [
    ButtonModule,
    CardModule,
    FieldsetModule,
    MenubarModule,
    PanelModule
    
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> PrimeNgModule { }
</div></code></pre>
<p>Si queremos agregar algún Module de PrimeNG recien importado, dentro de cualquire página o componente del nuevo módulo <strong>Products</strong> debemos importarlo en dicho módulo, recordemos que cada módulo requeire importar lo que necesita usar.</p>
<p>Entonces agregamos en nuestro <strong>ProductsModule</strong> en la sección de imports el <strong>PrimeNgModule</strong></p>
<p>Y luego iniciemos con la construcción del Compomente, agregemos una propiedad pública en el código del compomente <strong>BasicsPageComponent</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> BasicsPageComponent {

  <span class="hljs-keyword">public</span> name: <span class="hljs-built_in">string</span> = <span class="hljs-string">'fReddY cRuz'</span>
}
</div></code></pre>
<p>Y agregemos esto en el template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-panel</span> [<span class="hljs-attr">toggleable</span>]=<span class="hljs-string">"true"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p-header</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Basics Angular Pipes<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">p-header</span>&gt;</span>
   
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
        Basics Angular Pipes, included in CommonModule.
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
        Consider having the following public property in your component:
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">code</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"white-space: nowrap;"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: blue;"</span>&gt;</span>public<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #333;"</span>&gt;</span> name<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: #333;"</span>&gt;</span>: string = <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: green;"</span>&gt;</span>'fReddY cRuz'<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-12 md:col-4"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p-card</span> <span class="hljs-attr">header</span>=<span class="hljs-string">"Uppercase"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ name | uppercase }}" }} produces {{ name | uppercase }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span> 
            <span class="hljs-tag">&lt;/<span class="hljs-name">p-card</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-12 md:col-4"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p-card</span> <span class="hljs-attr">header</span>=<span class="hljs-string">"Lowecase"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ name | lowercase }}" }} produces {{ name | lowercase }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">p-card</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-12 md:col-4"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">p-card</span> <span class="hljs-attr">header</span>=<span class="hljs-string">"TitleCase"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ name | titlecase }}" }} produces {{ name | titlecase }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">p-card</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p-panel</span>&gt;</span>


</div></code></pre>
<h2 id="primeflex">PrimeFlex</h2>
<p><strong>PrimeFlex</strong> es una biblioteca de utilidades CSS que presenta varios helpers, como un sistema de cuadrícula, flexbox, espaciado, elevación y más. Las clases que agregamos al template anterior no tienen efecto aún, necesitamos instalar el PrimeFlex</p>
<pre class="hljs"><code><div>npm install primeflex --save
</div></code></pre>
<p>Y luego agregamos el estilo en el <strong>Angular.json</strong></p>
<pre class="hljs"><code><div><span class="hljs-string">"styles"</span>: [
  <span class="hljs-string">"src/styles.css"</span>,
  <span class="hljs-string">"node_modules/primeng/resources/themes/lara-light-indigo/theme.css"</span>,
  <span class="hljs-string">"node_modules/primeng/resources/primeng.min.css"</span>,
  <span class="hljs-string">"node_modules/primeicons/primeicons.css"</span>,
  <span class="hljs-string">"node_modules/primeflex/primeflex.css"</span>
],
</div></code></pre>
<p>Con eso cambios se genera esta vista:</p>
<br/>
<img src="./imagenes/pipesApp03.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<p>Agregar este otro Card</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-12 md:col-6"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p-card</span> <span class="hljs-attr">header</span>=<span class="hljs-string">"Date"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ customDate | date }}" }} produces {{ customDate | date }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ customDate | date:'short' }}" }} produces {{ customDate | date: 'short' }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ customDate | date:'medium' }}" }} produces {{ customDate | date: 'medium' }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ customDate | date:'long' }}" }} produces {{ customDate | date: 'long' }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ customDate | date:'full' }}" }} produces {{ customDate | date: 'full' }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ customDate | date:'shortDate' }}" }} produces {{ customDate | date: 'shortDate' }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ customDate | date:'mediumDate' }}" }} produces {{ customDate | date: 'mediumDate' }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ customDate | date:'shortTime' }}" }} produces {{ customDate | date: 'shortTime' }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">p-card</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Produce esta salida:</p>
<br/>
<img src="./imagenes/pipesApp04.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<h2 id="configuraci%C3%B3n-del-locale">Configuración del Locale</h2>
<p>Para usar el PIPE Date con Locale, es necesario agregar un par de configuraciones, necesitamos importar el Locale que nuestra app va a usar y luego usar la función <strong>registerLocaleData</strong> para registrarlo.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> localEsNI <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common/locales/es-NI'</span>;
<span class="hljs-keyword">import</span> { registerLocaleData } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/common'</span>;

registerLocaleData(localEsNI);

<span class="hljs-meta">@NgModule</span>({})
</div></code></pre>
<p>Ahora ya podemos usar el Locale ES-Ni en nuestra app.</p>
<pre class="hljs"><code><div>{{ customDate | date: 'full':'':'es-NI' }} produces lunes, 1 de enero de 2024, 17:04:54 GMT-06:00
</div></code></pre>
<h2 id="definir-globalmente-el-locale">Definir globalmente el Locale</h2>
<p>Podemos definir un Locale de forma global, para evitar tener que definirlo en cada lugar, por defecto está configurado el en-US, si queremos cambiarlo por otro, debemos cambiar nuestro app.module.ts,</p>
<p>Debemos mantener los cambios anteriores, es decir importar el Locales y registrarlo, pero para hacerlo que sea el default, debemos agregar un <strong>providers</strong> en el mismo app.module.ts</p>
<pre class="hljs"><code><div>providers: [
    { provide: LOCALE_ID, useValue: <span class="hljs-string">'es-NI'</span> }
  ],
</div></code></pre>
<p>Ahora podemos ver las fechas con el locale es-NI.</p>
<br/>
<img src="./imagenes/pipesApp05.png" alt="Barra Lateral" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<p>NOTA: El LOCALE_ID se importa del <strong>@angular/core</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { LOCALE_ID, NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
</div></code></pre>
<h2 id="pipes-para-n%C3%BAmeros">Pipes para Números</h2>
<p>Creamos un nuevo componente para mostrar la funcionalidad de los Pipes de Números. (Son los mismos pasos y el mismo template, varían únicamente los Pipes a mostrar.)</p>
<p>En el caso de Number, si tenemos esta variable:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> amount: <span class="hljs-built_in">number</span> = <span class="hljs-number">123456.789</span>;
</div></code></pre>
<p>Y aplicamos el pipe <code>number: '1.0-2'</code> obtendremos el valor <code>123,456.79</code></p>
<p>El DecimalPipe se define de esta forma</p>
<pre class="hljs"><code><div>{{ value_expression | number [ : digitsInfo [ : locale ] ] }}
</div></code></pre>
<p><strong>digitsInfo</strong> se define como:</p>
<pre class="hljs"><code><div>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}
</div></code></pre>
<p><strong>minIntegerDigits</strong>: el número mínimo de dígitos enteros antes del punto decimal. El valor predeterminado es 1.</p>
<p><strong>minFractionDigits</strong>: el número mínimo de dígitos después del punto decimal. El valor predeterminado es 0.</p>
<p><strong>maxFractionDigits</strong>: el número máximo de dígitos después del punto decimal. El valor predeterminado es 3.</p>
<p>De modo que <code>'1.0-2'</code> va a generar un número con:</p>
<ul>
<li>Al menos un dígito antes del punto decimal</li>
<li>Un mínimo de 0 decimales</li>
<li>Un máximo de 2 decimales</li>
</ul>
<p>Dado que el número original contiene 3 decimales <code>123456.789</code> el valor transformado será <code>123,456.79</code></p>
<h2 id="pipes-de-moneda">Pipes de Moneda</h2>
<p>Consultar la documentación oficial para obtener más información sobre los parámetros de monedas. Estos son un par de ejemplos:</p>
<pre class="hljs"><code><div>{{ amount | currency: 'NIO' }} produces C$123,456.79
{{ amount | currency: 'EUR': 'symbol-narrow' | currency }} produces €123,456.79
{{ amount | currency: 'USD': 'symbol-narrow': '1.4-4' }} produces $123,456.7890
</div></code></pre>
<p>NOTA: la configuración <code>1.4-4</code> indica, al menos 4 decimales (puede agregar ceros) y máximo 4 decimales (puede aplicar redondeos)</p>
<h2 id="pipe-de-porcentaje">Pipe de Porcentaje</h2>
<p>Definida la siguiente propiedad:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> percent: <span class="hljs-built_in">number</span> = <span class="hljs-number">0.712</span>;
</div></code></pre>
<p>Estos son un par de ejemplos:</p>
<pre class="hljs"><code><div>{{ percent | percent }} produces 71 %
{{ percent | percent: '1.0-2' }} produces 71.2 %
{{ percent | percent: '1.4-4' }} produces 71.2000 %
</div></code></pre>
<h2 id="uncommon-pipes">Uncommon Pipes</h2>
<p>Iniciemos con el <strong>i18nSelect</strong>: Selector genérico que muestra la cadena que coincide con el valor actual. Por ejemplo, si vamos a enviar correos de invitación a personas, podemos cambiar algunos textos dependiendo del género.</p>
<p>Creamos este componente:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, OnInit } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-keyword">type</span> gender = <span class="hljs-string">'male'</span> | <span class="hljs-string">'female'</span>;
<span class="hljs-keyword">export</span>
<span class="hljs-keyword">interface</span> Client {
  name: <span class="hljs-built_in">string</span>;
  gender: gender;
}

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-uncommon-page'</span>,
  templateUrl: <span class="hljs-string">'./uncommon-page.component.html'</span>,
  styleUrl: <span class="hljs-string">'./uncommon-page.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> UncommonPageComponent {

  <span class="hljs-comment">//i18nSelect</span>
  <span class="hljs-keyword">public</span> clients: Client[] = [
    { name: <span class="hljs-string">'Freddy'</span>, gender: <span class="hljs-string">'male'</span>},
    { name: <span class="hljs-string">'Adrea'</span>, gender: <span class="hljs-string">'female'</span>},
    { name: <span class="hljs-string">'Martin'</span>, gender: <span class="hljs-string">'male'</span>},
    { name: <span class="hljs-string">'Ana'</span>, gender: <span class="hljs-string">'female'</span>}
  ];

  <span class="hljs-keyword">public</span> selectedClient: Client = <span class="hljs-keyword">this</span>.clients[<span class="hljs-number">0</span>];

  <span class="hljs-keyword">public</span> changeClient(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.selectedClient = <span class="hljs-keyword">this</span>.clients[<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-keyword">this</span>.clients.length)];
  }
}
</div></code></pre>
<p>En resumen un arreglo de Clientes (nombre y género), un método que cambia aleatoriamente el cliente seleccionado.</p>
<p>Ahora veamos el Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-fieldset</span> <span class="hljs-attr">legend</span>=<span class="hljs-string">"i18nSelect Pipe"</span> [<span class="hljs-attr">toggleable</span>]=<span class="hljs-string">"true"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
      Saludos {{selectedClient.name}} es un placer invitarlo
      a nuestro evento anual de programadores.
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">p-button</span> (<span class="hljs-attr">onClick</span>)=<span class="hljs-string">"changeClient()"</span> <span class="hljs-attr">label</span>=<span class="hljs-string">"Change Client"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">p-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p-fieldset</span>&gt;</span>
</div></code></pre>
<p>Veamos algunas salidas:</p>
<br/>
<img src="./imagenes/pipesApp06.png" alt="Barra Lateral" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<br/>
<img src="./imagenes/pipesApp07.png" alt="Barra Lateral" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<p>Como podemos ver, en la segunda imagen, el nombre &quot;Andrea&quot; no se corresponde con &quot;Invitarlo&quot;, podríamos agregar un <strong>ngIf</strong> que valide el género e imprima <strong>Invitarla</strong> pero para eso tenemos el pipe <strong>i18nSelect</strong></p>
<p>Agreguemos un MAP, el *<em>invitationMap</em> que tiene el género como Key, y la palabra a cambiar como el Value.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> invitationMap = {
    male: <span class="hljs-string">'invitarlo'</span>,
    female: <span class="hljs-string">'invitarla'</span>
  };
</div></code></pre>
<p>y cambiemos nuestro template por:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
  Saludos {{selectedClient.name}} es un placer 
  {{ selectedClient.gender | i18nSelect: invitationMap }}
  a nuestro evento anual de programadores.
<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</div></code></pre>
<p>El resultado:
P
<br/>
<img src="./imagenes/pipesApp08.png" alt="Barra Lateral" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" /></p>
<h2 id="i18nplural-pipe">i18nPlural Pipe</h2>
<p>Creamos el siguiente template,</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-fieldset</span> <span class="hljs-attr">legend</span>=<span class="hljs-string">"i18nPlural Pipe"</span> [<span class="hljs-attr">toggleable</span>]=<span class="hljs-string">"true"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
    Actualmente tenemos {{clients.length}} clientes esperando. 
  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p-button</span>
    (<span class="hljs-attr">onClick</span>)=<span class="hljs-string">"deleteClient()"</span>
    <span class="hljs-attr">label</span>=<span class="hljs-string">"Delete Client"</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">p-button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p-fieldset</span>&gt;</span>
</div></code></pre>
<p>El método <strong>deleteClient()</strong> simplemente elimina un cliente de la lista, si ejecutamos varias veces el eliminar hasta dejar un solo cliente en el arreglo, se leerá:</p>
<pre class="hljs"><code><div>Actualmente tenemos 1 clientes esperando.
</div></code></pre>
<p>Al igual que el <strong>i18nSelect</strong>, podemos proporcionar un Mapa y usar el pipe <strong>i18nPlural</strong></p>
<p>Creamos el mapa:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> totalClientsMap = {
    <span class="hljs-string">'=0'</span>: <span class="hljs-string">'no tenemos ningún cliente esperando.'</span>,
    <span class="hljs-string">'=1'</span>: <span class="hljs-string">'tenemos un cliente esperando.'</span>,
    <span class="hljs-string">'other'</span>: <span class="hljs-string">'tenemos # clientes esperando.'</span>
  };
</div></code></pre>
<p>Cambiamos nuestro Template a esto:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
  Actualmente {{clients.length | i18nPlural: totalClientsMap}}
<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</div></code></pre>
<p>Esto genera las siguientes salidas:</p>
<pre class="hljs"><code><div>Actualmente tenemos 4 clientes esperando.
Actualmente tenemos 3 clientes esperando.
Actualmente tenemos 2 clientes esperando.
Actualmente tenemos un cliente esperando.
Actualmente no tenemos ningún cliente esperando.
</div></code></pre>
<h2 id="slice-pipe">Slice Pipe</h2>
<p>El <strong>SlicePipe</strong> Crea un nuevo Array o cadena que contiene un subconjunto (porción) de los elementos.</p>
<p>Creamos este métdo, crea un arreglo con los nombres de los clientes:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> clientNames(): <span class="hljs-built_in">string</span>[] {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.clients.map(<span class="hljs-function"><span class="hljs-params">client</span> =&gt;</span> client.name);
  }
</div></code></pre>
<p>El siguiente Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-fieldset</span> <span class="hljs-attr">legend</span>=<span class="hljs-string">"Slice Pipe"</span> [<span class="hljs-attr">toggleable</span>]=<span class="hljs-string">"true"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Originals<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span> {{ clientNames() }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>Slice:0:1<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span> {{ clientNames() | slice:0:1 }}<span class="hljs-tag">&lt;
    &lt;<span class="hljs-attr">b</span>&gt;</span>Slice:1:1<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span> {{ clientNames() | slice:1:2 }}<span class="hljs-tag">&lt;
    &lt;<span class="hljs-attr">b</span>&gt;</span>Slice:2:3<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span> {{ clientNames() | slice:2:3 }}<span class="hljs-tag">&lt;
    &lt;<span class="hljs-attr">b</span>&gt;</span>Slice:3<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span> {{ clientNames() | slice:3 }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p-fieldset</span>&gt;</span>
</div></code></pre>
<p>Genera:</p>
<pre class="hljs"><code><div>Originals
 Freddy,Adrea,Martin,Ana
Slice:0:1
 Freddy
Slice:1:1
 Adrea
Slice:2:3
 Martin
Slice:3
 Ana
</div></code></pre>
<h2 id="json-pipe">Json Pipe</h2>
<p>El siguiente template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-fieldset</span> <span class="hljs-attr">legend</span>=<span class="hljs-string">"Json Pipe"</span> [<span class="hljs-attr">toggleable</span>]=<span class="hljs-string">"true"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span> {{ clients | json }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p-fieldset</span>&gt;</span> 
</div></code></pre>
<p>Genera el contenido del arreglo de objetos Clients en formato JSON:</p>
<pre class="hljs"><code><div> [
  {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Freddy"</span>,
    <span class="hljs-attr">"gender"</span>: <span class="hljs-string">"male"</span>
  },
  {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Adrea"</span>,
    <span class="hljs-attr">"gender"</span>: <span class="hljs-string">"female"</span>
  },
  {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Martin"</span>,
    <span class="hljs-attr">"gender"</span>: <span class="hljs-string">"male"</span>
  },
  {
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Ana"</span>,
    <span class="hljs-attr">"gender"</span>: <span class="hljs-string">"female"</span>
  }
]
</div></code></pre>
<h2 id="key-value-pipe">Key-Value Pipe</h2>
<p>El keyValue permite transformar un Objeto tipo Mapa, Key - Value, en interable. Por ejemplo</p>
<pre class="hljs"><code><div>&lt;p-fieldset legend=<span class="hljs-string">"KeyValue Pipe"</span> [toggleable]=<span class="hljs-string">"true"</span>&gt;
    &lt;ul *ngFor=<span class="hljs-string">"let client of clients[0] | keyvalue"</span>&gt;
        &lt;li&gt;
            {{client | json }}
        &lt;<span class="hljs-regexp">/li&gt;
    &lt;/u</span>l&gt;
&lt;<span class="hljs-regexp">/p-fieldset&gt; 
</span></div></code></pre>
<p>Dato que <strong>clients[0]</strong> retorna un objeto de tipo client</p>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> Client {
  name: <span class="hljs-built_in">string</span>;
  gender: gender;
}
</div></code></pre>
<p>Este no es iterable, si omitimos el <strong>keyvalue</strong> obtenemos un error:</p>
<pre class="hljs"><code><div>Type 'Client' is not assignable to type 'NgIterable&lt;any&gt;
</div></code></pre>
<p>En resumen, <strong>keyvalue</strong> transforma Objeto o Mapa en un arreglo de pares Key-Value.</p>
<p>La salida del Template es:</p>
<pre class="hljs"><code><div>{ "key": "gender", "value": "male" }
{ "key": "name", "value": "Freddy" }
</div></code></pre>
<h2 id="async-pipe">Async Pipe</h2>
<p>DEfinamos un Observable en el componente</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> myObservableTimer = interval(<span class="hljs-number">1000</span>);
</div></code></pre>
<p>Cada 1 segundo, emitirá un evento.</p>
<p>Si colocamos esto en el Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-fieldset</span> <span class="hljs-attr">legend</span>=<span class="hljs-string">"Async Pipe"</span> [<span class="hljs-attr">toggleable</span>]=<span class="hljs-string">"true"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>{{ myObservableTimer }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p-fieldset</span>&gt;</span>  
</div></code></pre>
<p>No se emite ningún resultado, esto se debe a que no nos hemos suscrito al observable, si agregamos el pipe async</p>
<pre class="hljs"><code><div>&lt;pre&gt;{{ myObservableTimer | <span class="hljs-keyword">async</span> }}&lt;<span class="hljs-regexp">/pre&gt;
</span></div></code></pre>
<p>Observaremos que cada 1 segundo se imprimer un valor,  0,1,2,... esto se debe a que <strong>async</strong> automáticamente se suscribe al OBservable y recibe los eventos.</p>
<p>Además, si navegamos a otra página, y si colocamos un console.log con el valor emitido por el observable, veremos que la app deja de recibir los eventos, esto signidica que <strong>async</strong> no solamente se suscribe, sino, que también elimia la suscripcón una vez se destruye el componente.</p>
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-pipes-personalizados">Nueva sección: Pipes Personalizados</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>Este es un breve listado de los temas fundamentales:</p>
<ul>
<li>Pipes personalizados</li>
<li>Argumentos hacia los Pipes</li>
<li>SortableTable manual y usando PrimeNg</li>
</ul>
<h2 id="creando-un-custom-pipe-toggle-case">Creando un Custom Pipe: Toggle-Case</h2>
<p>Vamos a crear un módulo para tener nuestros customs Pipes en un lugar independiente</p>
<pre class="hljs"><code><div>[fcruz@fedora 04-pipesApp]$ ng g m custom-pipes
CREATE src/app/custom-pipes/custom-pipes.module.ts
</div></code></pre>
<p>Procedemos a crear el Custom Pipe</p>
<pre class="hljs"><code><div>[fcruz@fedora 04-pipesApp]$ ng g p custom-pipes/toggle-case/toggle-case
CREATE src/app/custom-pipes/toggle-case/toggle-case.pipe.spec.ts (204 bytes)
CREATE src/app/custom-pipes/toggle-case/toggle-case.pipe.ts (225 bytes)
UPDATE src/app/custom-pipes/custom-pipes.module.ts (284 bytes)
</div></code></pre>
<p>Analicemos el código autogenerado</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Pipe, PipeTransform } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Pipe</span>({
  name: <span class="hljs-string">'toggleCase'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ToggleCasePipe <span class="hljs-keyword">implements</span> PipeTransform {

  transform(value: unknown, ...args: unknown[]): unknown {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }

}
</div></code></pre>
<p>Nuevamente observamos una simple clase con una anotación y una que otra implementación.</p>
<p>La Clase <strong>ToggleCasePipe</strong> tiene una anotación <strong>@Pipe</strong> que recibe como argumento requerido el <strong>name</strong> del pipe. Además esta misma clase implementa el <strong>PipeTransform</strong> y por lo tanto debe de implementar el método <strong>transform</strong></p>
<p>Dicho método acepta un parámetro <strong>value</strong> que es el valor que se desea transformar. Además acepta ninguno o varios parámetros adicionales <strong>args</strong></p>
<p>Podemos implementar un CustomPipe Simple que cambie una Cadena de Minúsculas a Mayúsculas o lo contrario. Ese es el objetivo de nuestro Pipe.</p>
<p>Podemos cambiar el tipo del <strong>value</strong> porque solo aceptaremos un <strong>string</strong> y podemos remover los <strong>args</strong> porque no vamos a ocupar parámetros adicionales.</p>
<p>Definamos nuestro transform de la siguiente forma:</p>
<pre class="hljs"><code><div>transform(value: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">if</span> (!value || <span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">'string'</span> || value.length === <span class="hljs-number">0</span> ) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;
    }

    <span class="hljs-keyword">if</span> (value === value.toUpperCase()) {
      <span class="hljs-keyword">return</span> value.toLowerCase();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> value.toUpperCase();
    }
  }
</div></code></pre>
<p>Si el valor recibido no está definido, o no es un string o es un string vacío, retornamos un string vacío. El resto del código se explica por si mismo.</p>
<p>Ahora usemos el Custom Pipe, como es un módulo, el componente que dese usarlo, su módulo debe importarlo.</p>
<p>Como deseamos implementarlo en el componente <strong>CustomsPageComponent</strong> y este pertenece al módulo <strong>ProductsModule</strong> este último debe importar el módulo <strong>CustomPipesModule</strong></p>
<p><strong>NOTA: Dado que aún no implementamos los standalone, debemos usar los módulos por el momento.</strong></p>
<p>Una vez importado en el <strong>ProductsModule</strong> ya podemos usarlo en nuestro template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-card</span> <span class="hljs-attr">header</span>=<span class="hljs-string">"My TogleCase"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ 'Testing' | toggleCase }}" }} produces {{ 'Testing' | toggleCase }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ 'TESTING' | toggleCase }}" }} produces {{ 'TESTING' | toggleCase }}<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">p-card</span>&gt;</span>
</div></code></pre>
<br/>
<img src="./imagenes/pipesApp09.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<h2 id="aagumentos-en-custom-pipes">Aagumentos en Custom Pipes</h2>
<p>Creemos un nuevo Pipe, uno que reciba un string, y tres parámetros, el primero un número, y los otros boolean, el primero define el ancho del texto generado, el segundo si el usuario quiere usar números y el tercero si quiere usar caractéres especiales. El objetivo del Pipe es generar un RandomPassword de ancho N con o sin Números y caracteres especiales.</p>
<pre class="hljs"><code><div>{{value_expression | randomPassword [ : lenght [ : useNumer [ : useSpecialCharacter ]]]}}
</div></code></pre>
<p>Creamos el Pipe</p>
<pre class="hljs"><code><div>CREATE src/app/custom-pipes/random-password/random-password.pipe.spec.ts (220 bytes)
CREATE src/app/custom-pipes/random-password/random-password.pipe.ts (233 bytes)
UPDATE src/app/custom-pipes/custom-pipes.module.ts (421 bytes)
</div></code></pre>
<p>Implementamos el código:</p>
<p>NOTA: Colocar un  RandomPasswordGenerator en un Pipe quizás no es la mejor idea, pero solo se hace con propósitos educativos, para indicar como usar los parámetros.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Pipe, PipeTransform } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Pipe</span>({
  name: <span class="hljs-string">'randomPassword'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> RandomPasswordPipe <span class="hljs-keyword">implements</span> PipeTransform {

  <span class="hljs-keyword">private</span> symbols = <span class="hljs-string">"~`!@#$%^&amp;*()/|:;.,+-*"</span>
  <span class="hljs-keyword">private</span> alphabet = <span class="hljs-string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</span>;

  transform(value: <span class="hljs-built_in">string</span>, ...args: unknown[]): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">const</span> [length, allowNumbers, allowSpecial] = args <span class="hljs-keyword">as</span> [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>, <span class="hljs-built_in">boolean</span>];

    <span class="hljs-keyword">let</span> randomNumber = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">if</span> (allowNumbers) {
      randomNumber = <span class="hljs-keyword">this</span>.generateRandomNumber();
    }

    <span class="hljs-keyword">let</span> randomSpecialChars = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">if</span> (allowSpecial) {
      randomSpecialChars = <span class="hljs-keyword">this</span>.generateRandomString(<span class="hljs-built_in">Math</span>.floor(length / <span class="hljs-number">2</span>) , <span class="hljs-keyword">this</span>.symbols);
    }

    <span class="hljs-keyword">let</span> characters: <span class="hljs-built_in">string</span>[] = value.split(<span class="hljs-string">""</span>)
    .concat(randomNumber.split(<span class="hljs-string">""</span>))
    .concat(randomSpecialChars.split(<span class="hljs-string">""</span>));

   
    <span class="hljs-keyword">let</span> refill = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">if</span> (characters.length &lt; length) {
      refill = <span class="hljs-keyword">this</span>.generateRandomString(length - characters.length, <span class="hljs-keyword">this</span>.alphabet);
    }

    characters = characters.concat(refill.split(<span class="hljs-string">""</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.shuffleArray(characters).join(<span class="hljs-string">""</span>).slice(<span class="hljs-number">0</span>,length);
  }

  <span class="hljs-keyword">private</span> generateRandomNumber(): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (<span class="hljs-number">99999</span> - <span class="hljs-number">10000</span> + <span class="hljs-number">1</span>)) + <span class="hljs-number">10000</span>).toString();
  }

  <span class="hljs-keyword">private</span> generateRandomString(length: <span class="hljs-built_in">number</span>, charset: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">let</span> returnString = <span class="hljs-string">''</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
      <span class="hljs-keyword">const</span> indiceAleatorio = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * charset.length);
      returnString += charset.charAt(indiceAleatorio);
    }
    <span class="hljs-keyword">return</span> returnString;
  }

  <span class="hljs-keyword">private</span> shuffleArray(array: <span class="hljs-built_in">string</span>[]): <span class="hljs-built_in">string</span>[] {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = array.length - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) {
        <span class="hljs-keyword">const</span> j = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (i + <span class="hljs-number">1</span>));
        [array[i], array[j]] = [array[j], array[i]];
    }
    <span class="hljs-keyword">return</span> array;
  }
}
</div></code></pre>
<p>Ahora lo implementamos en nuestro template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-card</span> <span class="hljs-attr">header</span>=<span class="hljs-string">"My RandomPassword"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ 'Testing' | randomPassword:15:true:true }}" }} produces '{{ 'Testing' | randomPassword:15:true:true }}'<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ 'BASE' | randomPassword:20:true:false }}" }} produces '{{ 'BASE' | randomPassword:20:true:false }}'<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">pre</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"wrapper"</span>&gt;</span>{{ "{{ 'BASE' | randomPassword:20:false:false }}" }} produces '{{ 'BASE' | randomPassword:20:false:false }}'<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p-card</span>&gt;</span>
</div></code></pre>
<p>La Salida Sería:</p>
<br/>
<img src="./imagenes/pipesApp10.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<h2 id="el-sortby-pipe">El SortBy Pipe</h2>
<p>El siguiente ejemplo simplemente es para demostrar que el PIPE puede ser usado para transformar más que simples datos, podemos aplicarlo para cambiar los datos en un arreglo de objetos. El siguiente pipe ordena datos en una tabla, los datos provienen de un arreglo de productos. Además se implementa un toolbar de PrimeNG para mostrar botones que inician las acciones de ordenamiento, el código completo es el siguiente:</p>
<p>Primero necesitamos una interfaz para los productos.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Product {
    code: <span class="hljs-built_in">string</span>;
    name: <span class="hljs-built_in">string</span>;
    category: <span class="hljs-built_in">string</span>;
    quantity: <span class="hljs-built_in">number</span>;
    discount: <span class="hljs-built_in">boolean</span>;
}
</div></code></pre>
<p>Luego implementamos el código del componente Table.</p>
<pre class="hljs"><code><div>Component({
  selector: <span class="hljs-string">'app-tables-page'</span>,
  templateUrl: <span class="hljs-string">'./tables-page.component.html'</span>,
  styleUrl: <span class="hljs-string">'./tables-page.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> TablesPageComponent {

  <span class="hljs-keyword">public</span> sortBy?: keyof Product | <span class="hljs-string">''</span> = <span class="hljs-string">''</span>;

  <span class="hljs-keyword">public</span> products: Product[] = [{
    code: <span class="hljs-string">'AAA-1111'</span>,
    name: <span class="hljs-string">'PlayStation 5'</span>,
    category: <span class="hljs-string">'Games'</span>,
    quantity: <span class="hljs-number">10</span>,
    discount: <span class="hljs-literal">true</span>
  }]

  <span class="hljs-keyword">public</span> changeSort(sortBy: keyof Product | <span class="hljs-string">''</span>): <span class="hljs-built_in">void</span> {
    <span class="hljs-built_in">console</span>.log(sortBy);
    <span class="hljs-keyword">this</span>.sortBy = sortBy;
  }
}
</div></code></pre>
<p>NOTA: <strong>products</strong> contiene más datos, aca se muestra un solo registro para reducir el código en la documentación.</p>
<p>La propiedad <strong>sortBy</strong> únicamente puede tomar los valores de los KEY del tipo de datos Products, es decir: <strong>code, name, category, quantity y discount</strong> El valor de dicha proiedad es modificado por el método <strong>changeSort</strong></p>
<p>Luego implementamos el PIPE <strong>SortByPipe</strong></p>
<pre class="hljs"><code><div><span class="hljs-meta">@Pipe</span>({
  name: <span class="hljs-string">'sortBy'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SortByPipe <span class="hljs-keyword">implements</span> PipeTransform {

  transform(value: Product[], sortBy?: keyof Product | <span class="hljs-string">''</span>): Product[] {

    <span class="hljs-keyword">if</span> (sortBy === <span class="hljs-string">''</span>)
      <span class="hljs-keyword">return</span> value;

    <span class="hljs-keyword">if</span> (sortBy !== <span class="hljs-literal">undefined</span>)
      <span class="hljs-keyword">return</span> value.sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> (a[sortBy] &gt; b[sortBy]) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>);

    <span class="hljs-keyword">return</span> value;
    
  } 
}
</div></code></pre>
<p>y otro Pipe para transformar el true:false del campo <strong>discount</strong> en algo mas legible</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Pipe</span>({
  name: <span class="hljs-string">'booleanConverter'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> BooleanConverterPipe <span class="hljs-keyword">implements</span> PipeTransform {

  transform(value: <span class="hljs-built_in">boolean</span>, ...args: <span class="hljs-built_in">string</span>[]): <span class="hljs-built_in">string</span> {
    <span class="hljs-keyword">return</span> (value) ? args[<span class="hljs-number">0</span>] : args[<span class="hljs-number">1</span>];
  }
}
</div></code></pre>
<p>Finalmente el Template del Componente que muestra la tabla:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p-panel</span> [<span class="hljs-attr">toggleable</span>]=<span class="hljs-string">"true"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">p-header</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Custom Angular Pipes<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">p-header</span>&gt;</span>
   
    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
        Implementing custom Pipes in a table feature.
    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-name">p-panel</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">p-toolbar</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"p-toolbar-group-start"</span>&gt;</span>

    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"p-toolbar-group-end"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">pButton</span> 
                <span class="hljs-attr">label</span>=<span class="hljs-string">"By Name"</span>
                <span class="hljs-attr">icon</span>=<span class="hljs-string">"pi pi-sort-amount-down"</span>   
                <span class="hljs-attr">class</span>=<span class="hljs-string">"mr-2"</span>
                (<span class="hljs-attr">click</span>) = <span class="hljs-string">"changeSort('name')"</span> &gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">pButton</span> 
                <span class="hljs-attr">label</span>=<span class="hljs-string">"By Category"</span>
                <span class="hljs-attr">icon</span>=<span class="hljs-string">"pi pi-sort-amount-down"</span> 
                <span class="hljs-attr">class</span>=<span class="hljs-string">"p-button-success mr-2"</span>
                (<span class="hljs-attr">click</span>) = <span class="hljs-string">"changeSort('category')"</span> &gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">pButton</span> 
                <span class="hljs-attr">label</span>=<span class="hljs-string">"By Quantity"</span>
                <span class="hljs-attr">icon</span>=<span class="hljs-string">"pi pi-sort-amount-down"</span>    
                <span class="hljs-attr">class</span>=<span class="hljs-string">"p-button-warning mr-2"</span>
                (<span class="hljs-attr">click</span>) = <span class="hljs-string">"changeSort('quantity')"</span> &gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p-toolbar</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col mt-2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p-table</span> [<span class="hljs-attr">value</span>]=<span class="hljs-string">"products | sortBy:sortBy"</span> [<span class="hljs-attr">tableStyle</span>]=<span class="hljs-string">"{ 'min-width': '50rem' }"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> <span class="hljs-attr">pTemplate</span>=<span class="hljs-string">"header"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Code<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Category<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Quantity<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Discount<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">ng-template</span> <span class="hljs-attr">pTemplate</span>=<span class="hljs-string">"body"</span> <span class="hljs-attr">let-product</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{ product.code }}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{ product.name }}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{ product.category }}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{ product.quantity }}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>{{ product.discount | booleanConverter:'discount available':'No'}}<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">ng-template</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">p-table</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>El resultado:</p>
<br/>
<img src="./imagenes/pipesApp11.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<p>Se importaron dos nuevos módulos de primeNG para este componente <strong>TableModule y  ToolbarModule</strong></p>
<p>El <strong>sortBy</strong> pipe se implementa sobre el arreglo productos:</p>
<pre class="hljs"><code><div>[value]=<span class="hljs-string">"products | sortBy:sortBy"</span>
</div></code></pre>
<p>Donde <strong>sortBy</strong> (el parámetro) viene de la propiedad pública definida por el componente y que es modificada por cada botón:</p>
<pre class="hljs"><code><div>(click) = "changeSort('quantity')
</div></code></pre>
<p>Listo, con esto hemos creado un SortBy mediante un Pipe, el cual puede ser extendido, como agregar parámetros ASC / DESC o incluso hacerlo genérico para que ordede otro tipo de arreglos.</p>
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-lazyload-y-layouts">Nueva Sección: LazyLoad y Layouts</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>Este es un breve listado de los temas fundamentales:</p>
<ul>
<li>Rutas Hijas</li>
<li>Rutas Principales</li>
<li>LazyLoad</li>
<li>Multiples estilos en la misma SPA</li>
</ul>
<p>Esta sección es fundamental para seguir el curso, ya que de aquí en adelante, implementaremos la carga perezosa en cada módulo principal de las futuras aplicaciones que haremos.</p>
<p>Comprender el Lazyload no es difícil, y la forma como lo veremos aquí nos ayudará a manejar los dos posibles casos de uso. Uno de ellos es cuando la ruta hija no tiene estilo especial y otra en la que requiere un estilo diferente por cada módulo.</p>
<h2 id="nueva-app">Nueva APP</h2>
<p>Crearemos una nueva APP para mostrar el uso de Componentes Layouts y con especial enfasis en ruteo.</p>
<pre class="hljs"><code><div>ng new herosApp --standalone false
</div></code></pre>
<h2 id="generar-m%C3%B3dulos-iniciales">Generar módulos iniciales</h2>
<pre class="hljs"><code><div>ng g m auth --routing
CREATE src/app/auth/auth-routing.module.ts (247 bytes)
CREATE src/app/auth/auth.module.ts (272 bytes)

ng g m heros --routing
CREATE src/app/heros/heros-routing.module.ts (248 bytes)
CREATE src/app/heros/heros.module.ts (276 bytes)

ng g m shared
CREATE src/app/shared/shared.module.ts (192 bytes)

ng g m material
CREATE src/app/material/material.module.ts (194 bytes)
</div></code></pre>
<p>El módulo <strong>shared</strong> es el único que vamos a importar dentro de <strong>app.module.ts</strong></p>
<p>Todo lo demás se hará con LazyLoad.</p>
<h2 id="creando-componentes">Creando Componentes:</h2>
<p>Agregamos la estructura básica de los compomentes para el módulo <strong>Auth</strong></p>
<pre class="hljs"><code><div>$ ng g c auth/pages/layout-page --skip-tests
$ ng g c auth/pages/login-page --skip-tests
$ ng g c auth/pages/register-page --skip-tests
</div></code></pre>
<p>Creamos los componentes para el módulo <strong>Heros</strong></p>
<pre class="hljs"><code><div>$ ng g c heros/pages/hero-page --skip-tests
$ ng g c heros/pages/layout-page --skip-tests
$ ng g c heros/pages/list-page --skip-tests
$ ng g c heros/pages/new-page --skip-tests
$ ng g c heros/pages/search-page --skip-tests
</div></code></pre>
<p>Creamos los componentes para el módulo <strong>Shared</strong></p>
<pre class="hljs"><code><div>$ ng g c shared/pages/Error404-page --skip-tests
</div></code></pre>
<p>En este caso si vamos a exportar el  <strong>Error404PageComponent</strong> en el módulo <strong>SharedModule</strong> porque vamos a usarlos en una ruta por default en el <strong>app.routing.module.ts</strong></p>
<pre class="hljs"><code><div><span class="hljs-meta">@NgModule</span>({
  declarations: [Error404PageComponent],
  imports: [  CommonModule],
  exports: [Error404PageComponent]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SharedModule { }
</div></code></pre>
<h2 id="material">Material</h2>
<p>En este módulo vamos a importar todo lo referente a Angular Materia, similar a lo que hicimos con PrimeNG, removemos el <strong>CommonModule</strong> de <strong>material.module.ts</strong></p>
<h2 id="estructura-final">Estructura final</h2>
<p>Por el momento esta sería la estructura de nuestro proyecto:</p>
<pre class="hljs"><code><div>[fcruz@fedora app]$ tree
.
├── app.component.css
├── app.component.html
├── app.component.spec.ts
├── app.component.ts
├── app.module.ts
├── app-routing.module.ts
├── auth
│   ├── auth.module.ts
│   ├── auth-routing.module.ts
│   └── pages
│       ├── layout-page
│       │   ├── layout-page.component.css
│       │   ├── layout-page.component.html
│       │   └── layout-page.component.ts
│       ├── login-page
│       │   ├── login-page.component.css
│       │   ├── login-page.component.html
│       │   └── login-page.component.ts
│       └── register-page
│           ├── register-page.component.css
│           ├── register-page.component.html
│           └── register-page.component.ts
├── heros
│   ├── heros.module.ts
│   ├── heros-routing.module.ts
│   └── pages
│       ├── hero-page
│       │   ├── hero-page.component.css
│       │   ├── hero-page.component.html
│       │   └── hero-page.component.ts
│       ├── layout-page
│       │   ├── layout-page.component.css
│       │   ├── layout-page.component.html
│       │   └── layout-page.component.ts
│       ├── list-page
│       │   ├── list-page.component.css
│       │   ├── list-page.component.html
│       │   └── list-page.component.ts
│       ├── new-page
│       │   ├── new-page.component.css
│       │   ├── new-page.component.html
│       │   └── new-page.component.ts
│       └── search-page
│           ├── search-page.component.css
│           ├── search-page.component.html
│           └── search-page.component.ts
├── material
│   └── material.module.ts
└── shared
    ├── pages
    │   └── error404-page
    │       ├── error404-page.component.css
    │       ├── error404-page.component.html
    │       └── error404-page.component.ts
    └── shared.module.ts
</div></code></pre>
<h2 id="configuraci%C3%B3n-de-rutas">Configuración de Rutas</h2>
<p>Iniciamos con la configuración de las rutas, primeramente nos vamos al <strong>AuthRoutingModule</strong>.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// localhost:4200/auth</span>
<span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">''</span>,
    component: LayoutPageComponent, 
  }
];

<span class="hljs-meta">@NgModule</span>({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AuthRoutingModule { }
</div></code></pre>
<p>Y luego en el de <strong>HerosRoutingModule</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// localhost:4200/heros</span>
<span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">''</span>,
    component: LayoutPageComponent,
  }
];

<span class="hljs-meta">@NgModule</span>({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HerosRoutingModule { }
</div></code></pre>
<p>NOTA: cada <strong>LayoutPageComponent</strong> corresponde al propio de cada módulo.</p>
<p>Luego definimos la rutas principales, en el <strong>AppRoutingModule</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">//localhost:4200</span>
<span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">'auth'</span>,
    loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./auth/auth.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.AuthModule),
  },
  {
    path: <span class="hljs-string">'heros'</span>,
    loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./heros/heros.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.HerosModule),
  },
  {
    path: <span class="hljs-string">'404'</span>,
    component: Error404PageComponent,
  },
  {
    path: <span class="hljs-string">''</span>,
    redirectTo: <span class="hljs-string">'heros'</span>,
    pathMatch: <span class="hljs-string">'full'</span>,
  },
  {
    path: <span class="hljs-string">'**'</span>,
    redirectTo: <span class="hljs-string">'404'</span>,
   }
];

<span class="hljs-meta">@NgModule</span>({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AppRoutingModule { }
</div></code></pre>
<p><strong>auth</strong> y <strong>heros</strong> son cargado de modo Lazy.</p>
<p>Por el momento tenemos creadas ciertas Rutas las cuales responden a estas URL:</p>
<pre class="hljs"><code><div>http://localhost:4200/
http://localhost:4200/auth 
http://localhost:4200/heros 
http://localhost:4200/404 
</div></code></pre>
<p>Aún debemos configurar las rutas internas, las que responden por ejemplo a <strong>auth/login</strong></p>
<h2 id="rutas-children">Rutas Children</h2>
<p>El módulo <strong>AuthRoutingModule</strong> actualmente tiene configurada la ruta padre <em>localhost:4200/auth</em> podemos agregar las rutas hijas con el arreglo <strong>children</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// localhost:4200/auth</span>
<span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">''</span>,
    component: LayoutPageComponent, 
    children: [
      <span class="hljs-comment">// localhost:4200/auth/login</span>
      {
        path: <span class="hljs-string">'login'</span>, component: LoginPageComponent
      },
      <span class="hljs-comment">// localhost:4200/auth/register</span>
      {
        path: <span class="hljs-string">'register'</span>, component: RegisterPageComponent
      },
      {
        path: <span class="hljs-string">'**'</span>, redirectTo: <span class="hljs-string">'login'</span>,
      }
    ]
  }
];

<span class="hljs-meta">@NgModule</span>({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AuthRoutingModule { }
</div></code></pre>
<p>También aplicamos el mismo cambio en el módulo <strong>HerosRoutingModule</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">// localhost:4200/heros</span>
<span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">''</span>,
    component: LayoutPageComponent,
    children: [
      <span class="hljs-comment">// localhost:4200/heros/list</span>
      { path: <span class="hljs-string">'list'</span>, component: ListPageComponent },
      <span class="hljs-comment">// localhost:4200/heros/create</span>
      { path: <span class="hljs-string">'create'</span>, component: NewPageComponent },
      <span class="hljs-comment">// localhost:4200/heros/edit/1</span>
      { path: <span class="hljs-string">'edit/:id'</span>, component: NewPageComponent},
      <span class="hljs-comment">// localhost:4200/heros/search</span>
      { path: <span class="hljs-string">'search/'</span>, component: SearchPageComponent },
      <span class="hljs-comment">// localhost:4200/heros/1</span>
      { path: <span class="hljs-string">':id'</span>, component: HeroPageComponent },      
      { path: <span class="hljs-string">'**'</span>, redirectTo: <span class="hljs-string">'list'</span> }
    ]
  }
];

<span class="hljs-meta">@NgModule</span>({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HerosRoutingModule { }
</div></code></pre>
<p>NOTA: Es importante el orden de los paths, vemos que el último corresponde a <strong>:id</strong>, si colocamos este path de primero en la lista, cualquier otro path va a cohincidir con este, de modo que se coloca al final.</p>
<p>Con estos cambios, ya tenemos las rutas listas:</p>
<pre class="hljs"><code><div>// Parents

http://localhost:4200/
http://localhost:4200/auth 
http://localhost:4200/heros 
http://localhost:4200/404 

// Nuevos 

// Auth
http://localhost:4200/auth/login
http://localhost:4200/auth/register

// Heros
http://localhost:4200/heros/list
http://localhost:4200/heros/create
http://localhost:4200/heros/edit/1
http://localhost:4200/heros/search
http://localhost:4200/heros/1
</div></code></pre>
<h2 id="router-outlet">Router Outlet</h2>
<p>Con estas rutas, si cargamos cualquier ruta hija, por ejemplo: <em>http://localhost:4200/auth/login</em> vemos unicamente el <strong>Layout-page works!</strong> Esto corresponde al <strong>LayoutPageComponent</strong> del <strong>AuthModule</strong>, pero, ¿Cómo mostramos la página o componente hijo? usaremos nuevamente el <strong>router-outlet</strong></p>
<p>Agregamos esto al template de cada <strong>LayoutPageComponent</strong> tanto del Auth como del Heros</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
</div></code></pre>
<p>Ahora si cargamos el mismo URL <em>http://localhost:4200/auth/login</em> Vemos:</p>
<pre class="hljs"><code><div>layout-page works!

login-page works!
</div></code></pre>
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-continuaci%C3%B3n-de-heros-app--con-angular-material">Nueva Sección: Continuación de Heros APP / Con Angular Material:</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>Este es un breve listado de los temas fundamentales:</p>
<ul>
<li>Angular Material</li>
<li>Interfaces y tipado</li>
<li>Pipes personalizados</li>
<li>Variables de entorno</li>
<li>Autocomplete de AngularMaterial</li>
<li>Peticiones HTTP</li>
<li>JSON-Server</li>
<li>Prime Flex</li>
</ul>
<p>Esta sección tiene por objetivo principal aprender a utilizar Angular Material, es la primera de varias secciones donde lo usaremos. Al final del día trabajaremos con muchos componentes de Angular material que les ayudará a ver cualquier otro tipo de paquete modularizado de la misma manera y ustedes sabrán aplicarlo.</p>
<p>En la siguiente sección después de esta, continuaremos la aplicación pero realizaremos un CRUD.</p>
<h2 id="instalaci%C3%B3n-de-material">Instalación de Material</h2>
<p>Vamos a usar dos cosas</p>
<ul>
<li>Angular Material</li>
<li>PrimeFlex</li>
</ul>
<p>De Angular Materials vamos a usar sus componentes y de PrimerFlex algunos estilos.</p>
<pre class="hljs"><code><div>$ ng add @angular/material
</div></code></pre>
<p>Salida del Comando:</p>
<pre class="hljs"><code><div>ℹ Using package manager: npm
✔ Found compatible package version: @angular/material@17.0.4.
✔ Package information loaded.

The package @angular/material@17.0.4 will be installed and executed.
Would you like to proceed? Yes
✔ Packages successfully installed.
? Choose a prebuilt theme name, or &quot;custom&quot; for a custom theme: Indigo/Pink
[ Preview: https://material.angular.io?theme=indigo-pink ]
? Set up global Angular Material typography styles? Yes
? Include the Angular animations module? Include and enable animations
UPDATE package.json (1112 bytes)
✔ Packages installed successfully.
UPDATE src/app/app.module.ts (576 bytes)
UPDATE angular.json (3005 bytes)
UPDATE src/index.html (519 bytes)
UPDATE src/styles.css (181 bytes)
[fcruz@fedora 05-herosApp]$ 
</div></code></pre>
<p>En <strong>src/app/app.module.ts</strong> se importa el <strong>BrowserAnimationsModule</strong> porque hemos habilitado las animaciones, también se agregan unas fuentes en <strong>src/index.html</strong> (Roboto) que son agregadas tambien en nuestro archivo <strong>src/styles.css</strong> y se debe a que aceptamos esta sección <strong>&quot;Set up global Angular Material typography styles&quot;</strong></p>
<h2 id="instalaci%C3%B3n-de-primeflex">Instalación de PrimeFlex</h2>
<p>En este caso lo instalaremos desde el CDN</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://unpkg.com/primeflex@latest/primeflex.css"</span>&gt;</span>   
</div></code></pre>
<p>No vamos a instalar los themes de PrimeFlex para usar el de Angular Material.</p>
<h2 id="importar-los-m%C3%B3dulos-de-material">Importar los módulos de Material</h2>
<p>Importaremos los módulos que vamos a usar en la APP:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { NgModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-keyword">import</span> { MatAutocompleteModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/autocomplete'</span>;
<span class="hljs-keyword">import</span> { MatButtonModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/button'</span>;
<span class="hljs-keyword">import</span> { MatCardModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/card'</span>;
<span class="hljs-keyword">import</span> { MatChipsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/chips'</span>;
<span class="hljs-keyword">import</span> { MatDialogModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/dialog'</span>;
<span class="hljs-keyword">import</span> { MatFormFieldModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/form-field'</span>;
<span class="hljs-keyword">import</span> { MatGridListModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/grid-list'</span>;
<span class="hljs-keyword">import</span> { MatIconModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/icon'</span>;
<span class="hljs-keyword">import</span> { MatInputModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/input'</span>;
<span class="hljs-keyword">import</span> { MatListModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/list'</span>;
<span class="hljs-keyword">import</span> { MatProgressSpinnerModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/progress-spinner'</span>;
<span class="hljs-keyword">import</span> { MatSelectModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/select'</span>;
<span class="hljs-keyword">import</span> { MatSidenavModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/sidenav'</span>;
<span class="hljs-keyword">import</span> { MatSnackBarModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/snack-bar'</span>;
<span class="hljs-keyword">import</span> { MatToolbarModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/toolbar'</span>;

<span class="hljs-meta">@NgModule</span>({
  exports: [
    MatAutocompleteModule,
    MatButtonModule,
    MatCardModule,
    MatChipsModule,
    MatDialogModule,
    MatFormFieldModule,
    MatGridListModule,
    MatIconModule,
    MatInputModule,
    MatListModule,
    MatProgressSpinnerModule,
    MatSelectModule,
    MatSidenavModule,
    MatSnackBarModule,
    MatToolbarModule,
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MaterialModule { }
</div></code></pre>
<h2 id="pantalla-del-login-auth">Pantalla del Login (Auth)</h2>
<p>Dado que usaremos componente de Material en el <strong>AuthModule</strong> debemos importar el <strong>MaterialModule</strong></p>
<p>Luego, apliquemos un cambio en el template del <strong>LayoutPageComponent</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid p-3"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-12 mt-5 md:col-6 md:col-offset-3 md:mt-8"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>NOTA: Las Clases son de PrimeFlex</p>
<p>En el <strong>LoginPageComponent</strong> template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex flex-column"</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"text-lg mb-4"</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>

 <span class="hljs-tag">&lt;<span class="hljs-name">mat-form-field</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-label</span>&gt;</span>Usuario<span class="hljs-tag">&lt;/<span class="hljs-name">mat-label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">matInput</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"User Name"</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">mat-form-field</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">mat-form-field</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-label</span>&gt;</span>Password<span class="hljs-tag">&lt;/<span class="hljs-name">mat-label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">matInput</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Password"</span>&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">mat-form-field</span>&gt;</span>

 <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-button</span> <span class="hljs-attr">mat-flat-button</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span>&gt;</span>login<span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span>
    Login
 <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex justify-content-end mt-5"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">routerLink</span>=<span class="hljs-string">"/auth/register"</span>&gt;</span>SingIn<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>De nuevo, estamos usando clases de PrimeFlex y los controles de Material:</p>
<ul>
<li>mat-form</li>
<li>mat-label</li>
<li>matInput</li>
<li>mat-icon</li>
</ul>
<p>De esta misma forma podemos crear otra pantalla para el create, con un campo adicional para confirmar password.</p>
<p>El resultado:</p>
<br/>
<img src="./imagenes/herosApp01.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 40%; height: auto; border: 1px solid black" />
<br/>
<img src="./imagenes/herosApp02.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 40%; height: auto; border: 1px solid black" />
<h2 id="sidenav">SideNav</h2>
<p>Continuamos aplicando cambios, esta vez trabajamos en el LayoutPage del HerosModule, vamos a crear un SideNav y un Menu, el cual va a ser mostrado por todas las vistas renderizadas bajo HerosModule, entonces debemos de colocar esto en el compomente padre del módulo, es decir en el template del <strong>LayoutPageComponent</strong></p>
<p>Antes, debemos importar el <strong>MaterialModule</strong> en nuestro <strong>HerosModule</strong></p>
<p>Luego creamos un Arreglo para las opciones del menú:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> LayoutPageComponent {

  <span class="hljs-keyword">public</span> sidebarItems = [
    {label: <span class="hljs-string">'List'</span>,   icon: <span class="hljs-string">'list'</span>,   url: <span class="hljs-string">'./list'</span>},
    {label: <span class="hljs-string">'New'</span>,    icon: <span class="hljs-string">'add'</span>,    url: <span class="hljs-string">'./create'</span>},
    {label: <span class="hljs-string">'Search'</span>, icon: <span class="hljs-string">'search'</span>, url: <span class="hljs-string">'./search'</span>},
  ];
}
</div></code></pre>
<p>Y luego creamos el Template del <strong>LayoutPageComponent</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav-container</span> <span class="hljs-attr">fullscreen</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-sidenav</span> #<span class="hljs-attr">sidenav</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"push"</span> [<span class="hljs-attr">ngStyle</span>]=<span class="hljs-string">"{width: '250px'}"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mat-toolbar</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"accent"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Menu<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spacer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-icon-button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"sidenav.toggle()"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span>&gt;</span>menu<span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">mat-toolbar</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">mat-nav-list</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">mat-list-item</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of sidebarItems"</span>
            [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"item.url"</span>
            (<span class="hljs-attr">click</span>)=<span class="hljs-string">"sidenav.toggle()"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span> <span class="hljs-attr">matListItemIcon</span>&gt;</span>{{item.icon}}<span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span>
                {{item.label}}
            <span class="hljs-tag">&lt;/<span class="hljs-name">mat-list-item</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">mat-nav-list</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">mat-toolbar</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-icon-button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"sidenav.toggle()"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span>&gt;</span>menu<span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spacer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-button</span>&gt;</span>
            Logout
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-toolbar</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span> 
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-sidenav-container</span>&gt;</span>
</div></code></pre>
<p>Todo el contenido está dentro del <strong>mat-sidenav-container</strong>  el cual contiene 3 secciones:</p>
<ul>
<li>Un SideBar (mat-sidenav)</li>
<li>Un Toolbar (mat-toolbar)</li>
<li>Un container para renderizar los componentes (router-outlet)</li>
</ul>
<p>El Toolbar tiene un botón que hace aparecer el SideBar y viceversa</p>
<p>El Sidebar internamente cuenta con dos elementos</p>
<ul>
<li>mat-toolbar (Muestra el título y el boton para ocultar la sección)</li>
<li>mat-nav-list (El que muestra las opciones del menú)</li>
</ul>
<p>Veamos el resultado:</p>
<br/>
<img src="./imagenes/herosApp03.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<h2 id="json-server">Json Server</h2>
<p>Implementaremos un Servidor JSON unicamente en desarrollo, <a href="https://www.npmjs.com/package/json-server">https://www.npmjs.com/package/json-server</a></p>
<pre class="hljs"><code><div>npm install --save-dev json-server
</div></code></pre>
<p>Creamos un directorio <strong>data</strong> en el root de nuestro proyecto y agregamos un json con datos para mostrar, por ejemplo:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"users"</span>: [
    {
      <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">"usuario"</span>: <span class="hljs-string">"John Doe"</span>,
      <span class="hljs-attr">"email"</span>: <span class="hljs-string">"john.due@gmail.com"</span>
    }
  ],
  <span class="hljs-attr">"heroes"</span>: [
    {
      <span class="hljs-attr">"id"</span>: <span class="hljs-string">"dc-batman"</span>,
      <span class="hljs-attr">"superhero"</span>: <span class="hljs-string">"Batman"</span>,
      <span class="hljs-attr">"publisher"</span>: <span class="hljs-string">"DC Comics"</span>,
      <span class="hljs-attr">"alter_ego"</span>: <span class="hljs-string">"Bruce Wayne"</span>,
      <span class="hljs-attr">"first_appearance"</span>: <span class="hljs-string">"Detective Comics #27"</span>,
      <span class="hljs-attr">"characters"</span>: <span class="hljs-string">"Bruce Wayne"</span>
    },
    {
      <span class="hljs-attr">"id"</span>: <span class="hljs-string">"dc-superman"</span>,
      <span class="hljs-attr">"superhero"</span>: <span class="hljs-string">"Superman"</span>,
      <span class="hljs-attr">"publisher"</span>: <span class="hljs-string">"DC Comics"</span>,
      <span class="hljs-attr">"alter_ego"</span>: <span class="hljs-string">"Kal-El"</span>,
      <span class="hljs-attr">"first_appearance"</span>: <span class="hljs-string">"Action Comics #1"</span>,
      <span class="hljs-attr">"characters"</span>: <span class="hljs-string">"Kal-El"</span>
    }
  ]
}```

En nuestro Package JSON, agregamos un script:

```json
<span class="hljs-string">"backend"</span>: <span class="hljs-string">"json-server --watch data/db.json --port 3004"</span>
</div></code></pre>
<p>Y finalmente ejecutamos el script en la línea de comandos: (En el root del proyecto)</p>
<pre class="hljs"><code><div>$ npm run  backend

&gt; 05-heros-app@0.0.0 backend
&gt; json-server --watch data/db.json --port 3004


  \{^_^}/ hi!

  Loading data/db.json
  Done

  Resources
  http://localhost:3004/users
  http://localhost:3004/heroes

  Home
  http://localhost:3004
</div></code></pre>
<h2 id="variables-de-entorno">Variables de Entorno</h2>
<p>Angular 17 ya no incluye por defecto la configuración de los environmnets, haremos la configuración manual.</p>
<p>Primero, dentro de <em>src</em> creamos un directorio <em>environments</em> con dos archivos</p>
<ul>
<li>environments.ts</li>
<li>environments.prod.ts</li>
</ul>
<p>Creamos las configuraciones de acuerdo al ambiente, por ejemplo nuestro URL para consumir el JSON Server</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> environments = {
    baseUrl: <span class="hljs-string">'http://localhost:3004'</span>    
}
</div></code></pre>
<p>Y luego en el archivo <strong>angular.json</strong> en la sección:</p>
<pre class="hljs"><code><div>Projects
  05-herosApp
    architect
      build
        configurations
          production
</div></code></pre>
<p>Agreamos el <strong>fileReplacements</strong>:</p>
<pre class="hljs"><code><div>configurations<span class="hljs-string">": {
  "</span>production<span class="hljs-string">": {
    "</span>fileReplacements<span class="hljs-string">": [
      {
        "</span>replace<span class="hljs-string">": "</span>src/environments/environment.ts<span class="hljs-string">",
        "</span>with<span class="hljs-string">": "</span>src/environments/environment.prod.ts<span class="hljs-string">"
      }
    ],
</span></div></code></pre>
<h2 id="crear-interfaz">Crear Interfaz</h2>
<p>Primero debemos crear algunas interfaces, en el direcotrio <em>src/app/heroes/</em> creamos <strong>interfaces</strong> y dentro de este el archivo <strong>heroes.interface.ts</strong></p>
<p>Usaremos la extensión <strong>Paste JSON as code</strong>, ejecutamos en la linea de comandos :</p>
<pre class="hljs"><code><div>curl http://localhost:3004/heroes
</div></code></pre>
<p>Copiamos la salida y en el archivo <strong>heroes.interface.ts</strong> ejecutamos  el comando <strong>Paste JSON as code</strong>  se genera el siguiente código:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Heroe {
    id:               <span class="hljs-built_in">string</span>;
    superhero:        <span class="hljs-built_in">string</span>;
    publisher:        Publisher;
    alter_ego:        <span class="hljs-built_in">string</span>;
    first_appearance: <span class="hljs-built_in">string</span>;
    characters:       <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> Publisher {
    DCComics = <span class="hljs-string">"DC Comics"</span>,
    MarvelComics = <span class="hljs-string">"Marvel Comics"</span>,
}
</div></code></pre>
<h2 id="crear-servicio">Crear Servicio</h2>
<p>Creamos un servicio:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Injectable</span>({providedIn: <span class="hljs-string">'root'</span>})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HeroesService {
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> httpClient: HttpClient</span>) { }

    <span class="hljs-keyword">private</span> baseUrl: <span class="hljs-built_in">string</span> = environments.baseUrl;
    
    getHeroes(): Observable&lt;Heroe[]&gt; {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.get&lt;Heroe[]&gt;(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.baseUrl}</span>/heroes`</span>);
    }

}
</div></code></pre>
<p>NOTA: El HttpClientModule debe ser importado, lo haremos en el app.module.ts</p>
<h2 id="nuevo-componente">Nuevo Componente</h2>
<p>Vamos a consumir el servicio, para mostrar el listado de Heroes, pero antes, necesitamos un componente para mostrar la información de un Heroe en específico,</p>
<pre class="hljs"><code><div>ng g c heros/components/hero-card
</div></code></pre>
<p>Este componente recibirá la información de un Hero (@Input)</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'heros-hero-card'</span>,
  templateUrl: <span class="hljs-string">'./hero-card.component.html'</span>,
  styleUrl: <span class="hljs-string">'./hero-card.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HeroCardComponent <span class="hljs-keyword">implements</span> OnInit{

  <span class="hljs-meta">@Input</span>() 
  <span class="hljs-keyword">public</span> hero!: Heroe;

  ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.hero){
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'HeroCardComponent: Hero is required'</span>);
    }
  }
}
</div></code></pre>
<p>Su Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">mat-card</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-header</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-title</span>&gt;</span>{{ hero.superhero}}<span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-title</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-subtitle</span>&gt;</span>{{ hero.alter_ego}}<span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-subtitle</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-header</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-content</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mt-2"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>{{ hero.publisher }}<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>First apparition<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> {{ hero.first_appearance }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mat-chip-listbox</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">mat-chip</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let character of hero.characters.split(',') | slice:0:3"</span>&gt;</span>
                {{ character }}
            <span class="hljs-tag">&lt;/<span class="hljs-name">mat-chip</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">mat-chip-listbox</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-content</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-divider</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-divider</span>&gt;</span>
    
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-actions</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
            <span class="hljs-attr">mat-button</span> 
            <span class="hljs-attr">mat-raised</span>
            <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>
            [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"['/heroes/edit', hero.id]"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span>&gt;</span>edit<span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span>
            View
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"spacer"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> 
            <span class="hljs-attr">mat-button</span> 
            <span class="hljs-attr">mat-raised</span>
            <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span>
            [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"['/heroes', hero.id]"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span>&gt;</span>more_horiz<span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span>
            More
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-actions</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-card</span>&gt;</span>
</div></code></pre>
<p>Luego necesitamos mostrar esta información, lo haremos en el <strong>ListPageComponent</strong></p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-list-page'</span>,
  templateUrl: <span class="hljs-string">'./list-page.component.html'</span>,
  styleUrl: <span class="hljs-string">'./list-page.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ListPageComponent <span class="hljs-keyword">implements</span> OnInit{

  <span class="hljs-keyword">public</span> heroes: Heroe[] = [];

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> heroesService: HeroesService</span>) { }
  ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.heroesService.getHeroes().subscribe(<span class="hljs-function"><span class="hljs-params">heroes</span> =&gt;</span> <span class="hljs-keyword">this</span>.heroes = heroes);
  }

}
</div></code></pre>
<p>Y finalmente el Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Heroes List<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">mat-divider</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mat-divider</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid mb-8 pt-2"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> 
        *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let hero of heroes"</span> 
        <span class="hljs-attr">class</span>=<span class="hljs-string">"col-12 sm:col-4 md:col-3 xl:col-2"</span>&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">heros-hero-card</span> [<span class="hljs-attr">hero</span>]=<span class="hljs-string">"hero"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">heros-hero-card</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<br/>
<img src="./imagenes/herosApp04.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<h2 id="mostrar-la-imagen-del-heroe">Mostrar la imagen del heroe.</h2>
<p>Los archivos de cada heroe lo tenemos almacenados en el directorio:</p>
<pre class="hljs"><code><div>src/assets/heros/
</div></code></pre>
<p>El nombre del archivo es el <code>hero.id</code> y todos tienen una extensión jpg. Este es un URL válido a una de las imágenes</p>
<pre class="hljs"><code><div>http://localhost:4200/assets/heros/dc-superman.jpg
</div></code></pre>
<p>Podríamos aregar al cardComponent, en el template el siguiente código:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">mat-card-image</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"'../assets/heros/' + hero.id + '.jpg'"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>
</div></code></pre>
<p>Ahora ya podemos ver la imagen del Heroe en nuestro Card:</p>
<br/>
<img src="./imagenes/herosApp05.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<p>otra opción sería agregar un PIPE, el cual recibe le <code>hero.id</code> y genera el URL de la imagen.</p>
<h2 id="creando-heroimage-pipe">Creando HeroImage Pipe</h2>
<p>En la línea de comandos:</p>
<pre class="hljs"><code><div>[fcruz@fedora 05-herosApp]$ ng g p heros/pipes/hero-image --flat --skip-tests
CREATE src/app/heros/pipes/hero-image.pipe.ts (223 bytes)
UPDATE src/app/heros/heros.module.ts (1043 bytes)
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">@Pipe</span>({
  name: <span class="hljs-string">'heroImage'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HeroImagePipe <span class="hljs-keyword">implements</span> PipeTransform {

  transform(hero: Heroe): <span class="hljs-built_in">string</span> {

    <span class="hljs-keyword">if</span> (!hero.id &amp;&amp; !hero.alt_img) {
      <span class="hljs-keyword">return</span> <span class="hljs-string">'assets/no-image.png'</span>;
    }

    <span class="hljs-keyword">if</span> (hero.alt_img) {
      <span class="hljs-keyword">return</span> hero.alt_img;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-string">`assets/heroes/<span class="hljs-subst">${hero.id}</span>.jpg`</span>;
  }
}
</div></code></pre>
<p>Y ahora cambiamos nuestro template del <strong>HeroCardComponent</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">mat-card-image</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"hero | heroImage"</span>&gt;</span>
</div></code></pre>
<p>De esta forma, tendremos un único lugar donde cambiar en el caso de que nuestro directorio de imáges cambie.</p>
<h2 id="obtener-heroe">Obtener Heroe</h2>
<p>Agregamos un método para obtener la información de un heroe:</p>
<pre class="hljs"><code><div>getHeroById(id: <span class="hljs-built_in">string</span>): Observable&lt;Heroe | <span class="hljs-literal">undefined</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.get&lt;Heroe&gt;(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.baseUrl}</span>/heroes/<span class="hljs-subst">${id}</span>`</span>)
    .pipe(catchError(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> of(<span class="hljs-literal">undefined</span>)));
}
</div></code></pre>
<p>El método <strong>getHeroById</strong> retorna un <strong>Observable</strong> que puede ser un heroes (si lo encuentra) o un <strong>undefined</strong></p>
<p>Luego consumimos esto en el <strong>HeroPageComponent</strong></p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-hero-page'</span>,
  templateUrl: <span class="hljs-string">'./hero-page.component.html'</span>,
  styleUrl: <span class="hljs-string">'./hero-page.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HeroPageComponent <span class="hljs-keyword">implements</span> OnInit{

  <span class="hljs-keyword">public</span> hero?: Heroe;

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> heroService: HeroesService, 
    <span class="hljs-keyword">private</span> activatedRoute: ActivatedRoute,
    <span class="hljs-keyword">private</span> router: Router</span>) { }
  
  ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.activatedRoute.params
    .pipe(
      switchMap(<span class="hljs-function">(<span class="hljs-params">{id}</span>) =&gt;</span> <span class="hljs-keyword">this</span>.heroService.getHeroeById(id))
    ).subscribe(<span class="hljs-function"><span class="hljs-params">hero</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!hero) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.router.navigateByUrl(<span class="hljs-string">'/heroes/list'</span>);
      }
      <span class="hljs-keyword">this</span>.hero = hero; 

      <span class="hljs-keyword">return</span>;
    });
  }
}
</div></code></pre>
<p>El constructor inyecta 3 servicios:</p>
<ul>
<li>
<p><strong>HeroesService</strong> para obtener la información del Héroe</p>
</li>
<li>
<p><strong>ActivatedRoute</strong> para acceder al URL activo, y más especificamente a los parametros, dado que necesitamos el ID del Héroe.</p>
</li>
<li>
<p><strong>Router</strong> para redireccionar al usuario en caso de que la búsqueda no retorne nada.</p>
</li>
</ul>
<p>Toda la lógica está en el <strong>ngOnInit</strong>: Accedemos al parámetro ID mediante el <strong>activatedRoute</strong>, luego usamos el <strong>switchMap</strong> para generar otro Observable con el resultado de la búsqueda y finalmente nos suscribimos para analizar si se ha encontrado resultados o no.</p>
<p>Recuerden, esta implementación es incorrecta, ya que genera un <strong>CallbackHell</strong>, o un Subscribe dentro de otro Subsribe:</p>
<pre class="hljs"><code><div>ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.activatedRoute.params.subscribe(<span class="hljs-function">(<span class="hljs-params">{id}</span>) =&gt;</span> {
      <span class="hljs-keyword">this</span>.heroService.getHeroeById(id).subscribe(<span class="hljs-function">(<span class="hljs-params">heroe</span>) =&gt;</span> {
        <span class="hljs-keyword">this</span>.hero = heroe;
      });
    });
  }
</div></code></pre>
<p>Finalmente podemos trabajar en el template para mostrar información de un Héroe en especifico.</p>
<h2 id="autocomplete-con-material">Autocomplete con Material</h2>
<p>Iniciemos con la plantillas:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"flex flex-column p-2"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Searcher<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-form-field</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">mat-label</span>&gt;</span>Hero Searcher<span class="hljs-tag">&lt;/<span class="hljs-name">mat-label</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
        <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> 
        <span class="hljs-attr">matInput</span> 
        [<span class="hljs-attr">formControl</span>]=<span class="hljs-string">"searchControl"</span>
        (<span class="hljs-attr">input</span>)=<span class="hljs-string">"searchHero()"</span>
        [<span class="hljs-attr">matAutocomplete</span>]=<span class="hljs-string">"auto"</span>/&gt;</span>

        <span class="hljs-tag">&lt;<span class="hljs-name">mat-autocomplete</span> <span class="hljs-attr">autoActiveFirstOption</span> #<span class="hljs-attr">auto</span>=<span class="hljs-string">"matAutocomplete"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">mat-option</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let option of heros"</span> [<span class="hljs-attr">value</span>]=<span class="hljs-string">"option.id"</span>&gt;</span>
                {{option.superhero}}
            <span class="hljs-tag">&lt;/<span class="hljs-name">mat-option</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">mat-option</span> 
            *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"heros.length === 0 &amp;&amp; searchControl.pristine === false"</span>
            <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span>
                No Hero found!
            <span class="hljs-tag">&lt;/<span class="hljs-name">mat-option</span>&gt;</span>

            <span class="hljs-tag">&lt;<span class="hljs-name">mat-option</span> 
            *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"heros.length === 0 &amp;&amp; searchControl.pristine === true"</span>
            <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span>
                Search your hero!
            <span class="hljs-tag">&lt;/<span class="hljs-name">mat-option</span>&gt;</span>
            
        <span class="hljs-tag">&lt;/<span class="hljs-name">mat-autocomplete</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-form-field</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Estamos usando componentes de material para mostrar un texto con AutoComplete. El template necesita una lista de <strong>heros</strong> para rellenar las opciones deacuerdo a los criterios de búsqueda.</p>
<p>Ademas controlamos el texto inicial <strong>Search your hero!</strong> el cual se muestra únicamente al inicio, una vez que el usuario ingresa cualquier término, se mostraran los resultados o el texto <strong>No Hero found!</strong> eso se controla con los datos en el arreglo <strong>hero</strong> y con la propiedad <strong>pristine</strong> la cual es TRUE solamente cuando el control se encuentra en su estado inicial.</p>
<p>En cuando al Componente, (TS code):</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SearchPageComponent {

  <span class="hljs-keyword">public</span> searchControl = <span class="hljs-keyword">new</span> FormControl(<span class="hljs-string">''</span>);

  <span class="hljs-keyword">public</span> heros: Heroe[] = [];

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"> <span class="hljs-keyword">private</span> herosService: HeroesService</span>) { }

  searchHero() {
    <span class="hljs-keyword">const</span> value: <span class="hljs-built_in">string</span> = <span class="hljs-keyword">this</span>.searchControl.value || <span class="hljs-string">''</span>;

    <span class="hljs-keyword">this</span>.herosService.getSuggestions( value.trim() )
    .subscribe( <span class="hljs-function"><span class="hljs-params">heros</span> =&gt;</span> <span class="hljs-keyword">this</span>.heros = heros)
  }
}
</div></code></pre>
<p>Dado que estamos usando <strong>ReactiveForms</strong> de Angular, para enlazar nuestro <strong>matInput</strong> debemos importar el módulo <strong>ReactiveFormsModule</strong>, lo haremos en el <strong>HerosModule</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { ReactiveFormsModule } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>;
</div></code></pre>
<p>Y lo agregamos a los <strong>Imports</strong></p>
<p>Con esto ya tenemos un autoComplete,</p>
<p>Estado inicial:</p>
<br/>
<img src="./imagenes/herosApp06.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<p>Tras buscar un obtener resultados</p>
<br/>
<img src="./imagenes/herosApp07.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<p>Sin resultados</p>
<br/>
<img src="./imagenes/herosApp08.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 80%; height: auto; border: 1px solid black" />
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-crud-con-json-server">Nueva Sección: CRUD con Json-Server:</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>Este es un breve listado de los temas fundamentales:</p>
<p>CRUD</p>
<p>Pipes puros e impuros</p>
<p>Snacks</p>
<p>Dialogs</p>
<p>Inyección de servicios manualmente</p>
<p>Esta sección les dará las bases para poder realizar CRUD completos hacia cualquier backend basado en servicios web, mediante comunicación JSON</p>
<h2 id="agregando-los-m%C3%A9todos-al-servicio">Agregando los Métodos al Servicio</h2>
<p>Agregamos los métodos: Add/Update/Delete</p>
<pre class="hljs"><code><div>addHeroe(heroe: Heroe): Observable&lt;Heroe&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.post&lt;Heroe&gt;(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.baseUrl}</span>/heroes`</span>, heroe);

updateHeroe(heroe: Heroe) : Observable&lt;Heroe&gt; {
    <span class="hljs-keyword">if</span> (!heroe.id) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Hero id is requierd to Update'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.put&lt;Heroe&gt;(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.baseUrl}</span>/heroes/<span class="hljs-subst">${heroe.id}</span>`</span>, heroe);

deleteHeroe(id: <span class="hljs-built_in">string</span>): Observable&lt;<span class="hljs-built_in">boolean</span>&gt; {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.delete(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.baseUrl}</span>/heroes/<span class="hljs-subst">${id}</span>`</span>)
    .pipe(
        catchError(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> of(<span class="hljs-literal">false</span>)),
        map(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> <span class="hljs-literal">true</span>));
}
</div></code></pre>
<p>En el caso del <strong>deleteHeroe</strong> el API retorna un arreglo vacío <strong>[]</strong> con status 200 cuando se borra un Heroe, y retorna un objeto vacío <strong>{}</strong> con status 404 cuado se intenta borrar un Heroe con ID inexistente, por lo tanto, en ese caso retornaremos un Observable con valor <strong>true/false</strong></p>
<p>Para ello usamos el <strong>catchError</strong> para enviar un <strong>false</strong> o caso contraio enviamos un <strong>true</strong></p>
<h2 id="formularios-reactivos">Formularios Reactivos</h2>
<p>Los formularios reactivos permite mover la mayor parte de la lógica del lado del componente.</p>
<p>Vamos a usar un Formulario Reactivo para enlazar nuestro formulario, en el componente <strong>NewPageComponent</strong> creamos este objeto:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span>  heroForm = <span class="hljs-keyword">new</span> FormGroup({
    id:               <span class="hljs-keyword">new</span> FormControl&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">''</span>),
    superhero:        <span class="hljs-keyword">new</span> FormControl&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">''</span>, {nonNullable: <span class="hljs-literal">true</span>}),
    publisher:        <span class="hljs-keyword">new</span> FormControl&lt;Publisher&gt;(Publisher.DCComics),
    alter_ego:        <span class="hljs-keyword">new</span> FormControl&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">''</span>),
    first_appearance: <span class="hljs-keyword">new</span> FormControl&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">''</span>),
    characters:       <span class="hljs-keyword">new</span> FormControl&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">''</span>),
    alt_img:          <span class="hljs-keyword">new</span> FormControl&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">''</span>)
  });
</div></code></pre>
<p><strong>heroForm</strong> es de tipo <strong>FormGroup</strong> el cual acepta un objeto cuyas propiedades son los campos de nuestro formulario, cada propiedad se define con el tipo <strong>FormControl</strong>, al mismo se le puede indicar el tipo de datos y algunas validaciones adicionales.</p>
<p>Ahora vamos a conectar el TemplateHTML con el formulario.</p>
<p>En resumen el Template del <strong>NewPageComponent</strong> tiene estas secciones</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-12 sm:col-6 mt-2"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-card</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">mat-card-content</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid"</span>&gt;</span>
          <span class="hljs-comment">&lt;!-- Input Super Hero--&gt;</span>
          <span class="hljs-comment">&lt;!-- Input Alter Ego--&gt;</span>
          <span class="hljs-comment">&lt;!-- Input First Appearance--&gt;</span>
          <span class="hljs-comment">&lt;!-- Input Characters--&gt;</span>
          <span class="hljs-comment">&lt;!-- Input Puiblisher--&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- Butons Sectios--&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card-content</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-card</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-comment">&lt;!-- Second Column with the Image --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Vamos a cambiar el <strong><div class="grid"></strong> que agrupa los controles (Input) por un <strong>&lt;form class=&quot;grid&quot; [formGroup]=&quot;heroForm&quot;&gt;</strong></p>
<p>Esto enlaza nuestro Form del Template con el FormGroup del Componente. Pero debemos hacer lo mismo a nivel de Campos.</p>
<p>Por ejemplo, el campo <strong>Super Hero</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">mat-label</span>&gt;</span>Super Hero<span class="hljs-tag">&lt;/<span class="hljs-name">mat-label</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> 
<span class="hljs-attr">matInput</span> 
<span class="hljs-attr">placeholder</span>=<span class="hljs-string">""</span>
<span class="hljs-attr">required</span>=<span class="hljs-string">""</span>&gt;</span>
</div></code></pre>
<p>A dicho Input le agregaremos:</p>
<pre class="hljs"><code><div>formControlName="superhero"
</div></code></pre>
<p>Esto enlaza el Input <strong>superhero</strong> con el Campo del mismo nombre que definimos en nuestro FormGroup a nivel del componente. Lo mismo aplicamos para los otros Input.</p>
<p>En el caso del Publisher, es un control tipo <strong>mat-select</strong>, tal como si fuese un control más, agregamos el <strong>formControlName</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">mat-select</span> 
<span class="hljs-attr">required</span>=<span class="hljs-string">""</span>
<span class="hljs-attr">formControlName</span>=<span class="hljs-string">"publisher"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-option</span> 
    *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let publisher of publishers"</span>
     [<span class="hljs-attr">value</span>]=<span class="hljs-string">"publisher.id"</span>&gt;</span>
        {{ publisher.desc}}
    <span class="hljs-tag">&lt;/<span class="hljs-name">mat-option</span>&gt;</span> 
<span class="hljs-tag">&lt;/<span class="hljs-name">mat-select</span>&gt;</span>
</div></code></pre>
<p>Ahora creamos un método</p>
<pre class="hljs"><code><div>onSubmit() {
    <span class="hljs-keyword">let</span> formValid = <span class="hljs-keyword">this</span>.heroForm.valid;
    <span class="hljs-keyword">let</span> value = <span class="hljs-keyword">this</span>.heroForm.value;
    <span class="hljs-keyword">let</span> rawValue = <span class="hljs-keyword">this</span>.heroForm.getRawValue();

    <span class="hljs-built_in">console</span>.log(rawValue);
  }
</div></code></pre>
<p>Y lo enlazamos en nuestro formulario</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid"</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"heroForm"</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"onSubmit()"</span>&gt;</span>
</div></code></pre>
<p>Dado que nuestro botón de guardar lo hemos dejado fuera del formulario, tenemos que agergar tambien el onSubmit</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-flat-button</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"primary"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"onSubmit()"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">mat-icon</span>&gt;</span>save<span class="hljs-tag">&lt;/<span class="hljs-name">mat-icon</span>&gt;</span>
    Save
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>Si hacemos click en el botón <strong>save</strong> en consola veremos este objeto:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"id"</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">"superhero"</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">"publisher"</span>: <span class="hljs-string">"DC Comics"</span>,
    <span class="hljs-attr">"alter_ego"</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">"first_appearance"</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">"characters"</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">"alt_img"</span>: <span class="hljs-string">""</span>
}
</div></code></pre>
<p>Además el <strong>this.heroForm.valid</strong> es <em>false</em> dado que no se han agregado los valores para los campos requeridos.</p>
<h2 id="geter-dentro-del-componente">Geter dentro del Componente</h2>
<p>El valor actual del <strong>this.heroForm.value</strong> aunque es muy similar a la interfaz de Heroe, realmente no es del mismo tipo, podemos crear un metodo GET, para retornar el valor del Heroe mostrado en el formulario.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">get</span> currentHero(): Heroe {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.heroForm.value <span class="hljs-keyword">as</span> Heroe;
}
</div></code></pre>
<p>Luego podemos usar este valor para mostrar la imagen con el <strong>heroImage</strong> pipe</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">img</span> [<span class="hljs-attr">src</span>]=<span class="hljs-string">"currentHero | heroImage"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"Hero Image here!!!"</span> <span class="hljs-attr">mat-card-image</span>&gt;</span>
</div></code></pre>
<p>Recordemos que el PIPE mencionado usa un default Image</p>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (!hero.id &amp;&amp; !hero.alt_img) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">'assets/no-image.png'</span>;
}
</div></code></pre>
<p>Por esta razón vemos el placeholder de la imagen:</p>
<br/>
<img src="./imagenes/herosApp09.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 70%; height: auto; border: 1px solid black" />
<h2 id="completar-el-onsubmit">Completar el OnSubmit</h2>
<p>Apliquemos los siguientes cambios en el OnSubmit</p>
<pre class="hljs"><code><div>onSubmit() {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentHero.id) {
    <span class="hljs-keyword">this</span>.heroService.updateHeroe(<span class="hljs-keyword">this</span>.currentHero)
    .subscribe(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> {
      <span class="hljs-comment">// mostrar mensaje</span>
    });
   <span class="hljs-keyword">return</span>;
  }

 <span class="hljs-keyword">this</span>.heroService.addHeroe(<span class="hljs-keyword">this</span>.currentHero)
  .subscribe( <span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> {
    <span class="hljs-comment">// mostrar mensaje y navegar /heroes/list</span>
  })
}  
</div></code></pre>
<p>Con estos cambios, por el momento, podemos agregar un registro, dado que al cargar el formulario, siempre muestra un formulario vacio. De modo que el ID no ha sido asignado al Heroe.</p>
<h2 id="carga-un-heroe">Carga un Heroe</h2>
<p>Para cargar un Heroe seleccionado desde el Grid, vamos a agregar un cambio en el <strong>NewPageComponent</strong></p>
<p>Durante la inicialización del componente, vamos a determinar si estamos cargando un heroe para editarlo, si es así, vamos a tomar de los params el ID del heroe y lo buscaremos con nuestro servicio.</p>
<p>Finalmente hacemos un reset del FORM y le asignamos el heroe encontrado, el código es el siguiente</p>
<pre class="hljs"><code><div>ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.router.url.includes(<span class="hljs-string">'edit'</span>)) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">this</span>.activatedRoute.params
    .pipe(
      switchMap(<span class="hljs-function">(<span class="hljs-params">{ id }</span>) =&gt;</span> <span class="hljs-keyword">this</span>.heroService.getHeroeById( id )),  
    ).subscribe(<span class="hljs-function"><span class="hljs-params">heroe</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!heroe) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.router.navigateByUrl(<span class="hljs-string">'/heroes/list'</span>); 

      <span class="hljs-keyword">this</span>.heroForm.reset(heroe);

      <span class="hljs-keyword">return</span>;
    });
  }
</div></code></pre>
<p>Con este cambio, al hacer click sobre el botón <strong>edit</strong> de un heroe, se abre la pantalla en modo de edición.</p>
<h2 id="snackbars">SnackBars</h2>
<p>MatSnackBar es un servicio para mostrar notificaciones. Actualmente al actualizar un registro, no vemos ningún mensaje que confirme que se ha aplicado el cambios.</p>
<p>Como es un servicio, lo importaremos y lo inyectaremos en el constructor.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">private</span> snackbar: MatSnackBar</span>) { }
</div></code></pre>
<p>Creamos un método, ya que vamos a desplegar diferentes mensajes dependiendo de ciertas acciones en este formulario:</p>
<pre class="hljs"><code><div>showSnackbar(message: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">this</span>.snackbar.open(message, <span class="hljs-string">'ok!'</span>, {
      duration: <span class="hljs-number">2500</span>,
      horizontalPosition: <span class="hljs-string">'center'</span>,
      verticalPosition: <span class="hljs-string">'top'</span>
    });
  }
</div></code></pre>
<p>Y luego lo llamamos donde sea necesario. Por ejemplo al editar, si la acción fue realizada con éxito:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">this</span>.showSnackbar(<span class="hljs-string">'Record updated successfully'</span>);
<span class="hljs-keyword">this</span>.router.navigateByUrl(<span class="hljs-string">'/heros/list'</span>);
</div></code></pre>
<h2 id="dialog">Dialog</h2>
<p>Para eliminar un Heroe, necesitamos un confirmación, para ellos usaremos el componente de Material: Dialog.</p>
<p>Este componente renderiza un dialogo en pantalla, como un pop-up, a su vez dicho componente necesita otro, que es un componente que contiene la información a mostrar.</p>
<p>Crearemos un componente en el directorio shared/components/dialogs</p>
<pre class="hljs"><code><div>ng g c shared/components/dialog/confirm
</div></code></pre>
<p>Dado qeu necesitamos pasarle datos al componente, como el titulo y el mensaje a mostrar, creamos una interfaz propia del componente:</p>
<p>Directorio: <strong>hared/components/dialog/interfaces</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> ConfirmData {
    title: <span class="hljs-built_in">string</span>;
    message: <span class="hljs-built_in">string</span>;
}
</div></code></pre>
<p>Luego creamos el TS del componente:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component, Inject } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { MAT_DIALOG_DATA, MatDialogRef } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/material/dialog'</span>;
<span class="hljs-keyword">import</span> { ConfirmData } <span class="hljs-keyword">from</span> <span class="hljs-string">'../interfaces/confirm.interface'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-confirm'</span>,
  templateUrl: <span class="hljs-string">'./confirm.component.html'</span>,
  styleUrl: <span class="hljs-string">'./confirm.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ConfirmComponent {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">public</span> dialogRef: MatDialogRef&lt;ConfirmComponent&gt;,
    <span class="hljs-meta">@Inject</span>(MAT_DIALOG_DATA) <span class="hljs-keyword">public</span> data: ConfirmData,
  </span>) {}

  onNoClick(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.dialogRef.close(<span class="hljs-literal">false</span>);
  }
  onConfirm(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.dialogRef.close(<span class="hljs-literal">true</span>);
  }
}
</div></code></pre>
<p>Un par de apuntes, el constructor de ConfirmComponent tiene dos parámetros:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> dialogRef: MatDialogRef&lt;ConfirmComponent&gt;: MatDialogRef
</div></code></pre>
<p>Es un servicio proporcionado por Angular Material que representa una referencia a un cuadro de diálogo. En este caso, se utiliza para cerrar el cuadro de diálogo cuando sea necesario. <strong>ConfirmComponent</strong> es el tipo de componente asociado al cuadro de diálogo.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Inject</span>(MAT_DIALOG_DATA) <span class="hljs-keyword">public</span> data: ConfirmData
</div></code></pre>
<p>Se utiliza para inyectar datos en el cuadro de diálogo. <strong>MAT_DIALOG_DATA</strong> es una constante proporcionada por Angular Material que permite inyectar datos en el cuadro de diálogo. <strong>ConfirmData</strong> es el tipo de datos que se espera.(<em>Interfaz</em>)</p>
<p>Finalmente el Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">mat-dialog-title</span>&gt;</span>{{ data.title }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">mat-dialog-content</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ data.message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">mat-dialog-actions</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"onNoClick()"</span>&gt;</span>Cancel<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">mat-button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"onConfirm()"</span> <span class="hljs-attr">cdkFocusInitial</span>&gt;</span>Ok<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Listo, antes de continuar, debemos exportar el <strong>ConfirmComponent</strong> en neustro <strong>SharedModule</strong></p>
<p>Ahora es momento de usarlo, nos vamos al <strong>NewPageComponent</strong>, primero inyectamos un servicio en el Constructor:</p>
<pre class="hljs"><code><div> <span class="hljs-keyword">private</span> dialog: MatDialog
</div></code></pre>
<p>Luego agregamos un método para eliminar el Heroe:</p>
<pre class="hljs"><code><div>onDeleteHero() {
    <span class="hljs-keyword">const</span> confirmData: ConfirmData  = {
      title: <span class="hljs-string">'Delete Hero'</span>,
      message: <span class="hljs-string">`Are you sure you want to delete the hero <span class="hljs-subst">${<span class="hljs-keyword">this</span>.currentHero.superhero}</span>?`</span>
    };
    <span class="hljs-keyword">const</span> dialog = <span class="hljs-keyword">this</span>.dialog.open(ConfirmComponent, {
      width: <span class="hljs-string">'500px'</span>,
      data: confirmData,
    });

    dialog.afterClosed()
    .pipe(
      switchMap(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (resp) 
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.heroService.deleteHeroe(<span class="hljs-keyword">this</span>.currentHero.id!);
        <span class="hljs-keyword">return</span> of(<span class="hljs-literal">false</span>);
      })
    ).subscribe(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (!resp) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">this</span>.showSnackbar(<span class="hljs-string">'Record deleted successfully'</span>);
      <span class="hljs-keyword">this</span>.router.navigateByUrl(<span class="hljs-string">'/heros/list'</span>);
    });

    dialog.afterClosed()
    .subscribe(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> {
      <span class="hljs-keyword">if</span> (resp) {
        <span class="hljs-built_in">console</span>.log(resp);

        <span class="hljs-keyword">this</span>.heroService.deleteHeroe(<span class="hljs-keyword">this</span>.currentHero.id!)
        .subscribe(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> {
          <span class="hljs-keyword">this</span>.showSnackbar(<span class="hljs-string">'Record deleted successfully'</span>);
          <span class="hljs-keyword">this</span>.router.navigateByUrl(<span class="hljs-string">'/heros/list'</span>);
        });
      }
    });
  }
</div></code></pre>
<p>Primero, <strong>ConfirmData</strong> es la interfaz que expone el componente <strong>ConfirmDialog</strong>, entonces debemos crear un objeto de este tipo y asignar los datos que se mostrarán en el Dialog:</p>
<p>Luego llamamos el método <strong>open</strong> del dialog y le pasamos la configuración, incluidos los datos.</p>
<p>Finalmente nos suscribimos al <strong>afterClosed</strong> y ejecutamos el <strong>deleteHeroe</strong></p>
<p>El <strong>afterClosed</strong> retornara un valor True|False, dependiendo del botón presionado (OK, CANCEL), si es true, procedemos con la eliminación del Heroe.</p>
<p>Otra forma de implementar el <strong>afterClose</strong> seria:</p>
<pre class="hljs"><code><div>dialog.afterClosed()
  .pipe(
    filter(<span class="hljs-function">(<span class="hljs-params">result: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> result),
    switchMap(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.heroService.deleteHeroe(<span class="hljs-keyword">this</span>.currentHero.id!)),
    filter(<span class="hljs-function">(<span class="hljs-params">wasDeleted: <span class="hljs-built_in">boolean</span></span>) =&gt;</span> wasDeleted),
    )
    .subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">this</span>.showSnackbar(<span class="hljs-string">'Record deleted successfully'</span>);
      <span class="hljs-keyword">this</span>.router.navigateByUrl(<span class="hljs-string">'/heros/list'</span>);
    });
</div></code></pre>
<p>El result del AfterClosed puede ser:</p>
<p>True: Si presiona en OK
False: Si presiona en Cancelar
undefined: Si presiona fuera del dialog</p>
<p>Por lo tanto el primer filter, filtra unicamene los eventos TRUE.</p>
<p>Luego el switchMap ejecuta el deleteHeroe, el cual puede retornar: TRUE: Si fue eliminado o  FALSE: si ocurrió un error.</p>
<p>De nuevo se aplica un filtro para mantener en el pipe los eventos TRUE</p>
<p>Finalmente al suscribirse, lo único que puede llegar a escuhar son EVENTOS TRUE, es decir que efectivamente se eliminó el registro, por lo tanto, directamente manda el mensaje a pantalla y redirecciona al list.</p>
<p>NOTA: Para que esto funcione, hay que hacer una correción en el deleteHeroe del servicio, el catchError debe estar al final del pipe. Es decir map -&gt; catchError. Anteriormente el catchError era lo primero que se ejecutaba en el PIPE.</p>
<pre class="hljs"><code><div>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.delete(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.baseUrl}</span>/heroes/<span class="hljs-subst">${id}</span>`</span>)
  .pipe(
      map(<span class="hljs-function"><span class="hljs-params">resp</span> =&gt;</span> <span class="hljs-literal">true</span>),
      catchError(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> of(<span class="hljs-literal">false</span>)));
</div></code></pre>
<p>El resultado final es el siguiente dialog al momento de eliminar un heroe:
<br/>
<img src="./imagenes/herosApp10.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 70%; height: auto; border: 1px solid black" /></p>
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-guards-protecci%C3%B3n-de-rutas">Nueva Sección: Guards (Protección de Rutas):</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>Este es un breve listado de los temas fundamentales:</p>
<ul>
<li>Protección de ruta-</li>
<li>Rutas privada-</li>
<li>Rutas pública-</li>
<li>Servicio de autenticació-</li>
<li>Guard-</li>
<li>Can Activat-</li>
<li>Can Matc-</li>
<li>Mantener la sesión del usuario</li>
</ul>
<p>Esta es una sección muy importante, donde controlaremos de forma básica una autenticación, mucho más adelante en el curso, realizaremos autenticación mediante JWT, pero antes de llegar a eso que son temas de Backend, necesito que comprendamos cómo Angular nos puede servir para proteger nuestras rutas.</p>
<h2 id="fake-login">Fake Login</h2>
<p>Para mostrar la utilidad de los Guards, vamos a simular el login/ logout del usuario, no vamos a autenticarlo por el momento. Usaremos el siguiente servicio dentro del módulo de Autenticación</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Injectable</span>({providedIn: <span class="hljs-string">'root'</span>})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AuthService {

    <span class="hljs-keyword">private</span> baseUrl: <span class="hljs-built_in">string</span> = environments.baseUrl;

    <span class="hljs-keyword">private</span> user?: User;

    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> httpClient: HttpClient</span>) { }

    <span class="hljs-keyword">get</span> currentUser() : User | <span class="hljs-literal">undefined</span> {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.user) <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;

        <span class="hljs-keyword">return</span> structuredClone(<span class="hljs-keyword">this</span>.user);
    }

    login( email: <span class="hljs-built_in">string</span>, password: <span class="hljs-built_in">string</span>): Observable&lt;User&gt; {
        
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.get&lt;User&gt;(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.baseUrl}</span>/users/1`</span>)
        .pipe(
            tap(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> <span class="hljs-keyword">this</span>.user = user),
            tap(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> localStorage.setItem(<span class="hljs-string">'token'</span>, user.id.toString()),
            )
        );
    }

    logout(): Observable&lt;<span class="hljs-built_in">boolean</span>&gt; {
        <span class="hljs-keyword">this</span>.user = <span class="hljs-literal">undefined</span>;
        localStorage.clear();
        <span class="hljs-keyword">return</span> of(<span class="hljs-literal">true</span>);
    }
}
</div></code></pre>
<p>Lo importante aca es que cuando se llame el método <strong>login</strong> se devolverá siempre el user con ID 1, notar que no estamos validando user ni password. Adicionalmente, guardaremos en el localStorage, en el UserID</p>
<p>También agregamos el <strong>logout</strong> que elimina el Token del localStorage y hace undefined el usuario previamente &quot;logeado&quot;</p>
<p>El Login lo usaremos en el <strong>LoginPageComponent</strong></p>
<pre class="hljs"><code><div>onLogin() {
  <span class="hljs-keyword">this</span>.authService.login(<span class="hljs-string">'admin@gmail.com'</span>, <span class="hljs-string">'123456'</span>)
  .subscribe(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> {
    <span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'/'</span>]);
  })
}
</div></code></pre>
<p>Y el Logout lo tenemos que usar en el <strong>LayoutPageComponent</strong> ya que este muestra el botón logout en la Hearde.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> authService: AuthService,
    <span class="hljs-keyword">private</span> router: Router</span>) { }

onLogout() {
  <span class="hljs-keyword">this</span>.authService.logout()
  .subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">this</span>.router.navigate([<span class="hljs-string">'/auth/login'</span>]);
  });
}
</div></code></pre>
<p>Listo, con estos métodos tenemos un fakeLogin que guarda el ID del usuario en el LocalStorage y lo elimina cuando hace Logout,</p>
<p>El objetivo es validar que el usuario esté logeado para permitirlo navegar en la APP, caso contrario debe ser redireccionado al <em>auth/login</em></p>
<h2 id="mostrar-el-usuario-logeado">Mostrar el usuario Logeado</h2>
<p>Vamos a mostrar en el Header BAR el usuario Logeado, en el template del <strong>LayoutPageComponent</strong> agreamos esto:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pl-1 pr-3"</span>&gt;</span>{{currentUser?.user | titlecase}}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<p>Y definimo el método:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">get</span> currentUser(): User | <span class="hljs-literal">undefined</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.authService.currentUser;
}
</div></code></pre>
<p>Ahora, luego de logearnos, podemos ver el nombre del usuario en la barra
<br/>
<img src="./imagenes/herosApp11.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 70%; height: auto; border: 1px solid black" /></p>
<p>Pero si recargamos la página se pierde los datos de sessión y el nombre se borra, aunque, en nuestro localstorage tenemos la información del Token.</p>
<p>Lo que necesitamos es verificar que al recargar las páginas, debemos inspeccionar el localStorage, y si tenemos un Token guardado, debemos cargar la información de nuevo a la sessión.</p>
<h2 id="verificar-sessi%C3%B3n-activa">Verificar Sessión Activa</h2>
<p>Vamos a usar un método en nuestro AuthService que valida si hay un Token</p>
<pre class="hljs"><code><div>checkAuth(): Observable&lt;<span class="hljs-built_in">boolean</span>&gt; {
    <span class="hljs-keyword">const</span> token = localStorage.getItem(<span class="hljs-string">'token'</span>);
    <span class="hljs-keyword">if</span> (!token) <span class="hljs-keyword">return</span> of(<span class="hljs-literal">false</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.get&lt;User&gt;(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.baseUrl}</span>/users/1`</span>)
    .pipe(
        tap(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> <span class="hljs-keyword">this</span>.user = user),
        map(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> !!user),
        catchError(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> of(<span class="hljs-literal">false</span>))
    )
}
</div></code></pre>
<p>Este método hace dos cosas:</p>
<ul>
<li>Regresa FALSE si el token no existe</li>
<li>Regresa TRUE y a la vez reasigna el this.user si existe el Token</li>
</ul>
<p>NOTA: <code>!!user</code> regresa TRUE si el usuario fue encontrado o False caso contrario, es la negación de la negación.</p>
<p>Si el usuario está definido:
<code>!user</code>  Regresa False  luego   <code>!False</code> regresa True.</p>
<p>Si el usuario NO está definido:
<code>!user</code> Regresa TRUE, luego <code>!True</code> regresa False</p>
<h2 id="implementando-el-guards">Implementando el Guards</h2>
<p>En Angular, los guards (o guardianes) son clases que implementan interfaces específicas para controlar la navegación en una aplicación. Estos guards se utilizan para proteger o permitir el acceso a ciertas rutas o componentes en función de ciertas condiciones.</p>
<p>Los Guards son servicios pero en lugar de inyectarlos en los constructores, se colocan en un lugar específico, los Routers.</p>
<p>NOTA: En Angular 17, se han deprecado varias interfaces de los Guards, aca se muestra un ejemplo tomado de la documentación de Angular.</p>
<p>Dentro del directorio <em>Auth</em> creamos el directorio <em>guards</em> y en el archivo auth.guards.ts creamos este código:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Injectable, inject } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { ActivatedRouteSnapshot, 
    CanActivateFn, 
    CanMatchFn, 
    Route,
    Router, 
    RouterStateSnapshot, 
    UrlSegment } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/router'</span>;
<span class="hljs-keyword">import</span> { AuthService } <span class="hljs-keyword">from</span> <span class="hljs-string">'../services/auth.service'</span>;
<span class="hljs-keyword">import</span> { Observable, tap } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-keyword">const</span> checkAuthStatus = (): <span class="hljs-built_in">boolean</span> | Observable&lt;<span class="hljs-built_in">boolean</span>&gt; =&gt; {
    <span class="hljs-keyword">const</span> authService: AuthService = inject(AuthService);
    <span class="hljs-keyword">const</span> router: Router = inject(Router);
   
    <span class="hljs-keyword">return</span> authService.checkAuth().pipe(
      tap(<span class="hljs-function">(<span class="hljs-params">isAuthenticated</span>) =&gt;</span> {
        <span class="hljs-keyword">if</span> (!isAuthenticated) {
          router.navigate([<span class="hljs-string">'/auth/login'</span>]);
        }
      })
    );
  };
  
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> canActivateAuthGuard: CanActivateFn = (
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ) =&gt; {   
    <span class="hljs-keyword">return</span> checkAuthStatus();
};
   
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> canMatchAuthGuard: CanMatchFn = (
    route: Route,
    segments: UrlSegment[]
  ) =&gt; {   
    <span class="hljs-keyword">return</span> checkAuthStatus();
};
</div></code></pre>
<p>Varias cosas por analizar:</p>
<ul>
<li>No necesitamos una clase para implementar los guards</li>
<li>La función local <strong>checkAuthStatus</strong> inyecta el AuthService y el Router con el <strong>inject</strong></li>
</ul>
<p>Tanto el <strong>canActivateGuard</strong> como el <strong>canMatchGuard</strong> implementan las interfaces respectivas <strong>CanActivateFn</strong> y <strong>CanMatchFn</strong>, estas regresan un valor True o False dependiendo de lo que retorne el método <strong>checkAuthStatus</strong></p>
<p>Un Valor True indica que se puede continuar con la navegación, un valor False indica lo conrario.</p>
<p>Luego debemos usar estos Guards, actualizamos nuestro <strong>app.routing.ts</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">//localhost:4200</span>
<span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">'auth'</span>,
    loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./auth/auth.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.AuthModule),
  },
  {
    path: <span class="hljs-string">'heros'</span>,
    loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./heros/heros.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.HerosModule),
    canActivate: [canActivateAuthGuard],
    canMatch: [canMatchAuthGuard], 
  },
  <span class="hljs-comment">//Otras rutas aca</span>
];
</div></code></pre>
<p>Ambos Guards entraran en servicio cuando el usuario intente navegar a cualquier ruta del módulo <strong>heros</strong></p>
<p>Con este cambio, si el usuario está logeado puede navegar a los URL's, caso contrario es redireccionado al Login.</p>
<h2 id="redirect-en-el-login">Redirect en el Login</h2>
<p>El caso contrario es: Cuando hay una sesión abierta y el usuario intenta abrir la página del login. Esto debe redireccionar el <em>./</em> ya que el usuario, al ver el login View puede interpretar que ha cerrado sesión, y abandonar su dispositivo o estación de trabajo. Si otro usuario abre la APP en usando otro URL, podrá ver el contenido ya que el usuario anterior no cerró sesión.</p>
<p>Para lograr esto creamos una copia del <strong>auth.guards.ts</strong> y vamos a cambiar la condición en el método <strong>checkAuthStatus</strong> En lugar de:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">return</span> authService.checkAuth().pipe(
tap(<span class="hljs-function">(<span class="hljs-params">isAuthenticated</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (!isAuthenticated) {
    router.navigate([<span class="hljs-string">'/auth/login'</span>]);
  }
})
</div></code></pre>
<p>Implementamos esto:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">return</span> authService.checkAuth().pipe(
  tap(<span class="hljs-function">(<span class="hljs-params">isAuthenticated</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (isAuthenticated) {
      router.navigate([<span class="hljs-string">'/heros/list'</span>]);
    }
  }),
  map(<span class="hljs-function">(<span class="hljs-params">isAuthenticated</span>) =&gt;</span> !isAuthenticated),
);
</div></code></pre>
<p>NOTA: Sin el  <code>map((isAuthenticated) =&gt; !isAuthenticated),</code> estaba enviado siempre al 404Page, esto porque el TAP hace un navigate, pero el método como tal estaba regresando un TRUE (todo ese return regrea algo, un TRUE). Al regresar un TRUE, intenta cargar el Auth/login y a la vez el Hero/Lis causando un problema interno de redireciconamiento.</p>
<p>El map retorna lo opuesto al <strong>isAuthenticated</strong> de modo que si está autenticado, retorna un False y la navegación al /Auth/Login se cancela.</p>
<p>Otros cambios en el Guard, es que debemos renombramos los métodos <strong>canActivateAuthGuard</strong>  y <strong>canMatchAuthGuard</strong> a <strong>canActivatePublicGuard</strong>  y <strong>canMatchPublicGuard</strong> respectivamente y luego agregamos los nuevos Guards al AppRouting en el path del login:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">'auth'</span>,
    loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./auth/auth.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.AuthModule),
    canActivate: [canActivatePublicGuard],
    canMatch: [canMatchPublicGuard],
  },
  {
    path: <span class="hljs-string">'heros'</span>,
    loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./heros/heros.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.HerosModule),
    canActivate: [canActivateAuthGuard],
    canMatch: [canMatchAuthGuard], 
  }
  ...
];
</div></code></pre>
<p>De esta forma, si el usuario está logeado, y trata de cargar el loginView será redireccionado al <strong>/heros/list</strong>, si no está logeado, podrá ver normalmente la página de logeo.</p>
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-formularios-reactivos">Nueva Sección: Formularios Reactivos:</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>Este es un breve listado de los temas fundamentales:</p>
<ul>
<li>Formularios Reactivos</li>
<li>Lazyload y tareas relacionadas</li>
<li>Validaciones propias de Angular</li>
<li>Validaciones personalizadas</li>
<li>Validaciones asíncronas</li>
<li>Arreglos y objetos anidados</li>
<li>FormBuilder</li>
<li>FormGroup</li>
<li>FormArray</li>
</ul>
<h2 id="nueva-app">Nueva APP</h2>
<p>Creamos una nueva app</p>
<pre class="hljs"><code><div> ng new 06-formsApp --standalone --routing
</div></code></pre>
<p>Usaremos bootsrap, pegamos el link en nuestro index</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">integrity</span>=<span class="hljs-string">"sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>&gt;</span>
</div></code></pre>
<p>Editamos el archivo <em>package.json</em> y agreamos el parámetro <strong>-o</strong> al script start</p>
<pre class="hljs"><code><div><span class="hljs-string">"start"</span>: <span class="hljs-string">"ng serve -o"</span>,
</div></code></pre>
<p>Creamos tres módulos</p>
<pre class="hljs"><code><div>ng g m auth --routing
CREATE src/app/auth/auth-routing.module.ts (247 bytes)
CREATE src/app/auth/auth.module.ts (272 bytes)

[fcruz@fedora 06-formsApp]$ ng g m reactive --routing
CREATE src/app/reactive/reactive-routing.module.ts (251 bytes)
CREATE src/app/reactive/reactive.module.ts (288 bytes)

ng g m shared
CREATE src/app/shared/shared.module.ts (192 bytes)
</div></code></pre>
<p>El ShareModulo lo agregamos al AppModule porque vamos a requereir usar los componentes del Share en nuestra APP. Ademas es el único módulo sin Routing, porque solo va a proporcionar Componentes como utilidades.</p>
<p>En cambio Auth y Reactive, si van a tener sus enrrutadores, porque haremos una carga Lazy y estos deben de agregar rutas Hijas. Generalmente, los Modulos que exponen rutas, contiene Componentes tipo Páginas, y estas agrupan otros componentes que pueden ser propios del módulo, o que vengan de Shared u otros módulos de terceros como Material.</p>
<h2 id="creando-estructura-de-directorios-y-paginas">Creando estructura de Directorios y paginas</h2>
<ul>
<li>
<p>Creamos dos dorectorios <strong>pages</strong> dentro de cada módulo: <strong>Auth</strong> y <strong>Reactive</strong></p>
</li>
<li>
<p>Creamos Los componentes Auth/register, Reactive/basic, Reactive/dinamic y Reactive/switch, los directorios quedarían así:</p>
</li>
</ul>
<pre class="hljs"><code><div>[fcruz@fedora app]$ tree
.
├── app.component.css
├── app.component.html
├── app.component.spec.ts
├── app.component.ts
├── app.module.ts
├── app-routing.module.ts
├── auth
│   ├── auth.module.ts
│   ├── auth-routing.module.ts
│   └── pages
│       └── register-page
│           ├── register-page.component.css
│           ├── register-page.component.html
│           └── register-page.component.ts
├── reactive
│   ├── pages
│   │   ├── basic-page
│   │   │   ├── basic-page.component.css
│   │   │   ├── basic-page.component.html
│   │   │   └── basic-page.component.ts
│   │   ├── dinamic-page
│   │   │   ├── dinamic-page.component.css
│   │   │   ├── dinamic-page.component.html
│   │   │   └── dinamic-page.component.ts
│   │   └── switch-page
│   │       ├── switch-page.component.css
│   │       ├── switch-page.component.html
│   │       └── switch-page.component.ts
│   ├── reactive.module.ts
│   └── reactive-routing.module.ts
└── shared
    └── shared.module.ts
</div></code></pre>
<p>En nuestro AppRoutingModule creamos las rutas Roots:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">'reactive'</span>,
    loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./reactive/reactive.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.ReactiveModule)
  },
  {
    path: <span class="hljs-string">'auth'</span>,
    loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./auth/auth.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.AuthModule)
  },
  {
    path:<span class="hljs-string">'**'</span>,
    redirectTo: <span class="hljs-string">'reactive'</span>
  }
];
</div></code></pre>
<p>Agregamos los ChildRoutes para el módulo de Reactive</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">''</span>,
    children:[
      { path: <span class="hljs-string">'basic'</span>, component: BasicPageComponent},
      { path: <span class="hljs-string">'dinamic'</span>, component: DinamicPageComponent},
      { path: <span class="hljs-string">'switch'</span>, component: SwitchPageComponent},
      { path: <span class="hljs-string">'**'</span>, redirectTo: <span class="hljs-string">'basic'</span>}
    ]
  }
];
</div></code></pre>
<p>Y Hacemos lo mismo con el módulo de Auth.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
  { path: <span class="hljs-string">'singup'</span>, component: RegisterPageComponent },
  { path: <span class="hljs-string">'**'</span>, redirectTo: <span class="hljs-string">'singup'</span> }
];
</div></code></pre>
<p>NOTA: Cada uno de estos componentes, tiene un template ya diseñado, el cual puede ser descarado del repo del curso.</p>
<p><a href="https://gist.github.com/Klerith/5729dcfb170595f84d1b564a182ffbc2">Repo del Curso Oficial</a></p>
<p>o del repo personal:</p>
<p><a href="https://github.com/macfredd/udemy-angular/blob/master/06-formsApp/src/app/auth/pages/register-page/register-page.component.html">Personal Repo</a></p>
<h2 id="barra-lateral">Barra Lateral</h2>
<p>Vamos a crear un componente en el direcotrio shared/components</p>
<pre class="hljs"><code><div>ng g c shared/components/side-menu --skip-tests
</div></code></pre>
<p>Lo exportamos en el SharedModule,</p>
<pre class="hljs"><code><div><span class="hljs-meta">@NgModule</span>({
  declarations: [
    SideMenuComponent
  ],
  imports: [
    CommonModule
  ],
  exports:[
    SideMenuComponent
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SharedModule { }
</div></code></pre>
<p>En el <strong>SideMenuComponent</strong> agreamos estos menuItems:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-keyword">interface</span> MenuItem {
  title: <span class="hljs-built_in">string</span>;
  route: <span class="hljs-built_in">string</span>;
}

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'shared-side-menu'</span>,
  templateUrl: <span class="hljs-string">'./side-menu.component.html'</span>,
  styleUrl: <span class="hljs-string">'./side-menu.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SideMenuComponent {

  <span class="hljs-keyword">public</span> reactiveMenu: MenuItem[] = [
    { title: <span class="hljs-string">'Basicos'</span>, route: <span class="hljs-string">'./reactive/basic'</span> },
    { title: <span class="hljs-string">'Dinamicos'</span>, route: <span class="hljs-string">'./reactive/dinamic'</span> },
    { title: <span class="hljs-string">'Switches'</span>, route: <span class="hljs-string">'./reactive/switch'</span> }
  ];

  <span class="hljs-keyword">public</span> authMenu: MenuItem[] = [
    { title: <span class="hljs-string">'Registro'</span>, route: <span class="hljs-string">'./auth/register'</span> }
  ];
}
</div></code></pre>
<p>Y el template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>Pages<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mt-2"</span>&gt;</span>Reactive<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> 
    *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of reactiveMenu"</span> 
    <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>
    [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"[item.route]"</span>
    <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active"</span>&gt;</span>
        {{ item.title }}
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mt-2"</span>&gt;</span>Validations<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
 
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> 
    *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of authMenu"</span> 
    <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>
    [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"[item.route]"</span>
    <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active"</span>&gt;</span>
        {{ item.title }}
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<p>NOTA: para que el <strong>[routerLink]</strong> funcione dentro del <em>li</em> debemos importar el <strong>RouterModule</strong> en el <strong>SharedModule</strong></p>
<p>Ahora debemos crear nuestro Layout principal, en el app.component.html</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row mt-5"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-12 col-sm-4"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">shared-side-menu</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">shared-side-menu</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Listo, al cargar la app podemos ver el url <strong>http://localhost:4200/reactive/basic</strong> porqué es esta nuestra página por default? Eso se debe a las rutas. En nuestro Root Router (app.routing.ts) hemos dicho que cualquier path <strong>[**]</strong> sera redireccionado al reactive.</p>
<p><strong>Path Inicial: http://localhost:4200/</strong></p>
<pre class="hljs"><code><div>{
  path:<span class="hljs-string">'**'</span>,
  redirectTo: <span class="hljs-string">'reactive'</span>
}
</div></code></pre>
<p><strong>Path redireccionado http://localhost:4200/reactive/</strong></p>
<p>y el path <strong>reactive</strong> carga en modo Lazy el módulo <strong>ReactiveModule</strong></p>
<pre class="hljs"><code><div>{
  path: <span class="hljs-string">'reactive'</span>,
  loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./reactive/reactive.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.ReactiveModule)
}
</div></code></pre>
<p>Y cuando cargamos este módulo, cargamos su reglas de ruteo. Y aca hemos definido que cualquier path que no haga match, será redireccionado al <strong>basic</strong></p>
<p><strong>Path Entrada al módulo: http://localhost:4200/reactive/</strong></p>
<pre class="hljs"><code><div>{ path: <span class="hljs-string">'**'</span>, redirectTo: <span class="hljs-string">'basic'</span>}
</div></code></pre>
<p>Y el path <strong>basic</strong> carga el <strong>BasicPageComponent</strong></p>
<pre class="hljs"><code><div>{ path: <span class="hljs-string">'basic'</span>, component: BasicPageComponent},
</div></code></pre>
<p><strong>Path final: http://localhost:4200/reactive/basic</strong></p>
<p>Resultado final:</p>
<br/>
<img src="./imagenes/reaciveFormsApp01.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<h2 id="primer-form">Primer Form</h2>
<p>En el componente BasicPageCompoenent agregaremos un Formulario reactivo, hay dos formas de hacerlo</p>
<p>Usando el FormGroup:</p>
<p>Primero importaremos el módulo <strong>ReactiveFormsModule</strong> en <strong>ReactiveModule</strong> y luego en nuestro componente <strong>BasicPageComponent</strong> agregamos el siguiente código:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> productForm: FormGroup = <span class="hljs-keyword">new</span> FormGroup({
  name: <span class="hljs-keyword">new</span> FormControl(<span class="hljs-string">''</span>),
  price: <span class="hljs-keyword">new</span> FormControl(<span class="hljs-number">0</span>),
  quantity: <span class="hljs-keyword">new</span> FormControl(<span class="hljs-number">0</span>)
});
</div></code></pre>
<p>La otra forma es usando un FormBuilder, para ello necesitamos inyectar un servicio</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> productForm: FormGroup = <span class="hljs-keyword">this</span>.formBuilder.group({
    name:     [ <span class="hljs-string">''</span>],
    price:    [ <span class="hljs-number">0</span> ],
    quantity: [ <span class="hljs-number">0</span> ]
  });
</div></code></pre>
<p>Esta forma no requiere que se importe el <strong>ReactiveFormsModule</strong> pero usaremos muchas características de los forumarios reactivos que lo vamos a mantener en el Import.</p>
<h2 id="enlazar-el-html-con-el-productform">Enlazar el HTML con el productForm</h2>
<p>Para enlazarlo usaremos la directiva <strong>[formGroup]</strong> que precisamente viene del <strong>ReactiveFormsModule</strong> y le asignaremos el nombre del objeto que definimos en TS.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"productForm"</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">"off"</span>&gt;</span>
</div></code></pre>
<p>NOTA: <strong>autocomplete</strong> OFF indica que nosotros haremos las validaciones de nuestro lado.</p>
<p>Creamos un método:</p>
<pre class="hljs"><code><div>onSubmit() {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.productForm.value);
}
</div></code></pre>
<p>Y lo usamos en el click del botón que hace el submit de nuestro formulario</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>
        (<span class="hljs-attr">click</span>)=<span class="hljs-string">"onSubmit()"</span>
        <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary float-end"</span>&gt;</span>
    Guardar
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>O mejor aún usamos la directiva <strong>ngSubmit</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> 
  [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"productForm"</span> 
  (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"onSubmit()"</span>
  <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">"off"</span>&gt;</span>
</div></code></pre>
<p>Si aún agregando datos, al presionar <strong>Guardar</strong> veremos un objeto sin valores en sus propiedades.</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">"price"</span>: <span class="hljs-string">""</span>,
    <span class="hljs-attr">"quantity"</span>: <span class="hljs-string">""</span>
}
</div></code></pre>
<h2 id="concetar-campos-de-los-formularios">Concetar campos de los formularios.</h2>
<p>Usaremos la directiva <strong>formControlName</strong> y le asignaremos el nombre de la propiedad, por ejemplo, esta sería <strong>name</strong> para el Nombre del producto.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"name"</span>
       <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
       <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>
       <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre del producto"</span>&gt;</span>
</div></code></pre>
<p>Repetimos el mismo proceso para los demas campos del formulario. (Price y quantity) Ahora podemos ver los valores iniciales en cada campo. Además, al agregar datos a los campos y luego presionar <strong>Guardar</strong> vemos en consola:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"PS5"</span>,
    <span class="hljs-attr">"price"</span>: <span class="hljs-number">750</span>,
    <span class="hljs-attr">"quantity"</span>: <span class="hljs-number">1</span>
}
</div></code></pre>
<h2 id="formvalidator">FormValidator</h2>
<p>Angular ya incluye validadores, podemos agregar un conjunto de reglas por campo para facilitar las validaciones, por ejemplo, el nombr del producto:</p>
<ul>
<li>Debe ser requerido</li>
<li>Debe contener al menos 3 caracteres</li>
<li>Y un máximo de 20</li>
</ul>
<p>Estas validaciones las agregamos al FormGroup, actualmente solo definimos un valor inicial sin validaciones. Las validaciones se agregan en el arreglo, como 2do y 3er parametro.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> productForm: FormGroup = <span class="hljs-keyword">this</span>.formBuilder.group({
    name:     [ <span class="hljs-string">''</span>],
    price:    [ <span class="hljs-number">0</span> ],
    quantity: [ <span class="hljs-number">0</span> ]
  });
</div></code></pre>
<p>En el caso del Name, agregamos:</p>
<pre class="hljs"><code><div>name:     [ <span class="hljs-string">''</span>, [Validators.required, Validators.minLength(<span class="hljs-number">3</span>), Validators.maxLength(<span class="hljs-number">20</span>)]],
</div></code></pre>
<p>Aplicamos un par de reglas para los campos price y quantity y probamos el Submit.</p>
<p>Al hacer el submit, simplemente vemos el objeto en el console.log, esto porque no estamos validando el estado del formulario, si agregamos esta condición, los datos no se imprimen</p>
<pre class="hljs"><code><div>onSubmit() {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.productForm.invalid) {
    <span class="hljs-keyword">this</span>.productForm.markAllAsTouched();
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.productForm.value);
}
</div></code></pre>
<p>nota: <code>this.productForm.markAllAsTouched();</code> permite mostrar todos los errores en pantalla que tenga el formulario en ese momento. Sin esa instruccion, el formulario es invalido, no ejecuta el Submit, pero tampoco se muestran los errores.</p>
<h2 id="mostrar-errores-en-pantalla">Mostrar errores en pantalla</h2>
<p>El manejo de los errores es importante, debemos proporcionar información exacta al usuario cuando ocurre un error.</p>
<p>Hay varios formas de mostrar un error en el control, cuando no se cumple una condición, por ejemplo, en el caso del nombre del producto tenemos dos reglas</p>
<ul>
<li>Requerido</li>
<li>Ancho mínimo de 3 caracteres</li>
</ul>
<p>Podemos implementarlos con el <strong>*ngIg</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"name"</span>
       <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
       <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>
       <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre del producto"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"productForm.controls['name'].getError('required')"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
    Este campo es requerido.
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"productForm.controls['name'].getError('minlength')"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
    Este campo requiere al menos 3 caracteres.
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<p>Como se puede observar accedemos al error especifico usando el método <strong>getError</strong> de control.</p>
<p>Si probamos el cambio, veremos el primer error, cuando el campo esta vecío, al agregar el primer caracter, se oculta el primero error y se muestra el segundo, y hasta que agregamos el 3 caracter, el control no mostrará ningún error.</p>
<p>Un inconveniente de usar esta forma es que el error se muestra de entrada cuando vamos a agregar un nuevo producto, porque el campo está vacío, podriamos agregra una condición más:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"productForm.controls['name'].getError('required')
      &amp;&amp; productForm.controls['name'].touched"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
</div></code></pre>
<p>Esto empieza a ser tedioso, imagina un formulario con 10 campos, y cada campo con almenos 1 o dos validaciones, y uno que otro con más de 4 validaciones. Definitivamente no es para nada eficiente.</p>
<h2 id="m%C3%A9todos-de-ayuda-de-errores">Métodos de ayuda de Errores</h2>
<p>Otra forma es crear método que ayuden a detectar errores, por ejemplo</p>
<pre class="hljs"><code><div>isValidField(field: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.productForm.controls[field].errors 
  &amp;&amp; <span class="hljs-keyword">this</span>.productForm.controls[field].touched;
}
</div></code></pre>
<p>Luego podemos cambiar nuestro template a algo mas sencillo:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isValidField('name')"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
    Este campo es requerido.
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<p>Pero esto no esta del todo bien, porque no estamos evaluando un error específico, por lo tanto no vamos a poder mostrar un mensaje adecuado.</p>
<p>Creemos otro método:</p>
<pre class="hljs"><code><div>getFieldError(field: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> {

  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.productForm.controls[field]) {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
  <span class="hljs-keyword">const</span> errors = <span class="hljs-keyword">this</span>.productForm.controls[field].errors || {};
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> errors) {
    <span class="hljs-keyword">if</span> (errors.hasOwnProperty(key)) {
      <span class="hljs-keyword">switch</span> (key) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'required'</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-string">'This field is required'</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'minlength'</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-string">`The minimum length is <span class="hljs-subst">${errors[key].requiredLength}</span>`</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">'maxlength'</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-string">`The maximum length is  <span class="hljs-subst">${errors[key].requiredLength}</span>`</span>;
        <span class="hljs-keyword">default</span>:
          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      }
    }
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</div></code></pre>
<p>Ahora en lugar de dos <strong>span</strong> podemos tener uno solo con el nuevo método.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"name"</span>
       <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>
       <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>
       <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre del producto"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isValidField('name')"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
    {{ getFieldError('name')}}
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<p>Esto está un poco mejor pero aún necesita trabajo, porque podemos dejar por fuera de las validaciones algun tipo de eror, por ejemplo el valor min que hemos establecido en precio</p>
<pre class="hljs"><code><div>price:    [ <span class="hljs-number">0</span>, [Validators.required, Validators.min(<span class="hljs-number">0</span>)]],
</div></code></pre>
<p>Si agregamos un valor negativo, no vemos el error. Tendríamos que agregar oto CASE</p>
<pre class="hljs"><code><div><span class="hljs-keyword">case</span> <span class="hljs-string">'min'</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">`The minimum value is <span class="hljs-subst">${errors[key].min}</span>`</span>;
</div></code></pre>
<p>Esto lo mejoraremos con un servicio de validaciones más adelante.</p>
<h2 id="formularios-din%C3%A1micos">Formularios Dinámicos</h2>
<p>No sabemos de antemano cuantos elementos tendrá el formulario, podemos agregar controles dinamicamente y cada control debe de tener ciertas validaciones.</p>
<p>Para nuestro formulario dinámico iniciemos creando el código TS.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> DinamicPageComponent {

  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> formBuilder: FormBuilder</span>) { }

  <span class="hljs-keyword">public</span> form = <span class="hljs-keyword">this</span>.formBuilder.group({
    name: [<span class="hljs-string">''</span>, [Validators.required, Validators.minLength(<span class="hljs-number">3</span>)]],
    favoriteGames: <span class="hljs-keyword">this</span>.formBuilder.array([
      [<span class="hljs-string">'Metal Gear'</span>, Validators.required],
      [<span class="hljs-string">'Final Fantasy'</span>, Validators.required],
      [<span class="hljs-string">'The Witcher'</span>, Validators.required]
    ])
  }); 

  <span class="hljs-keyword">get</span> favoriteGames() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.form.get(<span class="hljs-string">'favoriteGames'</span>) <span class="hljs-keyword">as</span> FormArray;
  }
  
  onSubmit() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.form.invalid) {
      <span class="hljs-keyword">this</span>.form.markAllAsTouched();
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">this</span>.form.reset();
  }
}
</div></code></pre>
<p>En el template enlazamos el formulario:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"form"</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"onSubmit()"</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">"off"</span>&gt;</span>
</div></code></pre>
<p>Y enlazamos los campos iniciales, el Name:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"name"</span>
<span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>
<span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre de la persona"</span>&gt;</span>
</div></code></pre>
<p>Para la parte dinámica, tenemos originalmente este HTML</p>
<pre class="hljs"><code><div><span class="hljs-comment">&lt;!-- Lista de Juegos Favoritos --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mb-3 row"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-sm-3 col-form-label"</span>&gt;</span>Favoritos<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-sm-9"</span> &gt;</span>

        <span class="hljs-comment">&lt;!-- Duplicar este bloque por cada elemento dinamico--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mb-1"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input-group"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-outline-danger"</span>
                        <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>&gt;</span>
                  Eliminar
              <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
               Este campo es requerido
            <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Primero necesitamos</p>
<p>Y luego agregar un ngFor para renderizar los elementos de nuestro arreglo de controles, es decir <strong>favoriteGames</strong> de nuestro <strong>form</strong> para ellos usaremos nuestro metodo <strong>get favoriteGames</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-sm-9"</span> <span class="hljs-attr">formArrayName</span>=<span class="hljs-string">"favoriteGames"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Duplicar este bloque por cada elemento dinamico--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mb-1"</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let favorite of favoriteGames.controls; let i = index"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input-group"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> [<span class="hljs-attr">formControlName</span>]=<span class="hljs-string">"i"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-outline-danger"</span>
                    <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>&gt;</span>
              Eliminar
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
           Este campo es requerido
        <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Notar que usamos un ngFor para renderizar dinamicamente los controles de nuestro array</p>
<p>Luego vemos que para acceder al nombre del control, usamos el index del arreglo</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> [<span class="hljs-attr">formControlName</span>]=<span class="hljs-string">"i"</span>
</span></div></code></pre>
<p>Con esto ya estaremos renderizando 3 controles, pero aun falta trabajar con las validaciones dinámicas.</p>
<h2 id="validaciones-din%C3%A1micas">Validaciones Dinámicas</h2>
<p>Vamos a copiar (por ahora) las funciones que usamos en el <strong>BasicPageComponent</strong> y agregaremos un método más para validar los controles de un array.</p>
<pre class="hljs"><code><div>isValidField(field: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.form.controls[field].errors 
    &amp;&amp; <span class="hljs-keyword">this</span>.form.controls[field].touched;
  }

  isValidFieldArray(formArray: FormArray, index: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">return</span> formArray.controls[index].errors 
    &amp;&amp; formArray.controls[index].touched;
  }

  getFieldError(field: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> {

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.form.controls[field]) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">const</span> errors = <span class="hljs-keyword">this</span>.form.controls[field].errors || {};

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> errors) {
      <span class="hljs-keyword">if</span> (errors.hasOwnProperty(key)) {
        <span class="hljs-keyword">switch</span> (key) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">'required'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">'This field is required'</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">'minlength'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">`The minimum length is <span class="hljs-subst">${errors[key].requiredLength}</span>`</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">'maxlength'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">`The maximum length is  <span class="hljs-subst">${errors[key].requiredLength}</span>`</span>;
          <span class="hljs-keyword">case</span> <span class="hljs-string">'min'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">`The minimum value is <span class="hljs-subst">${errors[key].min}</span>`</span>;
          <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
</div></code></pre>
<p>Para validar nuestro campo Name, el cual no es un arreglo usamos el método anterior</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-sm-9"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"name"</span>
           <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>
           <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Nombre de la persona"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isValidField('name')"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
           {{ getFieldError('name') }}
    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Y en el caso del error que se renderiza en el arreglo, usamos el nuevo método, le pasamos el favoriteGames y el index para indicar que elemento del array queremos validar.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isValidFieldArray(favoriteGames, i)"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
    Este campo es requerido.
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<p>Por el momento dejaremos el mensaje de error tal como se ve en la plantilla.</p>
<h2 id="eliminar-controles-din%C3%A1micos">Eliminar Controles dinámicos</h2>
<p>Simplemente basta con remover el control del arreglo</p>
<p>TS:</p>
<pre class="hljs"><code><div>onDelete(index: <span class="hljs-built_in">number</span>) {
  <span class="hljs-keyword">this</span>.favoriteGames.removeAt(index);
}
</div></code></pre>
<p>Y luego lo usamos en el template.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"onDelete(i)"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-outline-danger"</span>
          <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>&gt;</span>
    Eliminar
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<h2 id="agregar-controles-din%C3%A1micos">Agregar Controles dinámicos</h2>
<p>Aca también necesitamos un método para agregar, pero dado que tenemos en el template un input Box para capturar el contenido del control, demos agregar algo al template:</p>
<p>El template luce de esta forma:</p>
<br/>
<img src="./imagenes/reaciveFormsApp02.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<p>La idea es que al presionar Agregar Favorito, se agregue un control mas a nuestro arreglo y este sea renderizado.</p>
<p>Dado que necesitamos validar que el usuario por lo menos agregue aldo de información en el Input, podemos hacer un Control Reactivo aislado.</p>
<p>Es decir, en el TS agregamos esto</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> newFavorite: FormControl = <span class="hljs-keyword">new</span> FormControl(<span class="hljs-string">''</span>, [Validators.required, Validators.minLength(<span class="hljs-number">3</span>)]);
</div></code></pre>
<p>Adicionalmente creamos un <strong>onAdd</strong> método:</p>
<pre class="hljs"><code><div>onAdd() {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.newFavorite.invalid) {
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-keyword">const</span> newGameName = <span class="hljs-keyword">this</span>.newFavorite.value;
  <span class="hljs-keyword">this</span>.favoriteGames.push(<span class="hljs-keyword">this</span>.formBuilder.control(newGameName, Validators.required));
  <span class="hljs-keyword">this</span>.newFavorite.reset();
}
</div></code></pre>
<p>Y este control lo enlazamos en nuestro template junto con la acción de Agregar un favorito.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input-group"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> [<span class="hljs-attr">formControl</span>]=<span class="hljs-string">"newFavorite"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>
           <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"Agregar favorito"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"onAdd()"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-outline-primary"</span>
            <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>&gt;</span>
        Agregar favorito
    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Dado que es un control independiente, necesita su propio validador, podemos crear esta funcion:</p>
<pre class="hljs"><code><div>isValidNewFavorite(): <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">null</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.newFavorite.invalid 
    &amp;&amp; <span class="hljs-keyword">this</span>.newFavorite.touched;
  }
</div></code></pre>
<p>Y agregamos el span del control:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isValidNewFavorite()"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
    Valor incorrecto
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<p>De esta forma ya tenemos un formulario dinámico.</p>
<br/>
<img src="./imagenes/reaciveFormsApp03.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<p>Más información sobre formularios reactivos</p>
<p><a href="https://angular.io/guide/reactive-forms">https://angular.io/guide/reactive-forms</a></p>
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-validaciones">Nueva Sección: Validaciones</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>¿Qué veremos en esta sección?</p>
<p>Este es un breve listado de los temas fundamentales:</p>
<ul>
<li>Validaciones manuales</li>
<li>Validaciones asíncronas</li>
<li>Validar contra expresiones regulares</li>
<li>Separar la lógica de validaciones</li>
<li>Estado del formulario</li>
<li>Mensajes de error personalizados</li>
</ul>
<p>Más adelante tendremos una sección de directivas, la cual es un excelente complemento para el manejo de errores de formularios reactivos, pero luego llegarán a ella.</p>
<h2 id="formcontrol-en-radio-buttons">FormControl en Radio Buttons</h2>
<p>Supongamos que tenemos el siguiente formulario</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> form: FormGroup =  <span class="hljs-keyword">this</span>.forBuilder.group({
    gender : [<span class="hljs-string">'M'</span>, Validators.required],
    wantsNotifications: [<span class="hljs-literal">true</span>, Validators.required],
    termsAndConditions: [<span class="hljs-literal">false</span>, Validators.requiredTrue]
  });
</div></code></pre>
<p>El <strong>gender</strong> es un string M|F   (Masculino | Femenino), el formulario HTML es representado como un <strong>RadioButton</strong></p>
<p><strong>wantsNotifications</strong> es un true|false, es un checkbox pero se le agrega la clase <strong>form-switch</strong> de bootsrap para convertirlo en un slice button.</p>
<p>Finalmente <strong>termsAndConditions</strong> es un checkbox normal con valores tue|False</p>
<br/>
<img src="./imagenes/reaciveFormsApp04.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<p>Para los <strong>ReadioButtons</strong>, usaremos el mismo FormControlName</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-check"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"gender"</span>
           <span class="hljs-attr">class</span>=<span class="hljs-string">"form-check-input"</span>
           <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span>
           <span class="hljs-attr">value</span>=<span class="hljs-string">"M"</span>
           <span class="hljs-attr">id</span>=<span class="hljs-string">"radioMasculino"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-check-label"</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"radioMasculino"</span>&gt;</span>
      Masculino
    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-check"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"gender"</span>
           <span class="hljs-attr">class</span>=<span class="hljs-string">"form-check-input"</span>
           <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span>
           <span class="hljs-attr">value</span>=<span class="hljs-string">"F"</span>
           <span class="hljs-attr">id</span>=<span class="hljs-string">"radioFemenino"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-check-label"</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"radioFemenino"</span>&gt;</span>
      Femenino
    <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>En el caso del <strong>wantsNotifications</strong> y <strong>termsAndConditions</strong> se usan normalmente sus FormControlName respectivos.</p>
<p>Con respecto a las validaciones agregamos las funciones que hemos venido ausando anteriormente, únicamente al campo de las Términos y Condiciones necesita validación.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span>  *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isValidField('termsAndConditions')"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
   {{getFieldError('termsAndConditions')}}
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<p>Al hacer submit del formulario veremos el siguiente objeto:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"gender"</span>: <span class="hljs-string">"F"</span>,
    <span class="hljs-attr">"wantsNotifications"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">"termsAndConditions"</span>: <span class="hljs-literal">true</span>
}
</div></code></pre>
<p>NOTA: Si nuestro backend espera únicamente un objeto con el <strong>gender</strong> y el <strong>wantsNotifications</strong> dejando del lado del frontEnd la responsabilidad de acetpar los términos y condiciones, no debemos enviar este objeto, para ello podemos eliminar ese valor del request</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { termsAndConditions, ... newFormValue } = <span class="hljs-keyword">this</span>.form.value;
</div></code></pre>
<p>En este punto podemos enviar unicamente el <strong>newFormValue</strong></p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"gender"</span>: <span class="hljs-string">"F"</span>,
    <span class="hljs-attr">"wantsNotifications"</span>: <span class="hljs-literal">true</span>
}
</div></code></pre>
<h2 id="formulario-de-registro">Formulario de Registro</h2>
<p>Este es un típico formulario de registro, los errores se muestran en su estado inicial porque no hemos enlazado ningún formControl y no hemos realizados las valiadciones requeridas en cada campo.</p>
<br/>
<img src="./imagenes/reaciveFormsApp05.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 70%; height: auto; border: 1px solid black" />
<p>Lo primero es inyectar el FormBuilder y luego crear nuestro Form</p>
<pre class="hljs"><code><div><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> formBuilder: FormBuilder</span>) { }

  <span class="hljs-keyword">public</span> form = <span class="hljs-keyword">this</span>.formBuilder.group({
    name: [<span class="hljs-string">''</span>,[Validators.required, Validators.minLength(<span class="hljs-number">6</span>)]],
    email: [<span class="hljs-string">''</span>,[Validators.required]],
    userName: [<span class="hljs-string">''</span>,[Validators.required, Validators.minLength(<span class="hljs-number">6</span>)]],
    password: [<span class="hljs-string">''</span>,[Validators.required, Validators.minLength(<span class="hljs-number">8</span>)]],
    password_confirmation: [<span class="hljs-string">''</span>,[Validators.required]],
  });
</div></code></pre>
<p>Estas son las validaciones básicas, vamos a agregar otras validaciones manuales, ademas, usaremos un servicio para proveer las validaciones.</p>
<p>Luego debemos importar el <strong>ReactiveFormsModule</strong>  en el *<em>AuthModule</em> para poder usar la etiquetas especiales de los ReactiveForms en nuestro Html</p>
<p>Luego enlazamos nuestro forms en el template, tanto a nivel de group como a nivel de controles.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"form"</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"onSubmit()"</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">"off"</span>&gt;</span>
</div></code></pre>
<h2 id="validator-functions">Validator Functions</h2>
<p>Podemos crear nuestra propias funciones de validaciones y reusarlas en cualquier formulario. Para ello podemos crearlas en nuestro módulo Shared para que estén disponibles. Podemos crearlas como un servicio o bien como simples funciones, este útimo será la forma en como implementaremos la siguiente validación.</p>
<p>Imagina que nos han dado  el siguiente requerimiento, <strong>El userName no puede ser ninguno de estos valores: admin, Administrator, root</strong></p>
<p>Podemos pensar en una función que reciva dos cosas</p>
<ul>
<li>Un Valor que no debe de tomar el control</li>
<li>El control en sí</li>
</ul>
<p>El parámetro <strong>valor</strong> podríamos cambiarlo por un arreglo, de esa forma podemos aceptar en una sola llamada a la función varios valores.</p>
<p>Y como estamos usando los Validators de Angular, podemos retornar de una vez un objeto de tipo <strong>ValidationErrors</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
 * @description
 * Defines the map of errors returned from failed validation checks.
 *
 * @publicApi
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> ValidationErrors = {
    [key: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;
};
</div></code></pre>
<p>La función luce de la siguiente forma:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { FormControl, ValidationErrors } <span class="hljs-keyword">from</span> <span class="hljs-string">"@angular/forms"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> cantbeThisValue = (control : FormControl, value: <span class="hljs-built_in">string</span>[]) : <span class="hljs-function"><span class="hljs-params">ValidationErrors</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (value.map ( <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.toLowerCase().tim()).includes(control.value.toLowerCase().trim())) {
        <span class="hljs-keyword">return</span> {
            cantbeThisValue: <span class="hljs-literal">true</span>
        }
    }
  <span class="hljs-keyword">return</span> {};
}
</div></code></pre>
<p>Dado que recibimos un arreglo de valores que el control no debe aceptar, debemos tratar cada posible valor del arreglo y transformarlo a un valor que pueda ser comparado, es decir aplicamos un <strong>map</strong> para eliminar espacions en blanco y para pasarlo a minúsculas. Lo mismo hacemos con el valor del control</p>
<p>Si el valor del control está incluid en el arreglo, entonces generamos un objeto de tipo <strong>ValidationErrors</strong> que no es más que un key:value.</p>
<pre class="hljs"><code><div>return {
    cantbeThisValue: <span class="hljs-literal">true</span>
}
</div></code></pre>
<p>NOTA: Si retornamo un objeto vacío <strong>{}</strong> Angular no lo incluye en la lista de errores.</p>
<p>Luego debemos usar esta función, y lo haremos de esta forma: Al momento de crear nuestro <strong>form</strong> con el <strong>FormBuilder</strong> al especificar el campo <strong>userName</strong> podemos contruirlo de esta forma</p>
<pre class="hljs"><code><div>userName: [<span class="hljs-string">''</span>, 
  [ Validators.required, 
    Validators.minLength(<span class="hljs-number">5</span>),
    <span class="hljs-function">(<span class="hljs-params">control: FormControl</span>) =&gt;</span> cantbeThisValue(control, [<span class="hljs-string">'admin'</span>, <span class="hljs-string">'administrator'</span>, <span class="hljs-string">'root'</span>])
  ]
],
</div></code></pre>
<p>La parte que nos interesa en esta sección es esta línea</p>
<pre class="hljs"><code><div>(control: FormControl) =&gt; cantbeThisValue(control, [<span class="hljs-string">'admin'</span>, <span class="hljs-string">'administrator'</span>, <span class="hljs-string">'root'</span>])
</div></code></pre>
<p>Dado que nuestra función recibe como primer argumento el Control, debemos usar una función anónima para pasar el control.</p>
<p>Normalmente, si la función no recibe parámetro adicionales, podemos hacer una llamada de este tipo</p>
<pre class="hljs"><code><div>email: [<span class="hljs-string">''</span>, 
  [ Validators.required, 
    isValidEmail()
  ]
],
</div></code></pre>
<p>Como se observa, <strong>isValidEmail</strong> no se le pasa ningún parámetro, ya que implicitamente el control se pasa como primer argumento. Dentro de nuestra función isValidEmail, vamos a tener acceso al control y hacer la validación requerida.</p>
<p>Regresando a nuesto ejemplo, dado que debemos explicitamente enviar el <strong>Control</strong> <em>userName</em> y a la vez los valores no permitidos, debemos usar la función anónima para pasar el control en sí.</p>
<p>Con estos cambios, podemos probar las validaciones, si escribimos <strong>admin</strong> en el input UserName, veremos que el formulario es Inválido y el objeto Errors tiene este valor</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"cantbeThisValue"</span>: <span class="hljs-literal">true</span>
}
</div></code></pre>
<p>Luego podemos modificar la función <strong>getFieldError</strong> para agregar un nuevo Key <strong>cantbeThisValue</strong></p>
<pre class="hljs"><code><div>getFieldError(field: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> {

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.productForm.controls[field]) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">const</span> errors = <span class="hljs-keyword">this</span>.productForm.controls[field].errors || {};

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> errors) {
      <span class="hljs-keyword">if</span> (errors.hasOwnProperty(key)) {
        <span class="hljs-keyword">switch</span> (key) {
          <span class="hljs-keyword">case</span> <span class="hljs-string">'cantbeThisValue'</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-string">'Incorrect value'</span>;
          <span class="hljs-comment">// Other Keys here!</span>
          <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
      }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }
}
</div></code></pre>
<h2 id="validaci%C3%B3n-del-email">Validación del Email</h2>
<p>Podemos usar expresiones regulares para validar ciertos patrones, por ejemplo, creamos la siguiente constante en nuestro archivo validators.ts</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> emailPattern: <span class="hljs-built_in">string</span> = <span class="hljs-string">"^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$"</span>;
</div></code></pre>
<p>Luego agregamos la validación al campo Email:</p>
<pre class="hljs"><code><div>email: [<span class="hljs-string">''</span>, [Validators.required, Validators.pattern(CustomValidators.emailPattern)]],
</div></code></pre>
<p>En el caso de no cumplir con el Pattern indicado, vamos a obtener el siguiente error:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"pattern"</span>: {
    <span class="hljs-attr">"requiredPattern"</span>: <span class="hljs-string">"^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$"</span>,
    <span class="hljs-attr">"actualValue"</span>: <span class="hljs-string">"email"</span>
  }
}
</div></code></pre>
<p>También podríamos crear nuestra propia función y retornar un objeto con mejor información.</p>
<p>NOTA: he realizado un cambio en el import para permitir acceder a las funciones de nuestro validators.ts, con <strong>CustomValidators.emailPattern</strong> o <strong>CustomValidators.cantbeThisValue</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> CustomValidators <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../shared/validators/validators'</span>;
</div></code></pre>
<h2 id="servicio-de-validaciones">Servicio de Validaciones</h2>
<p>Vamos a crear una carpeta <strong>services</strong> en el directorio <strong>shared</strong> y dentro de este nuevo directorio creamos el archivo: <strong>validator.service.ts</strong> creamos un nuevo servicio manualmente,</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Injectable</span>({providedIn: <span class="hljs-string">'root'</span>})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ValidatorService {
    
}
</div></code></pre>
<p>Y dentro de este servicio vamos a pegar todas las funciones validadoras que hemos estado usando en las secciones anteriores.</p>
<ul>
<li>El email pattern</li>
<li>El método cantbeThisValue</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> cantbeThisValue = (control : FormControl, value: <span class="hljs-built_in">string</span>[]) : <span class="hljs-function"><span class="hljs-params">ValidationErrors</span> =&gt;</span> {}
</div></code></pre>
<ul>
<li>Las funcines isValidField</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> isValidField(form: FormGroup, field: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">null</span> {}
</div></code></pre>
<ul>
<li>El isValidField, en este caso tenemos que pasar el FormGroup</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> isValidField(form: FormGroup, field: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">null</span> {}
</div></code></pre>
<ul>
<li>El isValidArray</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> isValidFieldArray(formArray: FormArray, index: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">null</span> {}
</div></code></pre>
<ul>
<li>Y el GetFieldError</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> getFieldError(form: FormGroup, field: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span> {}
</div></code></pre>
<p>Luego debemos de hacer un par de cambios en el componente, en lugar de usar una función validadora local o importada de nuestro validator.ts ahora debemos inyectar el servicio</p>
<pre class="hljs"><code><div><span class="hljs-keyword">constructor</span>(<span class="hljs-params">
    <span class="hljs-keyword">private</span> formBuilder: FormBuilder,
    <span class="hljs-keyword">private</span> validatorSercice: ValidatorService</span>) { }
</div></code></pre>
<p>Removemos el Import anterior</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> CustomValidators <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../shared/validators/validators'</span>;
</div></code></pre>
<p>Y donde nos marque error, usamos el servicio. Es decir en lugar de <strong>CustomValidators.[METHOD]</strong> lo reemplazamos por <strong>this.validatorSercice.[METHOD]</strong></p>
<p>Debemos de mantener algunos de los metodos anteriores en nuestro componentes, porque estos siguen siendo usados por el template, por ejemplo el <strong>isValidField</strong> y el <strong>getErrorMessage</strong> pero estos métodos ahora llaman el servicio en lugar de hacer la validación localmente:</p>
<pre class="hljs"><code><div>  isValidField(field: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.validatorSercice.isValidField(<span class="hljs-keyword">this</span>.form, field );
  }

  getErrorMessage(field: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.validatorSercice.getFieldError(<span class="hljs-keyword">this</span>.form, field );
  }
</div></code></pre>
<p>Revisemos nuevamente el proceso de validación completo, todo inicial en el componente, quien define un <strong>FormGroup</strong> por ejemplo para el <strong>UserName</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> form = <span class="hljs-keyword">this</span>.formBuilder.group({
  <span class="hljs-comment">// Otros campos se definen aca  </span>
  userName: [<span class="hljs-string">''</span>, 
    [
      <span class="hljs-comment">// Otras validaciones se definen aca</span>
       (control: FormControl) =&gt; <span class="hljs-keyword">this</span>.validatorSercice.cantbeThisValue(control, [<span class="hljs-string">'admin'</span>, <span class="hljs-string">'administrator'</span>, <span class="hljs-string">'root'</span>])
    ]
  ],
});
</div></code></pre>
<p>Luego el Template hace el Enlace (primeramente a nivel del FormGroup) y luego con el campo:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"userName"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- otras propedades del input --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isValidField('userName')"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
     Nombre de usuario no permitido.
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<p>Cuando el usuario escribe <strong>admin</strong> en el userName, al perder el focus se aplica las validaciones en este caso manda a llamar el <strong>cantbeThisValue</strong> este valor no cumple con la regla, por lo tanto el campo UserName tiene un error.</p>
<p>Dado que el campo tiene un error, la llamada desde el template al metodo <strong>isValidField('userName')</strong> hace que el <strong>span</strong> con el texto <em>Nombre de usuario no permitido.</em> sea visible al usuario.</p>
<p>Una vez aplicadas todos los cambios en el template veremos un formulario sin mensajes de errores y listo para aceptar datos</p>
<br/>
<img src="./imagenes/reaciveFormsApp06.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" />
<p>Dado que con estos datos el formulario es válido, al hace el submit, enviaríamos los siguientes datos al server:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Leonel Messi"</span>,
    <span class="hljs-attr">"email"</span>: <span class="hljs-string">"messi@argentina.com"</span>,
    <span class="hljs-attr">"userName"</span>: <span class="hljs-string">"TheGoat"</span>,
    <span class="hljs-attr">"password"</span>: <span class="hljs-string">"12345678"</span>,
    <span class="hljs-attr">"password_confirmation"</span>: <span class="hljs-string">"12345678"</span>
}
</div></code></pre>
<p>NOTA: Aún hace falta implementar los validadores para los passwords.</p>
<h2 id="validadores-as%C3%ADncronos">Validadores Asíncronos</h2>
<p>Hasta el momento, todos los validadores que hemos agregado son Síncronos, al llamarlos, esperamos una respuesta y el flujo continuará cuando regresan una respuesta, usualmente un objeto. Estos validadores síncronos los hemos colocado coom segundo argumento, este segundo argument puede ser un arreglo de validadores o un único validador.</p>
<p>Pero este formato acepta un tercer agrumentos, también un único validador o un arreglo de validadores, con la diferencia que estos son <strong>Asíncronos</strong>, es decir regresaran una promesa o un observable.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> formName = <span class="hljs-keyword">this</span>.formBuilder.group({
    fieldName: [<span class="hljs-string">''</span>, [Validadores Síncronos], [Validadores Asíncronos]]
  });
</div></code></pre>
<p>Para crear un Validador Asíncrono debemos implementar la interfaz <strong>AsyncValidator</strong>  y debemos definir el método <strong>Validate</strong>, el método <strong>registerOnValidatorChange</strong> es opcional.</p>
<pre class="hljs"><code><div>validate(control: AbstractControl&lt;<span class="hljs-built_in">any</span>, <span class="hljs-built_in">any</span>&gt;): <span class="hljs-built_in">Promise</span>&lt;ValidationErrors | <span class="hljs-literal">null</span>&gt; | Observable&lt;ValidationErrors | <span class="hljs-literal">null</span>&gt; {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Method not implemented.'</span>);
}
</div></code></pre>
<p>Este método acepta un control, y retorna ya sea un Promise o un Observable. Vamos a retornar observables en nuestro caso.</p>
<p>Las validaciones asyncronas, colocan el formulario en un estado de <strong>pending</strong> es decir, que existen, en este caso, validaciones que se están ejecutando. Para ver ese estado tendriamos que retrazar la ejecución del validador a propósito (delay) para poder observar este efecto.</p>
<p>Otro ejemplo sería implementar una validacion que reuqire hacer alguna verificación en el backend, mientras no se complete dicha operación, el formulario estaría en estado <strong>Pending</strong></p>
<p>Implementemos un Validador de Email, que consulte si el email ya ha sido registrado por otro usuario. Dado que no tenemos un backend vamos a crear un Fake httpCall.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { AbstractControl, AsyncValidator, ValidationErrors } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/forms'</span>;
<span class="hljs-keyword">import</span> { Observable, of } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs'</span>;

<span class="hljs-meta">@Injectable</span>({providedIn: <span class="hljs-string">'root'</span>})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AsyncEmailValidator <span class="hljs-keyword">implements</span> AsyncValidator {
    
    <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) { }

    validate(control: AbstractControl): Observable&lt;ValidationErrors | <span class="hljs-literal">null</span>&gt; {
        <span class="hljs-keyword">const</span> email = control.value;

        <span class="hljs-keyword">const</span> httpCallObservable = <span class="hljs-keyword">new</span> Observable&lt;ValidationErrors | <span class="hljs-literal">null</span>&gt;<span class="hljs-function">(<span class="hljs-params"> (<span class="hljs-params">suscriber</span>) =&gt; {
            <span class="hljs-keyword">if</span> (<span class="hljs-params">email === 'example@domain.com'</span>) {
                suscriber.next(<span class="hljs-params">{ emailTaken: <span class="hljs-literal">true</span> }</span>);
                suscriber.complete(<span class="hljs-params"></span>);
                <span class="hljs-keyword">return</span>;
            }

            suscriber.next(<span class="hljs-params"><span class="hljs-literal">null</span></span>);
            suscriber.complete(<span class="hljs-params"></span>);
        }</span>)

        <span class="hljs-params">return</span> <span class="hljs-params">httpCallObservable</span>;
    }
}
</span></div></code></pre>
<p>En este código, por medio de un <strong>new Observable</strong> creamos un fake HTTP que simula una validación en el backend. Si el email <strong>example@domain.com</strong> es proporcionado por el Usuario, el Observable emite un <strong>{ emailTaken: true }</strong> de lo contrario emite un <strong>null</strong></p>
<p>Ahora es momento de usar nuestro validador, dado que lo hemos inyectado con root <code>@Injectable({providedIn: 'root'})</code> lo cual lo hace accesible desde cualquier parte de nuestra app, podemos instanciarlos como <code>new AsyncEmailValidator()</code> y inyectarlos en el constructor.</p>
<p>Usemos el NEW</p>
<pre class="hljs"><code><div>email: [<span class="hljs-string">''</span>, 
  [Validators.required, Validators.pattern(<span class="hljs-keyword">this</span>.validatorSercice.emailPattern)], 
  [<span class="hljs-keyword">new</span> AsyncEmailValidator()]],
</div></code></pre>
<p>Insertamos un segundo arreglo con el <strong>new AsyncEmailValidator()</strong>, dado que ya hemos agregado un primero arreglo de validadoes síncronos, demos agregar los <strong>Async</strong> como Arreglo.</p>
<p><strong>Si todos los validadoes del primer grupo se cumplen, se hace las valiadciones de los Async.</strong></p>
<p>Si agregamos el email <strong>example@domain.co</strong> se dispara una primera vez el Async validator, porque ese email es válido segund el Pattern, que permite entre 2 y 4 caracteres luego del punto separador del dominio  <strong>[a-z]{2,4}$</strong>  Cuando se hace esta primer llamada ASYNC a nuestro nuevo validador, este retorna un null, pero tan pronto completamos el email <strong>example@domain.com</strong> se llama nuevamente el validador ASYNC y esta vez retorna:</p>
<pre class="hljs"><code><div>{ <span class="hljs-attr">"emailTaken"</span>: <span class="hljs-literal">true</span> }
</div></code></pre>
<p>Para mostrar el mensaje en pantalla, debemos llamar el <strong>getErrorMessage</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isValidField('email') "</span><span class="hljs-attr">class</span>=<span class="hljs-string">"form-text text-danger"</span>&gt;</span>
    {{ getErrorMessage('email') }}
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<p>Pero debemos agregar el índice <strong>emailTaken</strong> en nuestro Switch del método <strong>getErrorMessage</strong> del servicio: <strong>SyncValidatorService</strong></p>
<pre class="hljs"><code><div>    <span class="hljs-keyword">case</span> <span class="hljs-string">'emailTaken'</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">`The email is already taken`</span>;
</div></code></pre>
<p>Con estos cambios ya hemos implementado un Validador Asíncrono y hemos mostrado el error correspondiente en pantalla.</p>
<h2 id="validar-dos-campos-diferentes">Validar dos campos diferentes</h2>
<p>Esta es una situación particular, anteriormente aplicamos validadores a nivel de cada campo, pero en este caso no podemos aplicarlo a un solo campo, porque solo tenemos acceso al control al que aplicamos el validador.</p>
<p>Lo más transparente es subir un nivel, para poder acceder a todos los campos del formulario al momento de la validación, es decir que en lugar de pasar implícitamente un CAMPO en específico, pasamos todo el formulario, y luego podemos comparar los campos que necesitemos.</p>
<p>LA validación de <strong>passwords</strong> iguales es un ejemplo claro.</p>
<p>Necesitamos dos cosas</p>
<ul>
<li>Un lugar adecuado que tenga acceso a todos los campos del formulario para usar la función Validadora.</li>
<li>Una función validadora que compare dos valores y retorne un ValidationError si son iguales</li>
</ul>
<p>Primero, debemos colocar este validador siempre dentro de la definición del <strong>Form</strong> una vez que definimos los campos y sus validadores, como segundo parámetro podemos pasar un arreglo de funciones validadoras, en este caso se aplicaran a todo el formulario, o dicho de otra forma, estas funciones reciben implícitamente como argumento el formulario.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> formName = <span class="hljs-keyword">this</span>.formBuilder.group({
    fieldName: [<span class="hljs-string">''</span>, [Validadores Síncronos], [Validadores Asíncronos]]
  },{
    validators: [
      Validators Síncronos Globales
    ]
  });
</div></code></pre>
<p>Si la funcion validadora a nivel de FormGroup recibe el formulario, entonces podemos hacer un validador que acepte dicho formulario, y haga la validación con los campos requeridos, la función en cuestión es la siguiente:</p>
<pre class="hljs"><code><div><span class="hljs-comment">/**
   * Compare two fields of a form and return an error if they are not equal 
   * 
   * @param field1 Field name 1 to compare
   * @param field2 Field name 2 to compare
   * 
   * @returns  A function that compares the values of the fields and 
   * returns null if they are equal or an error if they are not equal
   */</span>
  <span class="hljs-keyword">public</span> fieldsMatch = <span class="hljs-function">(<span class="hljs-params">field1: <span class="hljs-built_in">string</span>, field2: <span class="hljs-built_in">string</span></span>) =&gt;</span> {
        <span class="hljs-keyword">return</span> (formGroup: AbstractControl): ValidationErrors | <span class="hljs-function"><span class="hljs-params">null</span> =&gt;</span> {
            <span class="hljs-keyword">const</span> control1 = formGroup.get(field1);
            <span class="hljs-keyword">const</span> control2 = formGroup.get(field2);
            <span class="hljs-keyword">const</span> fieldValue1 = control1?.value;
            <span class="hljs-keyword">const</span> fieldValue2 = control2?.value;

            <span class="hljs-keyword">if</span> (fieldValue1 === fieldValue2) {
                control2?.setErrors(<span class="hljs-literal">null</span>);
            } <span class="hljs-keyword">else</span> {
                control2?.setErrors({ notEqual: <span class="hljs-literal">true</span> });
            }

            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
    }
}
</div></code></pre>
<p>La Función <strong>fieldsMatch</strong> recibirá implícitamente el formulario desde donde se manda a llamar, adicionalmente debe recibir el nombre de los dos controles que deben compararse.</p>
<p>Pero en este caso <strong>fieldsMatch</strong> retorna otra función, la cual captura el FormGroup.Internamente podemos acceder a los nombres de los campos y a la vez extraer sus valores usando el FormGroup.</p>
<p>Finalmente debemos agregasr el nuevo KEY-ERROR <strong>notEqual</strong> a nuestro servicio <strong>getFieldError</strong></p>
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-selectores-anidados-nueva-app">Nueva Sección: Selectores Anidados, Nueva APP</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>El objetivo de la sección básicamente es aprender a reaccionar cuando información de un formulario cambia, en este caso haremos:</p>
<ul>
<li>Selectores anidados</li>
<li>Llenar selectores desde peticiones HTTP</li>
<li>Encadenamiento de operadores de RXJS</li>
<li>Explicar el por qué la gente dice que TypeScript no es del todo &quot;Type Safe&quot;</li>
</ul>
<p>Creamos una nueva APP</p>
<pre class="hljs"><code><div>ng new 07-selectorsApp --standalone false --routing
</div></code></pre>
<p>Luego creamos un módulo, <strong>Country</strong></p>
<pre class="hljs"><code><div>ng g m country
</div></code></pre>
<p>Creamos la siguiente estructura de directorios, dentro de <strong>src/app/coutnry</strong></p>
<pre class="hljs"><code><div>└── country
    ├── country.module.ts
    ├── interfaces
    ├── pages
    └── services
</div></code></pre>
<p>Luego creamos nuestro primer componente, dentro de <strong>pages</strong></p>
<pre class="hljs"><code><div>ng g c country/pages/selector-page
CREATE src/app/country/pages/selector-page/selector-page.component.css (0 bytes)
CREATE src/app/country/pages/selector-page/selector-page.component.html (28 bytes)
CREATE src/app/country/pages/selector-page/selector-page.component.spec.ts (644 bytes)
CREATE src/app/country/pages/selector-page/selector-page.component.ts (226 bytes)
</div></code></pre>
<p>Renombremos nuestro selector, a <strong>country-selector-page</strong></p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'country-selector-page'</span>,
  templateUrl: <span class="hljs-string">'./selector-page.component.html'</span>,
  styleUrl: <span class="hljs-string">'./selector-page.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SelectorPageComponent {

}
</div></code></pre>
<p>Editemos el <strong>app-routing.module.ts</strong> y carguemos en forma LazyLoading el <strong>CountryModule</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">'selector'</span>,
  loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./country/country.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.CountryModule)
  },
  {
    path: <span class="hljs-string">'**'</span>,
    redirectTo: <span class="hljs-string">'selector'</span>
  }
];
</div></code></pre>
<p>Ahora debeos crear nuestro <strong>country-routing.module.ts</strong>, este pudo haber sido creado con el parametro <strong>--routing</strong> cuando creamos el módulo.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
    {
        path: <span class="hljs-string">''</span>,
        component: SelectorPageComponent
    }
];

<span class="hljs-meta">@NgModule</span>({
    imports: [RouterModule.forChild(routes)],
    exports: [RouterModule]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CountryRoutingModule { }
</div></code></pre>
<p>Otra forma, quizás mejor, es usar childrens, porque es probable que necesitemos agregar mas paginas en nuestro componente Country,</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
    {
        path: <span class="hljs-string">''</span>,
        children: [
            {
                path: <span class="hljs-string">'countries'</span>,
                component: SelectorPageComponent
            },
            {
                path: <span class="hljs-string">'**'</span>,
                redirectTo: <span class="hljs-string">'countries'</span>
            }
        ]
    }
];
</div></code></pre>
<p>Finalmente lo conectamos con nuestro módulo principal <strong>CountryModule</strong> en el imports:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@NgModule</span>({
  declarations: [
    SelectorPageComponent
  ],
  imports: [
    CommonModule,
    CountryRoutingModule
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CountryModule { }
</div></code></pre>
<p>Listo, ya estamso cargando el SelectorPage cuando iniciamos la APP en la ruta: <code>http://localhost:4200/selector</code> o bien <code>http://localhost:4200/selector/countries</code> si aplicamos la segunda solución de mostrar las rutas con <strong>children</strong></p>
<h2 id="selector-page-component">Selector-Page Component</h2>
<p>Creamos un formulario con formBuilder, tal como se indica a continuación:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> formBuilder: FormBuilder</span>) { }
  
  <span class="hljs-keyword">public</span> form: FormGroup = <span class="hljs-keyword">this</span>.formBuilder.group({
    region: [<span class="hljs-string">''</span>, Validators.required]
  });
</div></code></pre>
<p>Enlazamos el <strong>form</strong> en nuestro template y hacemos lo mismo a nivel de campos, enlazado a tres selectores.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mt-3"</span>&gt;</span>Selectores Anidados<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">form</span> [<span class="hljs-attr">formGroup</span>]=<span class="hljs-string">"form"</span> (<span class="hljs-attr">ngSubmit</span>)=<span class="hljs-string">"onSubmit()"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row mb-3"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mb-3"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"form-label"</span>&gt;</span>Region<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"region"</span>
                    <span class="hljs-attr">class</span>=<span class="hljs-string">"form-select form-select-lg"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span>&gt;</span>Seleccione Uno<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
                    <span class="hljs-comment">&lt;!-- Llenar desde  Rest Api--&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</div></code></pre>
<p>Vamos a usar el <code>https://restcountries.com/</code> obetenemos un ejemplo del JSON y usando <strong>Past as JSON code</strong> creamos una interfaz en <code>/country/intergaces/coutrny.interface.ts</code> y agremos un enum para las regiones, en el mismo archivo de interfaces</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">enum</span> Region {
    Africa      = <span class="hljs-string">"Africa"</span>,
    Americas    = <span class="hljs-string">"Americas"</span>,
    Asia        = <span class="hljs-string">"Asia"</span>,
    Europe      = <span class="hljs-string">"Europe"</span>,
    Oceania     = <span class="hljs-string">"Oceania"</span>,
}
</div></code></pre>
<p>Creamos un srevicio:</p>
<pre class="hljs"><code><div>$ ng g s country/services/countries --skip-tests
CREATE src/app/country/services/countries.service.ts (138 bytes)
</div></code></pre>
<p>Y agremos el siguiente código:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> _regions: Region[] = [ 
    Region.Africa, 
    Region.Americas, 
    Region.Asia, 
    Region.Europe, 
    Region.Oceania
  ];

  <span class="hljs-keyword">get</span> regions(): Region[] {
    <span class="hljs-keyword">return</span> [...this._regions];
  }
</div></code></pre>
<p>NOTA: no debemos regresar el <code>this._regions</code> porque esto pasaria la referencia del objeto, y se podría modificar por el que lo consume, por lo tanto lo que retornamos es un nuevo arreglo, el cual se construye a partir de los elementos en <code>...this._regions</code></p>
<p>Ahora inyectamos el servicio en nuestro componente, y como es privado, (el servicio) no podemos accederlo desde el template, por lo tanto hacemos un getter en el componente</p>
<pre class="hljs"><code><div><span class="hljs-keyword">get</span> Regions() {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.countriesServices.regions;
}
</div></code></pre>
<p>Y en el template, llenamos el select:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"region"</span>
    <span class="hljs-attr">class</span>=<span class="hljs-string">"form-select form-select-lg"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span>&gt;</span>Seleccione Uno<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let region of Regions"</span> [<span class="hljs-attr">value</span>]=<span class="hljs-string">"region"</span>&gt;</span>
        {{ region }}
    <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
</div></code></pre>
<h2 id="segundo-selector-aninado">Segundo selector Aninado</h2>
<p>Usaremos una petición http para obtener los paises de la región seleccionada, por lo tanto debemos importar el <strong>HttpClientModule</strong> en el AppModule.</p>
<p>Ademas usaremos una versión más reducida de la interfaz <strong>Country</strong>,</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> CountriesResponse {
    name:         <span class="hljs-built_in">string</span>;
    cca3:         <span class="hljs-built_in">string</span>;
    borders:      <span class="hljs-built_in">string</span>[];
}
</div></code></pre>
<p>Además necesitamos agregar este nuevo método en nuestro servicio:</p>
<pre class="hljs"><code><div>getCountriesByRegion(region: Region): Observable&lt;CountriesResponse[]&gt; {

    <span class="hljs-keyword">if</span> (!region) {
      <span class="hljs-keyword">return</span> of([]);
    }

    <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.baseUrl}</span>/region/<span class="hljs-subst">${region}</span>?fields=name,cca3,borders`</span>;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.get&lt;Country[]&gt;(url)
    .pipe(
      map( <span class="hljs-function"><span class="hljs-params">countries</span> =&gt;</span> countries.map(<span class="hljs-function"><span class="hljs-params">country</span> =&gt;</span> (
        {
          name: country.name.common,
          cca3: country.cca3,
          borders: country.borders ?? []
        }
      ))),
    );
  }
</div></code></pre>
<p>Este método retorna un <code>Observable&lt;CountriesResponse[]&gt;</code> esta interfaz reducida solo define el coutrny name (como string), el cca3 y las fronteras o borders.</p>
<p>Hacemos la petición y luego pasamos esa respuesta por un <strong>pipe</strong>, la función <strong>map</strong> toma cada valor (country) de la respuesta, y lo transforma a la versión reducida.</p>
<p>Ahora necesitamos consumir este servicio en el Componente, donde definimos previamente el primer selector.</p>
<p>Creamos un método <strong>onRegionChange</strong> el cual crea un <strong>Listener</strong> con el <strong>valueChanges</strong> sonre el primer selector, en otras palabras, cuando el selector cambie el valor seleccionado se va a disparar este Evento.</p>
<pre class="hljs"><code><div>onRegionChange(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.form.get(<span class="hljs-string">'region'</span>)?.valueChanges
    .pipe(
      switchMap(<span class="hljs-function"><span class="hljs-params">region</span> =&gt;</span> <span class="hljs-keyword">this</span>.countriesServices.getCountriesByRegion(region))
    ).subscribe(<span class="hljs-function"><span class="hljs-params">countries</span> =&gt;</span> {
      <span class="hljs-keyword">this</span>.countries = countries;
    });
  }
</div></code></pre>
<p>Ahora hace falta llamar este método, y lo haremos en el onInit</p>
<pre class="hljs"><code><div>ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.onRegionChange();
  }
</div></code></pre>
<p>Cuando se inicializa el componente, el OnInit va a llamar el <strong>onRegionChange</strong> quien va a crear el Listener sobre el selector de Regiones.</p>
<p>Agregamos el Template el segundo selector</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"countries.length &gt; 0"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"row mb-3"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-6"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mb-3"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"form-label"</span>&gt;</span>Countries<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"country"</span>
                <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span>&gt;</span>Seleccione el País<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let country of countries"</span> [<span class="hljs-attr">value</span>]=<span class="hljs-string">"country.cca3"</span>&gt;</span>
                    {{ country.name }}
                <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Listo con este cambio podemos ver la lista de paises una vez seleccionamos una región.</p>
<h2 id="tercer-selector-anidado">Tercer Selector Anidado</h2>
<p>Mostraremos los países fronterizos con el país seleccionado en el segundo selector. Dado que la información de las fronteras viene en un arreglo de string, el cual contiene códigos de países, y lo que deseamos mostrar se el nombre del país fronterizo vamos hacer una llamada adicional.</p>
<p>En el Servicio agregamos dos nuevos métodos:</p>
<pre class="hljs"><code><div>getCountryByCode(cca3: <span class="hljs-built_in">string</span>): Observable&lt;CountriesResponse&gt; {
    
  <span class="hljs-keyword">const</span> url = <span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.baseUrl}</span>/alpha/<span class="hljs-subst">${cca3}</span>?fields=name,cca3,borders`</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.httpClient.get&lt;Country&gt;(url).pipe(
    map( <span class="hljs-function"><span class="hljs-params">country</span> =&gt;</span> (
      {
        name: country.name.common,
        cca3: country.cca3,
        borders: country.borders ?? []
      })
  ));
}


getCountryBordersByCode(borders: <span class="hljs-built_in">string</span>[]): Observable&lt;CountriesResponse[]&gt; {
  <span class="hljs-keyword">if</span> (!borders || borders.length === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> of([]);
  }
  <span class="hljs-keyword">const</span> requests: Observable&lt;CountriesResponse&gt;[] = [];
  borders.forEach(<span class="hljs-function"><span class="hljs-params">cca3</span> =&gt;</span> {
    requests.push(<span class="hljs-keyword">this</span>.getCountryByCode(cca3));
  });
  <span class="hljs-keyword">return</span> combineLatest(requests);
}
</div></code></pre>
<p><strong>getCountryByCode</strong>  obtiene el nombre de país, el código y sus fronteras. Este método lo usaremos cuando cambiemos un País del segundo selector.</p>
<p><strong>getCountryBordersByCode</strong> Va a recibir un arreglo de strings[] los cuales son los códigos de países de las fronteras. Este arreglo lo vamos a tomar de la respuesta de <strong>getCountryByCode</strong> (country.borders)  Notar que estamos usando un método diferente, dado que el API (probablemente si) no nos permite hacer consultas mandando un arreglo de códigos, tenemos que enviar tantas peticiones como códigos de fronteras vengan en el arreglo.</p>
<p>Explicación adicional:</p>
<p>Esta línea <code>requests.push(this.getCountryByCode(cca3));</code> no hace la llamada al API, simplemente agregar el request a nuestro arreglo de requests.</p>
<p>El que se encarga de hacer todas las peticiones es <code>combineLatest(requests);</code> esto se hace de una sola vez, todas al mismo tiempo. El método se encargara de gestionarlas y enviar una respuesta final.</p>
<p>Con estos métodos combinados, vamos a obtener la lista de fronteras, pero en forma de Paises, de modo que podremos mostrar el nombre del país fronterizo en lugar del Código.</p>
<p>Una vez implementados estos métodos, agregamos un nuevo Listener en nuestro Componente:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">public</span> borders: CountriesResponse[] = [];


onCountryChange(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.form.get(<span class="hljs-string">'country'</span>)?.valueChanges
    .pipe(
      tap(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.form.get(<span class="hljs-string">'border'</span>)?.reset(<span class="hljs-string">''</span>)),
      tap(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.borders = []),
      filter(<span class="hljs-function"><span class="hljs-params">code</span> =&gt;</span> code !== <span class="hljs-string">''</span>),
      switchMap(<span class="hljs-function"><span class="hljs-params">code</span> =&gt;</span> <span class="hljs-keyword">this</span>.countriesServices.getCountryByCode(code)),
      switchMap(<span class="hljs-function"><span class="hljs-params">country</span> =&gt;</span> <span class="hljs-keyword">this</span>.countriesServices.getCountryBordersByCode(country?.borders || []))
    ).subscribe(<span class="hljs-function"><span class="hljs-params">countryResponse</span> =&gt;</span> {
      <span class="hljs-keyword">this</span>.borders = countryResponse || [];
    });
  }
</div></code></pre>
<p>Primero definidmos un arreglo <strong>borders</strong> el cual contendrá la lista de paises fronterizos.</p>
<p>Segundo agregamos el Listener sobre el campo <strong>country</strong> con el <em>valueChanges</em></p>
<p>Cuando se seleccione un país occuren las siguientes tareas</p>
<ul>
<li>Limpamos el selector de las fronteras, por si se había mostrado algo anteriormente</li>
<li>Limpiamos internamente el arreglo de Borders.</li>
<li>Si el Código seleccionado es vacío o no definido, filtramos ese evento, es decir no continúa en el PIPE</li>
<li>Con SwitchMap hacemos un llamado al <strong>getCountryByCode</strong> para obtener la información del Pais seleccionado, recordemos que aca vamos a tener, el nombre del país, su código y lo mas importante los códigos de los países fronterizos en forma de arreglo de String[]</li>
<li>Con el Segundo Switch, mandamos el arreglo de paises fronterizos al método <strong>getCountryBordersByCode</strong> y este retornara un arreglo de Paises</li>
<li>Luego asignamos este arreglo de países a nuestra variable pública <strong>this.borders</strong></li>
</ul>
<p>Finalmente el template va a mostrar la lista de Fronteras con Nombres de Países</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"borders.length &gt; 0"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"row mb-3"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-6"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mb-3"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"form-label"</span>&gt;</span>Borders<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">formControlName</span>=<span class="hljs-string">"border"</span>
                <span class="hljs-attr">class</span>=<span class="hljs-string">"form-control"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">selected</span>&gt;</span>Seleccione la Frontera <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let border of borders"</span> [<span class="hljs-attr">value</span>]=<span class="hljs-string">"border.cca3"</span>&gt;</span>
                    {{ border.name }}
                <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-el-ciclo-de-un-componente">Nueva Sección: El ciclo de un componente</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>Se explicarán todos los pasos del ciclo de vida de un componente (también se aplican a las directivas que veremos después).</p>
<p>Creamos una nueva APP</p>
<pre class="hljs"><code><div>ng new 08-lifeCycle --standalone false --routing
</div></code></pre>
<p>Creamos un modulo</p>
<pre class="hljs"><code><div>ng g m products  --routing
CREATE src/app/products/products-routing.module.ts (251 bytes)
CREATE src/app/products/products.module.ts (288 bytes)
</div></code></pre>
<p>Agregamos el ProductsModule al Import del AppModule, no vamos hacer carga lazy en esta app.</p>
<p>Creamos dos directorios <strong>pages</strong> y <strong>comonents</strong> dentro de <strong>Products</strong></p>
<p>Creamos los componentes</p>
<pre class="hljs"><code><div>ng g c products/pages/product
ng g c products/components/price
</div></code></pre>
<pre class="hljs"><code><div>products
    ├── components
    ├── pages
    │   └── product
    │       ├── product.component.css
    │       ├── product.component.html
    │       ├── product.component.spec.ts
    │       └── product.component.ts
    ├── products.module.ts
    └── products-routing.module.ts
</div></code></pre>
<p>Luego agregamos las rutas necesarias y actualizamos los módulos, el objetivo es centrarnos en el ciclo de vida del componente.</p>
<p>En <strong>ProductComponent</strong> vamos a implementar todos los eventos del ciclo de vida, en el siguiente código se encuentran en el orden de ejecución.</p>
<div style="page-break-after: always;"></div>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> ProductComponent <span class="hljs-keyword">implements</span> OnChanges, OnInit, DoCheck, AfterContentInit, AfterContentChecked, AfterViewInit, AfterViewChecked, OnDestroy{
  
  <span class="hljs-comment">// Ocurre cuando Angular inicializa el componente</span>
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"></span>) { }
  
  <span class="hljs-comment">// Responde cuando Angular establece o restablece propiedades </span>
  <span class="hljs-comment">// de entrada vinculadas a datos. El método recibe un objeto </span>
  <span class="hljs-comment">// SimpleChanges de los valores de propiedad actuales y anteriores.</span>
  ngOnChanges(changes: SimpleChanges): <span class="hljs-built_in">void</span> {}
  
  <span class="hljs-comment">// Inicialice la directiva o el componente después de que </span>
  <span class="hljs-comment">// Angular muestre por primera vez las propiedades vinculadas </span>
  <span class="hljs-comment">// a datos y establezca las propiedades de entrada de la </span>
  <span class="hljs-comment">// directiva o el componente.</span>
  ngOnInit(): <span class="hljs-built_in">void</span> {}

  <span class="hljs-comment">// Detecta y actúa sobre cambios que Angular no puede o no </span>
  <span class="hljs-comment">// quiere detectar por sí solo.</span>
  ngDoCheck(): <span class="hljs-built_in">void</span> {}

  <span class="hljs-comment">// Responde después de que Angular proyecta contenido externo </span>
  <span class="hljs-comment">// en la vista del componente o en la vista en la que se </span>
  <span class="hljs-comment">// encuentra una directiva.</span>
  ngAfterContentInit(): <span class="hljs-built_in">void</span> {}

  <span class="hljs-comment">// Responde después de que Angular verifica el contenido </span>
  <span class="hljs-comment">// proyectado en la directiva o componente.</span>
  ngAfterContentChecked(): <span class="hljs-built_in">void</span> {}
  
  <span class="hljs-comment">// Responde después de que Angular inicializa las vistas </span>
  <span class="hljs-comment">// y las vistas secundarias del componente, o la vista </span>
  <span class="hljs-comment">// que contiene la directiva.</span>
  ngAfterViewInit(): <span class="hljs-built_in">void</span> {}

  <span class="hljs-comment">// Responde después de que Angular verifica las vistas </span>
  <span class="hljs-comment">// y las vistas secundarias del componente, o la vista </span>
  <span class="hljs-comment">// que contiene la directiva.</span>
  ngAfterViewChecked(): <span class="hljs-built_in">void</span> {}

  <span class="hljs-comment">// Limpiezas justo antes de que Angular destruya la directiva o componente. </span>
  <span class="hljs-comment">// Cancele la suscripción de Observables y separe los controladores </span>
  <span class="hljs-comment">// de eventos para evitar pérdidas de memoria.</span>
  ngOnDestroy(): <span class="hljs-built_in">void</span> {}
}
</div></code></pre>
<div style="page-break-after: always;"></div>
<p>Si agregamos un console.log con el nombre del método, veremos este orden de ejecución.</p>
<pre class="hljs"><code><div>ngOnInit
ngDoCheck
ngAfterContentInit
ngAfterContentChecked
ngAfterViewInit
ngAfterViewChecked
ngDoCheck
ngAfterContentChecked
ngAfterViewChecked
</div></code></pre>
<p>El <strong>ngOnChanges</strong> no se muestra porque el componente no tiene ningún elemento que pueda cambiar.</p>
<p>Si agregamos un propiedad pública</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> isProductVisible: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">true</span>;
</div></code></pre>
<p>Y lo enlazamos en el Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"isProductVisible = !isProductVisible"</span>&gt;</span>
    Testing
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>Al presinar el botón vemos estos eventos:</p>
<pre class="hljs"><code><div>ngDoCheck
ngAfterContentChecked
ngAfterViewChecked
</div></code></pre>
<h2 id="onchange-con-input">OnChange con @Input</h2>
<p>Agreguemos esto al PriceComponent</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> PriceComponent  <span class="hljs-keyword">implements</span> OnInit, OnChanges, OnDestroy {
  
  <span class="hljs-meta">@Input</span>() price: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;

  ngOnInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'    PriceComponent - ngOnInit'</span>);
  }

  ngOnChanges(changes: SimpleChanges): <span class="hljs-built_in">void</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'    PriceComponent - ngOnChanges'</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'    '</span> + <span class="hljs-built_in">JSON</span>.stringify(changes));
  }

  ngOnDestroy(): <span class="hljs-built_in">void</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'    PriceComponent - ngOnDestroy'</span>);
  }
}
</div></code></pre>
<p>Usemos este componente en nuestro ProductoComponent</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>product works!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">app-price</span> 
    *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isProductVisible"</span>
    [<span class="hljs-attr">price</span>]=<span class="hljs-string">"currentPrice"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">app-price</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"isProductVisible = !isProductVisible"</span>&gt;</span>
    Toggle product
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"increasePrice()"</span>&gt;</span>
    Increase Price
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p><strong>increasePrice()</strong> aumenta en +1 el precio del producto, por medio de una propiedad public <code>currentPrice</code></p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> currentPrice: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
</div></code></pre>
<p>Si ejecutamos la APP, vemos el Log, observamos</p>
<img src="./imagenes/lifeCycleApp01.png" alt="ngClass ejemplo" style="margin-right: 10px; max-width: 55%; height: auto; border: 1px solid black" />
<p>El objecto <strong>change</strong> también tiene una propiedad <strong>previousValue</strong> la cual es undefined, por eso no se muestra en el JSON.</p>
<p>Agreguemos un <code>console.log(JSON.stringify(changes));</code> al  <strong>ngOnChanges</strong> del ProductComonent, Si presionamos el botón que incrementa el precio en +1 veremos esto:</p>
<img src="./imagenes/lifeCycleApp02.png" alt="ngClass ejemplo" style="margin-right: 10px; max-width: 55%; height: auto; border: 1px solid black" />
<p>Primero, el cambio de la propiedad interna <strong>currentPrice</strong> de ProductComponent, no dispara el <strong>ngOnChanges</strong> del ProductoComponent, pero si el del componente hijo <strong>PriceComponent</strong> Y podemos ver el valor anterior y el nuevo valor, además de que <strong>firstChange</strong> es <strong>false</strong></p>
<p>EL <strong>firstChange</strong> es TRUE solo al momento de que el componente Padre le pasa el valor de <strong>0</strong> y el componente precio lo acepta por el <strong>@Input</strong></p>
<p>Tocar repetidamente el botón de incrementar el precio generará estos cambios en el objeto <strong>changes</strong> :</p>
<pre class="hljs"><code><div>[
  {<span class="hljs-attr">"price"</span>:{<span class="hljs-attr">"currentValue"</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">"firstChange"</span>:<span class="hljs-literal">true</span>}},
  {<span class="hljs-attr">"price"</span>:{<span class="hljs-attr">"previousValue"</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">"currentValue"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"firstChange"</span>:<span class="hljs-literal">false</span>}},
  {<span class="hljs-attr">"price"</span>:{<span class="hljs-attr">"previousValue"</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">"currentValue"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"firstChange"</span>:<span class="hljs-literal">false</span>}},
  {<span class="hljs-attr">"price"</span>:{<span class="hljs-attr">"previousValue"</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">"currentValue"</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">"firstChange"</span>:<span class="hljs-literal">false</span>}}
]
</div></code></pre>
<p>El registro anterior incluye la primera carga del componente, y luego click  en el botón incrementar precio por 3 veces.</p>
<h2 id="ondesroy-del-hijo">OnDesroy del Hijo</h2>
<p>Tenemos este botón:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"isProductVisible = !isProductVisible"</span>&gt;</span>
    Toggle product
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>El cual cambia el valor de la proiedad <strong>isProductVisible</strong> y a la vez oculta el componente Hijo</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">app-price</span> 
    *<span class="hljs-attr">ngIf</span>=<span class="hljs-string">"isProductVisible"</span>
    [<span class="hljs-attr">price</span>]=<span class="hljs-string">"currentPrice"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">app-price</span>&gt;</span>
</div></code></pre>
<p>Si presionamos ese botón, el componente Precio debe de destruirse.</p>
<img src="./imagenes/lifeCycleApp03.png" alt="ngClass ejemplo" style="margin-right: 10px; max-width: 55%; height: auto; border: 1px solid black" />
<p>Si nuevamente presionamos el mismo botón, el ciclo de vida de dicho componente se activa nuevamente y mostrará su estado inicial</p>
<pre class="hljs"><code><div>{<span class="hljs-attr">"price"</span>:{<span class="hljs-attr">"currentValue"</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">"firstChange"</span>:<span class="hljs-literal">true</span>}}
</div></code></pre>
<h2 id="ondestroy">OnDestroy</h2>
<p>Cualquier observable que emita constantemente valores debe ser cancelada su suscripción al momento de destruir el elemento, caso contrario, seguirá emitiendo valores y puede causar problemas de rendimiento.</p>
<p>Si creamos el siguiente Interval</p>
<pre class="hljs"><code><div>ngOnInit(): <span class="hljs-built_in">void</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'    PriceComponent - ngOnInit'</span>);
  interval(<span class="hljs-number">1000</span>).subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'    PriceComponent - interval: '</span> + value);
  });
}
</div></code></pre>
<p>Al salir del Componente Price (ocultarlo) veremos en consola que seguirá imprimieno valores.</p>
<p>Podemos usar el OnDestroy para cancelar la suscripción. Para ello asignaremos la suscripción a una variable pública</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> interval$?: Subscription;

ngOnInit(): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">this</span>.interval$ = interval(<span class="hljs-number">1000</span>).subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'    PriceComponent - interval: '</span> + value);
  });
}

ngOnDestroy(): <span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">this</span>.interval$?.unsubscribe();
}

</div></code></pre>
<p>Con este cambio, al ocultar el componente, se llama el ngOnDestroy y el intervalo se cancela. Generalmente cualquier objeto que genere o escuche eventos, debe ser destruido junto con el componente.</p>
<div style="page-break-after: always;"></div>
<h1 id="nueva-secci%C3%B3n-nueva-aplicaci%C3%B3n-de-mapas">Nueva Sección: Nueva Aplicación de Mapas:</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>¿Qué veremos en esta sección?</p>
<p>Este es un breve listado de los temas fundamentales:</p>
<p>-Manejo de librerías escritas en JavaScript en TypeScript
-Uso de Mapas basados en Mapbox (el API es similar a la de Google Maps)
-Marcadores
-Eventos
-FlyTo
-Coordenadas geográficas
-Componentes para re-utilización de mapas
-Mantener objetos de forma persistente
-@types
-Zoom
-Range</p>
<h2 id="crear-nueva-app-y-preparar-proyecto">Crear nueva APP y preparar proyecto</h2>
<p>Hacemos lo de siempre, creamos nueva app, modificamos el scrit del start para agregar el parámetro <strong>-o</strong>, limpiamos el APPComponent.html</p>
<pre class="hljs"><code><div>ng new 09-mapApp --standalone false --routing
</div></code></pre>
<p>Agregamos en el index.html la referencias a bootstrap y fontawesome</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">integrity</span>=<span class="hljs-string">"sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://kit.fontawesome.com/8de2637909.js"</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">"anonymous"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</div></code></pre>
<p>Creamos un módulo:</p>
<pre class="hljs"><code><div>$ ng g m maps --routing
CREATE src/app/maps/maps-routing.module.ts (247 bytes)
CREATE src/app/maps/maps.module.ts (272 bytes)
</div></code></pre>
<p>Componentes</p>
<pre class="hljs"><code><div>ng g c maps/components/mini-map
ng g c maps/components/site-menu

ng g c maps/layout/maps-layout --skip-selector
ng g c maps/pages/full-screen-page --skip-selector
ng g c maps/pages/properties-page --skip-selector
</div></code></pre>
<p>--skip-selector omite agregar un selector al componente, este es un componente especial que no necesita ser incluido como un TAG, eso lo veremos adelante. El componente se crea de la siguiente forma:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  templateUrl: <span class="hljs-string">'./maps-layout.component.html'</span>,
  styleUrl: <span class="hljs-string">'./maps-layout.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MapsLayoutComponent {

}
</div></code></pre>
<p>Esta es la estructura actual:</p>
<pre class="hljs"><code><div>[fcruz@fedora src]$ tree app
app
├── app.component.css
├── app.component.html
├── app.component.ts
├── app.module.ts
├── app-routing.module.ts
└── maps
    ├── components
    │   ├── mini-map
    │   │   ├── mini-map.component.css
    │   │   ├── mini-map.component.html
    │   │   └── mini-map.component.ts
    │   └── site-menu
    │       ├── site-menu.component.css
    │       ├── site-menu.component.html
    │       └── site-menu.component.ts
    ├── layout
    │   └── maps-layout
    │       ├── maps-layout.component.css
    │       ├── maps-layout.component.html
    │       └── maps-layout.component.ts
    ├── maps.module.ts
    ├── maps-routing.module.ts
    └── pages
        ├── full-screen-page
        │   ├── full-screen-page.component.css
        │   ├── full-screen-page.component.html
        │   └── full-screen-page.component.ts
        └─── properties-page
            ├── properties-page.component.css
            ├── properties-page.component.html
            └── properties-page.component.ts

</div></code></pre>
<p>En el archivo <strong>src/app/maps/layout/maps-layout/maps-layout.component.html</strong> agregamos un <code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></p>
<p>En el <strong>AppRoutingModule</strong> agregamos una ruta, con carga Lazy</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">'maps'</span>,
    loadChildren: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./maps/maps.module'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.MapsModule)
  },
  {
    path: <span class="hljs-string">'**'</span>,
    redirectTo: <span class="hljs-string">'maps'</span>,
  }
];
</div></code></pre>
<p>En cambio, en el <strong>MapsRoutingModule</strong> agregaremos estas rutas:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> routes: Routes = [
  {
    path: <span class="hljs-string">''</span>,
    component : MapsLayoutComponent,
    children: [
      { path: <span class="hljs-string">'fullscreen'</span>, component: FullScreenPageComponent},
      { path: <span class="hljs-string">'proerties'</span>, component: PropertiesPageComponent},
      { path: <span class="hljs-string">'**'</span>, redirectTo: <span class="hljs-string">'fullscreen'</span>}
    ]
  }
];
</div></code></pre>
<h2 id="maps-menu-lateral-sidemenu">Maps Menu lateral (sideMenu)</h2>
<p>Nuestro <strong>MapsLayoutComponent</strong> va a funcionar como un contenedor general de neustros componentes dentro del modulo de mapas. <strong>MapsLayoutComponent</strong> es un componente que pone a disposición un espacio ara que los demas componentes puedas renderizarse.</p>
<p>Vamos a crear el sideMenu y lo primero que haremos es agregar al template del <strong>MapsLayoutComponent</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">maps-site-menu</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">maps-site-menu</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">router-outlet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-outlet</span>&gt;</span>
</div></code></pre>
<p>POdemos agrear CSS a los componentes desde el padre, podríamos agregar esto en nuestro Layout CSS Component:</p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">maps-site-menu</span> {
    <span class="hljs-attribute">left</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">position</span>: fixed;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">180px</span>;
    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">999</span>;
}
</div></code></pre>
<p>Para agregar las opciones al menú, haremos lo mismo, creamos un menuItem[] y agregamos rutas y nombre de los items. Esto lo hacemos en el <strong>siteMenuComponent</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">interface</span> MenuItems {
  router: <span class="hljs-built_in">string</span>,
  name: <span class="hljs-built_in">string</span>,
  icon: <span class="hljs-built_in">string</span>
}

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'maps-site-menu'</span>,
  templateUrl: <span class="hljs-string">'./site-menu.component.html'</span>,
  styleUrl: <span class="hljs-string">'./site-menu.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SiteMenuComponent {
  <span class="hljs-keyword">public</span> menuItems: MenuItems[] = [
    { router: <span class="hljs-string">'/maps/fullscreen'</span>, name: <span class="hljs-string">'Fullscreen'</span>, icon: <span class="hljs-string">'fa-solid fa-desktop'</span> },
    { router: <span class="hljs-string">'/maps/properties'</span>, name: <span class="hljs-string">'Properties'</span>, icon: <span class="hljs-string">'fa-solid fa-house-chimney-window'</span>},
  ]
}
</div></code></pre>
<p>Y luego renderizamos con un NgFor.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> 
    *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of menuItems"</span> 
    <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>
    [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"[item.router]"</span>
    <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"menu-icon {{item.icon}}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>{{ item.name}}
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<h2 id="mapbox">MapBox</h2>
<p>Usaremos este servicio, de modo que se crear una cuenta y un token de accesso el cual usaremos en nuestro ENV files.</p>
<h2 id="archivos-de-environment">Archivos de Environment</h2>
<p>Crearemos los siguientes archivos</p>
<table>
<thead>
<tr>
<th>Nombre</th>
<th>Ubicación</th>
<th>Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td>.env</td>
<td>./</td>
<td>Contiene las variables de entorno, no se sube al repositorio</td>
</tr>
<tr>
<td>.env.template</td>
<td>./</td>
<td>Es un template que indica que variables se deben de configurar. Este archivo si debe ser enviado al repositorio</td>
</tr>
<tr>
<td>.environment</td>
<td>./src/environments</td>
<td>Se genera mediante un script, Angular usará este archivo para inicializar nuestras variables. Al igual que .env, es un archivo que no debe enviarse al respositorio, ya que contentrá información sensible.</td>
</tr>
</tbody>
</table>
<h2 id="construir-archivo-environment">Construir Archivo .environment</h2>
<p>Usaremos <strong>dotenv</strong>: Dotenv es un módulo de dependencia cero que carga variables de entorno desde un archivo .env en <strong>Process.env</strong>.</p>
<p>instalamos el paquete en Desarrollo:</p>
<pre class="hljs"><code><div>$ npm install dotenv --save-dev
</div></code></pre>
<p>Necesitamos transformar el contenido en nuestro archivo privado .env en una versión para que el entorno de Angular pueda usar dichas variables, para ello usaremos node y un script en JS</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { writeFileSync, mkdirSync } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-built_in">require</span>(<span class="hljs-string">'dotenv'</span>).config();

<span class="hljs-keyword">const</span> targetPath = <span class="hljs-string">'./src/environments/environment.ts'</span>;

<span class="hljs-keyword">const</span> envFileContent = <span class="hljs-string">`
export const environment = {
    mapbox_key: "<span class="hljs-subst">${process.env.MAPBOX_KEY}</span>",
};
`</span>;

mkdirSync(<span class="hljs-string">'./src/environments'</span>, { <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> });

writeFileSync(targetPath, envFileContent);
</div></code></pre>
<p>Este script <strong>set-envs.js</strong> lo guardamos en el path <strong>./scripts/set-envs.js</strong></p>
<p>Luego agregamos una nueva tarea en el package.json</p>
<pre class="hljs"><code><div><span class="hljs-string">"scripts"</span>: {
  <span class="hljs-attr">"envs"</span>: <span class="hljs-string">"node ./scripts/set-envs.js"</span>,
  <span class="hljs-attr">"start"</span>: <span class="hljs-string">"npm run evns &amp;&amp; ng serve -o"</span>,
  <span class="hljs-attr">"watch"</span>: <span class="hljs-string">"npm run evns &amp;&amp; ng build --watch --configuration development"</span>,
}
</div></code></pre>
<p>Probamos la tarea</p>
<pre class="hljs"><code><div>$ npm run envs

&gt; 09-map-app@0.0.0 envs
&gt; node ./scripts/set-envs.js
</div></code></pre>
<p>Como resultado podremos ver nuestro nuevo archivo de configuración <strong>./src/environments/environment.ts</strong></p>
<p>Para acceder a las propiedades debemos importar este archivo</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { environment } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../../environments/environment'</span>;
</div></code></pre>
<p>y luego acceder a la propiedad requerida</p>
<pre class="hljs"><code><div>accessToken: environment.mapbox_key
</div></code></pre>
<h2 id="instalar-mapbox">Instalar MapBox</h2>
<pre class="hljs"><code><div>npm install --save mapbox-gl
npm i --save-dev @types/mapbox-gl
</div></code></pre>
<p>NOTA: MapBox  no incluye archivos de declaración (*d.ts), por lo tanto debemos instalador  por separado</p>
<p>Agregamos en el index.html</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">'https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.css'</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">'stylesheet'</span> /&gt;</span>
</div></code></pre>
<h2 id="importar-mapbox">Importar MapBox</h2>
<p>Implementaremos el mapa en el <strong>fullScreenComponent</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { AfterViewInit, Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;
<span class="hljs-keyword">import</span> { Map } <span class="hljs-keyword">from</span> <span class="hljs-string">'mapbox-gl'</span>;
<span class="hljs-keyword">import</span> { environment } <span class="hljs-keyword">from</span> <span class="hljs-string">'../../../../environments/environment'</span>;


<span class="hljs-meta">@Component</span>({
  templateUrl: <span class="hljs-string">'./full-screen-page.component.html'</span>,
  styleUrl: <span class="hljs-string">'./full-screen-page.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> FullScreenPageComponent <span class="hljs-keyword">implements</span> AfterViewInit{

  <span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'map'</span>) divMap!: ElementRef;

  ngAfterViewInit(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> Map({
      accessToken: environment.mapbox_key,
      container: <span class="hljs-keyword">this</span>.divMap.nativeElement,, <span class="hljs-comment">// container ID</span>
      style: <span class="hljs-string">'mapbox://styles/mapbox/streets-v12'</span>, <span class="hljs-comment">// style URL</span>
      center: [<span class="hljs-number">-74.5</span>, <span class="hljs-number">40</span>], <span class="hljs-comment">// starting position [lng, lat]</span>
      zoom: <span class="hljs-number">9</span>, <span class="hljs-comment">// starting zoom</span>
    });
  }
}
</div></code></pre>
<p>Agregamos un contenedor, usaremos una referencia local <strong>#map</strong> visible en el componente mediante el <strong>ViewChild</strong></p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> #<span class="hljs-attr">map</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"map"</span>&gt;</span>
    
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Y algo de estilo:</p>
<pre class="hljs"><code><div><span class="hljs-selector-id">#map</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100vw</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;
}
</div></code></pre>
<br/>
<img src="./imagenes/mapApp01.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 90%; height: auto; border: 1px solid black" />
<h2 id="zoom-inout">Zoom in/out</h2>
<p>Implementamos estos métodos:</p>
<pre class="hljs"><code><div>
  <span class="hljs-keyword">public</span> zoom: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>;

  mapListener() {
    <span class="hljs-keyword">this</span>.map.on(<span class="hljs-string">'zoom'</span>, <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {
      <span class="hljs-keyword">this</span>.zoom = <span class="hljs-keyword">this</span>.map.getZoom();
    });
  }

  OnRangeChange(event: <span class="hljs-built_in">any</span>) {
    <span class="hljs-keyword">this</span>.map.setZoom(event.target.value);
  }

  zoomIn() {
    <span class="hljs-keyword">this</span>.map.zoomIn();
  }

  zoomOut() {
    <span class="hljs-keyword">this</span>.map.zoomOut();
  }
  
</div></code></pre>
<p>El método <strong>this.mapListener();</strong> lo llamaremos dentro del <strong>ngAfterViewInit</strong> luego de inicializar el mapa.</p>
<p>Y el Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> #<span class="hljs-attr">map</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"map"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"floatting-range p-2"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"floatting-content"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"zoomOut()"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
            <span class="hljs-attr">type</span>=<span class="hljs-string">"range"</span>
            <span class="hljs-attr">class</span>=<span class="hljs-string">"form-range p-2"</span>
            <span class="hljs-attr">min</span>=<span class="hljs-string">"-2"</span>
            <span class="hljs-attr">max</span>=<span class="hljs-string">"18"</span>
            [<span class="hljs-attr">value</span>]=<span class="hljs-string">"zoom"</span>
            (<span class="hljs-attr">change</span>)=<span class="hljs-string">"OnRangeChange($event)"</span>
        &gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"zoomIn()"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-label"</span>&gt;</span>
        Zoom: {{zoom | number: '1.1-1'}}
        <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>
        Ln, Lt: {{"0,0"}}
        
    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Un poco de estilo</p>
<pre class="hljs"><code><div><span class="hljs-selector-id">#map</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100vw</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;
}

<span class="hljs-selector-class">.floatting-range</span> {
    <span class="hljs-attribute">position</span>: fixed;
    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">left</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">999</span>;
    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;
    <span class="hljs-attribute">background-color</span>: white;
    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;
    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>);
}

<span class="hljs-selector-class">.floatting-content</span> {
    <span class="hljs-attribute">display</span>: flex;
    <span class="hljs-attribute">align-items</span>: center;
}
</div></code></pre>
<p>Con esto hemos implementado un Zoom in/out en el mapa y hemos conectado los controles en ambas dirrecciones, al hacer zoom en el mapa se actualizan los controles, al mover los controles se cambia el zoom en el mapa.</p>
<br/>
<img src="./imagenes/mapApp02.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 50%; height: auto; border: 1px solid black" />
<h2 id="latitud-y-longitud">Latitud y Longitud</h2>
<p>Creemos una propiedad <strong>lngLat</strong> y la inicializamos</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> currentLatLng: LngLat = <span class="hljs-keyword">new</span> LngLat(<span class="hljs-number">-85.579765542208</span>, <span class="hljs-number">11.577481296026505</span>);
</div></code></pre>
<p>Mostramos en el Template</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-label"</span>&gt;</span>
      Zoom: {{zoom | number: '1.1-1'}} - ({{currentLatLng.lat | number: '1.4-4'}}, {{currentLatLng.lng | number: '1.4-4'}})   
<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
</div></code></pre>
<p>La enlazamos al Mapa con un Listener</p>
<pre class="hljs"><code><div>mapListener() {

    <span class="hljs-comment">// Otros listeners</span>

    <span class="hljs-keyword">this</span>.map.on(<span class="hljs-string">'move'</span>, <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {
      <span class="hljs-keyword">this</span>.currentLatLng = <span class="hljs-keyword">this</span>.map.getCenter();;
    });
  }
</div></code></pre>
<p>Y listo, con esto podemos ver la Latitud y Longitud del centro del mapa cada vez que nos desplazamos.</p>
<h2 id="destruir-listeners">Destruir Listeners</h2>
<p>Una tarea importante es limpiar los listeners creados en nuestro componente:</p>
<pre class="hljs"><code><div>ngOnDestroy(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.map.remove();
  }
</div></code></pre>
<h2 id="marcadores">Marcadores</h2>
<p>El siguiente método, crea un marcador, en la latitud y longitud definida con las opciones enviadas como parámetro</p>
<pre class="hljs"><code><div>addMarker(lngLat: LngLat, options: MarkerOptions) {
    <span class="hljs-keyword">const</span> marker = <span class="hljs-keyword">new</span> Marker({
      ...options
    })
      .setLngLat(lngLat)
      .addTo(<span class="hljs-keyword">this</span>.map);

    <span class="hljs-keyword">if</span> (options.draggable) {
      marker.on(<span class="hljs-string">'drag'</span>, <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {
        <span class="hljs-keyword">this</span>.currentLatLng = marker.getLngLat();
      });
    }
  }
</div></code></pre>
<p>Podemos llamar este método con las siguientes opciones:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> makerOptions = {
      color: <span class="hljs-string">'#FF0000'</span>,
      draggable: <span class="hljs-literal">true</span>,
    }
    <span class="hljs-keyword">this</span>.addMarker(<span class="hljs-keyword">this</span>.currentLatLng, makerOptions);
</div></code></pre>
<p>Esto genera:
<br/>
<img src="./imagenes/mapApp03.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 60%; height: auto; border: 1px solid black" /></p>
<h2 id="guardar-en-el-local-storage">Guardar en el Local Storage</h2>
<p>Los marcadores que agregamos pueden ser guardados en el local storage, necesitamos dos métodos para guardar y recuperar la información. Nota, no vamos a guardar el objeto Marker, ya que contiene muchos datos, en su lugar guardaremos la latitud y longitud.</p>
<h2 id="c%C3%B3digo-completo-del-componente">Código completo del Componente</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> MarkerInfo {
  marker: Marker;
  color: <span class="hljs-built_in">string</span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> PlainMarker {
  lng: <span class="hljs-built_in">number</span>;
  lat: <span class="hljs-built_in">number</span>;
  color: <span class="hljs-built_in">string</span>;
}

<span class="hljs-meta">@Component</span>({
  templateUrl: <span class="hljs-string">'./full-screen-page.component.html'</span>,
  styleUrl: <span class="hljs-string">'./full-screen-page.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> FullScreenPageComponent <span class="hljs-keyword">implements</span> OnInit, AfterViewInit, OnDestroy{

  <span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'map'</span>) divMap?: ElementRef;

  <span class="hljs-keyword">public</span> zoom: <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span>;

  <span class="hljs-keyword">public</span> map!: Map;

  <span class="hljs-keyword">public</span> currentLatLng: LngLat = <span class="hljs-keyword">new</span> LngLat(<span class="hljs-number">-85.579765542208</span>, <span class="hljs-number">11.577481296026505</span>);

  <span class="hljs-keyword">private</span> markersList: MarkerInfo[] = [];

  ngOnInit(): <span class="hljs-built_in">void</span> {
    
  }
  
  ngAfterViewInit(): <span class="hljs-built_in">void</span> {

    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.divMap) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> Map({
      accessToken: environment.mapbox_key,
      container: <span class="hljs-keyword">this</span>.divMap.nativeElement, <span class="hljs-comment">// container ID</span>
      style: <span class="hljs-string">'mapbox://styles/mapbox/streets-v12'</span>, <span class="hljs-comment">// style URL</span>
      center: <span class="hljs-keyword">this</span>.currentLatLng, <span class="hljs-comment">// starting position [lng, lat]</span>
      zoom: <span class="hljs-keyword">this</span>.zoom, <span class="hljs-comment">// starting zoom</span>
    });

    <span class="hljs-keyword">this</span>.mapListener();

    <span class="hljs-keyword">this</span>.loadFromLocalStorage();
  }

  ngOnDestroy(): <span class="hljs-built_in">void</span> {
    <span class="hljs-keyword">this</span>.map.remove();
  }

  mapListener() {
    <span class="hljs-keyword">this</span>.map.on(<span class="hljs-string">'zoom'</span>, <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {
      <span class="hljs-keyword">this</span>.zoom = <span class="hljs-keyword">this</span>.map.getZoom();
    });

    <span class="hljs-keyword">this</span>.map.on(<span class="hljs-string">'move'</span>, <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {
      <span class="hljs-keyword">this</span>.currentLatLng = <span class="hljs-keyword">this</span>.map.getCenter();;
    });
  }

  addMarker(lngLat: LngLat, options: MarkerOptions) {

    <span class="hljs-keyword">const</span> color = options.color || 
      <span class="hljs-string">'#'</span> + <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">16777215</span>).toString(<span class="hljs-number">16</span>);
    
      <span class="hljs-keyword">const</span> marker = <span class="hljs-keyword">new</span> Marker({
      ...options,
      color
    })
      .setLngLat(lngLat)
      .addTo(<span class="hljs-keyword">this</span>.map);
    
    <span class="hljs-keyword">if</span> (options.draggable) {
      marker.on(<span class="hljs-string">'dragend'</span>, <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {
        <span class="hljs-keyword">this</span>.saveToLocalStorage();
      });
    }

    <span class="hljs-keyword">this</span>.markersList.push({marker, color});
    <span class="hljs-keyword">this</span>.saveToLocalStorage();
  }

  removerMarker(index: <span class="hljs-built_in">number</span>) {
    <span class="hljs-keyword">const</span> marker = <span class="hljs-keyword">this</span>.markersList[index];
    marker.marker.remove();
    <span class="hljs-keyword">this</span>.markersList.splice(index, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">this</span>.saveToLocalStorage();
  }

  flyToMarker(index: <span class="hljs-built_in">number</span>) {
    <span class="hljs-keyword">const</span> marker = <span class="hljs-keyword">this</span>.markersList[index];
    <span class="hljs-keyword">this</span>.map.flyTo({
      center: marker.marker.getLngLat()
    });
  }

  OnRangeChange(event: <span class="hljs-built_in">any</span>) {
    <span class="hljs-keyword">this</span>.map.setZoom(event.target.value);
  }

  zoomIn() {
    <span class="hljs-keyword">this</span>.map.zoomIn();
  }

  zoomOut() {
    <span class="hljs-keyword">this</span>.map.zoomOut();
  }
  
  onAddNewMarker() {
    <span class="hljs-keyword">const</span> makerOptions = {
      draggable: <span class="hljs-literal">true</span>,
    }
    <span class="hljs-keyword">this</span>.addMarker(<span class="hljs-keyword">this</span>.map.getCenter(), makerOptions);
  }

  <span class="hljs-keyword">get</span> markers(): MarkerInfo[]{
    <span class="hljs-keyword">return</span> [...this.markersList]
  }

  saveToLocalStorage() {
    <span class="hljs-keyword">const</span> plainMarkers: PlainMarker[] = <span class="hljs-keyword">this</span>.markersList.map(<span class="hljs-function">(<span class="hljs-params">marker</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> {
        lng: marker.marker.getLngLat().lng,
        lat: marker.marker.getLngLat().lat,
        color: marker.color
      }
    });

    localStorage.setItem(<span class="hljs-string">'plainmarkers'</span>, <span class="hljs-built_in">JSON</span>.stringify(plainMarkers));
  }

  loadFromLocalStorage() {
    <span class="hljs-keyword">const</span> plainMarkers = localStorage.getItem(<span class="hljs-string">'plainmarkers'</span>);
    <span class="hljs-keyword">if</span> (!plainMarkers) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">const</span> markers: PlainMarker[] = <span class="hljs-built_in">JSON</span>.parse(plainMarkers);
    markers.forEach(<span class="hljs-function">(<span class="hljs-params">marker</span>) =&gt;</span> {
      <span class="hljs-keyword">const</span> lngLat = <span class="hljs-keyword">new</span> LngLat(marker.lng, marker.lat);
      <span class="hljs-keyword">const</span> markerOptions = {
        color: marker.color,
        draggable: <span class="hljs-literal">true</span>
      }
      <span class="hljs-keyword">this</span>.addMarker(lngLat, markerOptions);
    });
  }
}
</div></code></pre>
<p>Y el Template completo</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> #<span class="hljs-attr">map</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"map"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"floatting-style floatting-range p-2"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"floatting-content"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"zoomOut()"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> 
            <span class="hljs-attr">type</span>=<span class="hljs-string">"range"</span>
            <span class="hljs-attr">class</span>=<span class="hljs-string">"form-range p-2"</span>
            <span class="hljs-attr">min</span>=<span class="hljs-string">"-2"</span>
            <span class="hljs-attr">max</span>=<span class="hljs-string">"18"</span>
            [<span class="hljs-attr">value</span>]=<span class="hljs-string">"zoom"</span>
            (<span class="hljs-attr">change</span>)=<span class="hljs-string">"OnRangeChange($event)"</span>
        &gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"zoomIn()"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary m-2"</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"onAddNewMarker()"</span>&gt;</span>
            +Marker
        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"form-label"</span>&gt;</span>
        Zoom: {{zoom | number: '1.1-1'}} - ({{currentLatLng.lat | number: '1.4-4'}}, {{currentLatLng.lng | number: '1.4-4'}})   
    <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"floatting-style floatting-markers-list p-2"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"floatting"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>Markers<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">li</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let marker of markers; let i = index"</span> 
                <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>
                (<span class="hljs-attr">dblclick</span>)=<span class="hljs-string">"removerMarker(i)"</span>
                (<span class="hljs-attr">click</span>)=<span class="hljs-string">"flyToMarker(i)"</span>&gt;</span>
                M {{ i + 1 }} [{{marker.marker.getLngLat().lat| number: '1.4-4'}}, {{marker.marker.getLngLat().lng | number: '1.4-4'}}]
            <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

</div></code></pre>
<p>Resultado final del Full Map View:</p>
<br/>
<img src="./imagenes/mapApp04.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 100%; height: auto; border: 1px solid black" />
<h2 id="lista-de-propiedades-uso-de-minimaps">Lista de Propiedades, uso de miniMaps</h2>
<p>El objetivo es mostrar una grilla, simulando una lista de propiedades, con un mapa mostrando la ubicación, el mapa lo implementaremos con el componente miniMap.</p>
<p>Este componente recibe una latitud, longitud y se muestra en modo <strong>interactive: false</strong> lo que bloque las funciones de zoom, drag, etc. Es una imagen estática.</p>
<p>El código del Minimap:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-mini-map'</span>,
  templateUrl: <span class="hljs-string">'./mini-map.component.html'</span>,
  styleUrl: <span class="hljs-string">'./mini-map.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MiniMapComponent {

  <span class="hljs-meta">@Input</span>() <span class="hljs-keyword">public</span> lngLat: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];
  <span class="hljs-meta">@ViewChild</span>(<span class="hljs-string">'map'</span>) divMap?: ElementRef;
  
  <span class="hljs-keyword">public</span> map!: Map;

  ngAfterViewInit(): <span class="hljs-built_in">void</span> {

    <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.divMap || !<span class="hljs-keyword">this</span>.lngLat) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> Map({
      accessToken: environment.mapbox_key,
      container: <span class="hljs-keyword">this</span>.divMap.nativeElement, 
      style: <span class="hljs-string">'mapbox://styles/mapbox/streets-v12'</span>, 
      center: <span class="hljs-keyword">this</span>.lngLat, 
      zoom: <span class="hljs-number">12</span>,
      interactive: <span class="hljs-literal">false</span>
    });

    <span class="hljs-keyword">new</span> Marker().setLngLat(<span class="hljs-keyword">this</span>.lngLat).addTo(<span class="hljs-keyword">this</span>.map);
  }

}
</div></code></pre>
<p>Y el Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> #<span class="hljs-attr">map</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Un poco de estilos</p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">div</span> {
    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;
    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span>;
}
</div></code></pre>
<p>Y listo, ahora trabajaremos en el PropertiesComponent, usará un arreglo de propiedades, y usara el miniMap para mostrarla</p>
<p>El código del componente:</p>
<pre class="hljs"><code><div>mport { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-keyword">interface</span> House {
  title: <span class="hljs-built_in">string</span>;
  description: <span class="hljs-built_in">string</span>;
  lngLat: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];
  price: <span class="hljs-built_in">number</span>;
}

<span class="hljs-meta">@Component</span>({
  templateUrl: <span class="hljs-string">'./properties-page.component.html'</span>,
  styleUrl: <span class="hljs-string">'./properties-page.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> PropertiesPageComponent {

  <span class="hljs-keyword">public</span> houses: House[] = [
    {
      title: <span class="hljs-string">'Casa residencial, Canadá'</span>,
      description: <span class="hljs-string">'Bella propiedad en Katana, Canadá'</span>,
      lngLat: [ <span class="hljs-number">-75.92722289474008</span>, <span class="hljs-number">45.280015511264466</span>],
      price: <span class="hljs-number">1000000</span>
    },
    <span class="hljs-comment">// Se agregan mas elementos en este arreglo</span>
  ]
}

</div></code></pre>
<p>Y el Template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row mt-3"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Listado de Propiedades<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row mt-2"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let house of houses"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"col-4 mb-2"</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">""</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-img-top"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">app-mini-map</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-img-top"</span> [<span class="hljs-attr">lngLat</span>]=<span class="hljs-string">"house.lngLat"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-mini-map</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-body"</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">h5</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-title"</span>&gt;</span>{{house.title}}<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-text"</span>&gt;</span>{{house.description}}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Como resultado obtenemos:</p>
<br/>
<img src="./imagenes/mapApp05.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 100%; height: auto; border: 1px solid black" />
<p>Con esto se da por conluida esta sección, hemos aprendido como icorporar otro mapa, hay muchas cosas que se pueden hacer, pero esto representa una buena base a partir de la cual se pueden implementar muchas aplicaciones con Mapas.</p>
<h1 id="nueva-secci%C3%B3n-standalone-component">Nueva Sección: Standalone Component</h1>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>Esta sección tiene por objetivo explicar y usar esta nueva característica de Angular, puntualmente veremos:</p>
<ul>
<li>¿Qué son?</li>
<li>¿Para qué sirven?</li>
<li>¿Cómo usarlos?</li>
<li>¿Cómo cargarlos de forma perezosa?</li>
<li>¿Cómo conectarlos entre sí?</li>
<li>¿Cómo integrarlos en módulos y componentes tradicionales?</li>
</ul>
<h2 id="standalone-como-p%C3%A1gina">Standalone Como Página</h2>
<p>Un &quot;standalone component&quot; en Angular es un componente independiente que puede ser utilizado de manera autónoma sin depender de otros componentes en la misma aplicación. Para crearlo con el CLI usaremos <code>--standalone true</code></p>
<p>El siguiente comando crear un <strong>standalone component</strong> en la ruta <code>app/alone/pages/</code></p>
<pre class="hljs"><code><div>ng g c alone/pages/alone-page --standalone true
</div></code></pre>
<p>Exáminemos la estructura de este componente:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;

<span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-alone-page'</span>,
  standalone: <span class="hljs-literal">true</span>,
  imports: [],
  templateUrl: <span class="hljs-string">'./alone-page.component.html'</span>,
  styleUrl: <span class="hljs-string">'./alone-page.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AlonePageComponent {

}
</div></code></pre>
<p>El componente es a su vez un módulo que puede ser importado por otro componente.</p>
<p>A continuación cargaremos el componente en modo Lazy, en lugar de loadChilder, usaremos el loadComponent, y cargaremos el AlonePageComponent tal como si fuese un módulo.</p>
<pre class="hljs"><code><div>{
  path: <span class="hljs-string">'alone'</span>,
  loadComponent: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'./alone/pages/alone-page/alone-page.component'</span>).then(<span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m.AlonePageComponent)
}
</div></code></pre>
<p>Si navegamos al path <code>http://localhost:4200/alone</code> veremos nuestro compomente, y no lo hemos importado en ninún lugar, solamente lo hemos cargado como si fuese un módulo más.</p>
<h2 id="standalone-como-componente-reutilizable">Standalone Como Componente reutilizable</h2>
<p>Creemos un nuevo componente</p>
<pre class="hljs"><code><div>ng g c alone/components/counter-alone --standalone
</div></code></pre>
<p>Agregamos un simple contador</p>
<pre class="hljs"><code><div><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> CounterAloneComponent {

  <span class="hljs-keyword">public</span> counter: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;
  
  decrement() {
    <span class="hljs-keyword">this</span>.counter--;
  }

  increment() {
    <span class="hljs-keyword">this</span>.counter++;
  }
}
</div></code></pre>
<p>Un template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Counter   {{ counter }}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"decrement()"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> (<span class="hljs-attr">click</span>)=<span class="hljs-string">"increment()"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>Si queremos usar este Standalone componente dentro de otro standalone component, debemos importar el componente, en este caso el Counter dentro del componente padre,</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-alone-page'</span>,
  standalone: <span class="hljs-literal">true</span>,
  imports: [CounterAloneComponent],
  templateUrl: <span class="hljs-string">'./alone-page.component.html'</span>,
  styleUrl: <span class="hljs-string">'./alone-page.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AlonePageComponent {

}
</div></code></pre>
<p>Y luego ya podemos usarlo en el template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">counter-alone</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">counter-alone</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<h2 id="standalone-en-m%C3%B3dulos-tradicionales">Standalone en Módulos Tradicionales</h2>
<p>Si un componente Standalone debe ser utilizando dentro de un compomente tradicional, debemos importar el Standalone Component dentro del módulo que contiene el componente padre. Por ejemplo, en el siguiente código, importamos el CounterAloneComponent dentro del <strong>MapsModule</strong> a partir de ese momento, cualquier componente definido dentro de <strong>MapsModule</strong> podrá usar dicho componente.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@NgModule</span>({
  declarations: [
    <span class="hljs-comment">// Other declarations</span>
  ],
  imports: [
    CommonModule,
    MapsRoutingModule,
  ]
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> MapsModule { }
</div></code></pre>
<h2 id="ejercicio-pr%C3%A1ctico">Ejercicio práctico</h2>
<p>Agregaremos un Like Button, en cada propiedad a la venta en nuestro PropertiesComponent, usando standalone component. Este boton acepta la cantidad de likes inciales y emite un evento cuado el visitante da click en el botón</p>
<p>Primero creamos el componente:</p>
<pre class="hljs"><code><div>ng g c standalone/components/like-btn --standalone
</div></code></pre>
<p>El código del componente sería:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'like-btn'</span>,
  standalone: <span class="hljs-literal">true</span>,
  imports: [],
  templateUrl: <span class="hljs-string">'./like-btn.component.html'</span>,
  styleUrl: <span class="hljs-string">'./like-btn.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> LikeBtnComponent {

  <span class="hljs-meta">@Input</span>() likes: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;

  <span class="hljs-meta">@Output</span>() onLike : EventEmitter&lt;<span class="hljs-built_in">number</span>&gt; = <span class="hljs-keyword">new</span> EventEmitter&lt;<span class="hljs-built_in">number</span>&gt;();

  liked() {
    <span class="hljs-keyword">this</span>.likes++;
    <span class="hljs-keyword">this</span>.onLike.emit(<span class="hljs-number">1</span>);
  }

}
</div></code></pre>
<p>El template:</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
    <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>
    <span class="hljs-attr">class</span>=<span class="hljs-string">"btn btn-primary"</span>
    (<span class="hljs-attr">click</span>)=<span class="hljs-string">"liked()"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"fa-regular fa-thumbs-up"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"badge badge-light"</span>&gt;</span>{{ likes }}<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
</div></code></pre>
<p>Lo importamos en el <strong>MapsModule</strong> y lo usamos en nuestro template</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card-footer"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">like-btn</span> [<span class="hljs-attr">likes</span>]=<span class="hljs-string">"0"</span> (<span class="hljs-attr">onLike</span>)=<span class="hljs-string">"liked(i)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">like-btn</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</div></code></pre>
<p>Finalmente debemos definir el método del lado del <strong>PropertiesPageComponent</strong> que va a procesar el evento final, puede ser una llamada AJAX para aumentar los likes de dicha propiedad.</p>
<pre class="hljs"><code><div>liked(index: <span class="hljs-built_in">number</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.houses[index].title + <span class="hljs-string">' liked'</span>);
}
</div></code></pre>
<p>Resultado:</p>
<br/>
<img src="./imagenes/mapApp06.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 40%; height: auto; border: 1px solid black" />
<h2 id="transformar-el-sidemenu-en-standalone">Transformar el SideMenu en Standalone</h2>
<p>Debemos mover todo el directorio del componente, que se encuentra dentro del módulo de maps, al directorio donde tenemos los standalone component.</p>
<p>ACtualizamos las referencias y agregamos al SideMenu:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  standalone: <span class="hljs-literal">true</span>,
  imports: [CommonModule, RouterModule]
})
</div></code></pre>
<p>CommonModule lo importamos porque usamos el NGFor para iterar sobre las opcones del menú, y el RouterModule porque agregamos links en cada opción.</p>
<pre class="hljs"><code><div><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> 
    *<span class="hljs-attr">ngFor</span>=<span class="hljs-string">"let item of menuItems"</span> 
    <span class="hljs-attr">class</span>=<span class="hljs-string">"list-group-item"</span>
    [<span class="hljs-attr">routerLink</span>]=<span class="hljs-string">"[item.router]"</span>
    <span class="hljs-attr">routerLinkActive</span>=<span class="hljs-string">"active"</span>
    &gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"menu-icon {{item.icon}}"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span>{{ item.name}}
    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
</div></code></pre>
<p>Con esto ya tenemos el componente en modo standalone, ahora debemos hacer los cambios donde sea que debamos utilizarlo, primero en el <strong>MapsModule</strong>, porque el menú lo usamos en el <strong>MapsLayoutComponent</strong> que está dentro de dicho módulo, y segundo lo agregaremos en nuestro <strong>AlonePageComponent</strong> dado que este también es un standalone component, entonces lo importamos directamente en dicho componente:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Component</span>({
  selector: <span class="hljs-string">'app-alone-page'</span>,
  standalone: <span class="hljs-literal">true</span>,
  imports: [CounterAloneComponent, SiteMenuComponent],
  templateUrl: <span class="hljs-string">'./alone-page.component.html'</span>,
  styleUrl: <span class="hljs-string">'./alone-page.component.css'</span>
})
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> AlonePageComponent {

}
</div></code></pre>
<p>Y luego lo ubicamos en el template, y finalmente movemos algunos estilos CSS que habámos creado a nivel del Menu, como compomente del MAPA, para que ahora sean parte del Standalone Components, de esta forma nuestro menú contiene todo lo necesario para renderizarse correctamente donde se necesite</p>
<pre class="hljs"><code><div><span class="hljs-selector-tag">ul</span> {
    <span class="hljs-attribute">left</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">position</span>: fixed;
    <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>;
    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">999</span>;
}
</div></code></pre>
<p>Antes, debemos agregar una opción más al MenuItems para poder navegar al Alone Page</p>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> menuItems: MenuItems[] = [
    { router: <span class="hljs-string">'/maps/fullscreen'</span>, name: <span class="hljs-string">'Fullscreen'</span>, icon: <span class="hljs-string">'fa-solid fa-desktop'</span> },
    { router: <span class="hljs-string">'/maps/properties'</span>, name: <span class="hljs-string">'Properties'</span>, icon: <span class="hljs-string">'fa-solid fa-house-chimney-window'</span>},
    { router: <span class="hljs-string">'/alone'</span>, name: <span class="hljs-string">'Alone'</span>, icon: <span class="hljs-string">'fa-solid fa-user'</span>}
  ]
</div></code></pre>
<p>El resultado:</p>
<br/>
<img src="./imagenes/mapApp07.png" alt="Diseño Básico" style="margin-right: 10px; max-width: 70%; height: auto; border: 1px solid black" />
<div style="page-break-after: always;"></div>
<h2 id="nueva-seccion---directivas-personalizadas-y-signals">Nueva Seccion - Directivas personalizadas y Signals</h2>
<h2 id="%C2%BFqu%C3%A9-veremos-en-esta-secci%C3%B3n">¿Qué veremos en esta sección?</h2>
<p>En esta sección vamos a crear directivas personalizadas en Angular. La idea será crear una directiva robusta que nos sirva para resumir la forma cómo los errores en los formularios son mostrados, y así no tener que colocar infinidad de condiciones dentro del HTML.</p>
<p>Esta directiva que crearemos, es de uso real y dará una buena idea de qué podemos hacer con ellas.</p>
<p>Además iniciaremos el estudio de los Signals:</p>
<aside class="nota-informativa">
  <p>Una señal es un wrapper alrededor de un valor que puede notificar a los consumidores interesados cuando ese valor cambia. Las señales pueden contener cualquier valor, desde primitivas simples hasta estructuras de datos complejas.</p>
</aside>
<aside class="nota-importante">
  <p>Disponibles a partir de la versión 16 de Angular.</p>
</aside>

</body>
</html>
